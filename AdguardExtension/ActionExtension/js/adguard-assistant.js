(function() {
var Resources = function () {
var _resources = {
"button.css": "LmFkZ3VhcmQtYWxlcnQgewogICAgY3Vyc29yOiBwb2ludGVyOwogICAgbGVmdDogMDsKICAgIHRvcDogMDsKICAgIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50OwogICAgZm9udDogMTJweCBBcmlhbCwgc2Fucy1zZXJpZiAhaW1wb3J0YW50OwogICAgbGluZS1oZWlnaHQ6IDEuNSAhaW1wb3J0YW50OwogICAgei1pbmRleDogMjE0NzQ4MzY0NiAhaW1wb3J0YW50OwogICAgd2lkdGg6IGF1dG8gIWltcG9ydGFudDsKICAgIGJhY2tncm91bmQ6IG5vbmUgIWltcG9ydGFudDsKICAgIGhlaWdodDogYXV0byAhaW1wb3J0YW50OwogICAgem9vbTogMSAhaW1wb3J0YW50OwogICAgZGlzcGxheTogaW5saW5lLWJsb2NrICFpbXBvcnRhbnQ7CiAgICBtYXJnaW46IDAgIWltcG9ydGFudDsKICAgIGJvcmRlcjogMCAhaW1wb3J0YW50OwogICAgcGFkZGluZzogMCAhaW1wb3J0YW50OwogICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTsKICAgIG9wYWNpdHk6IDAuNzsKICAgIHRvdWNoLWFjdGlvbjogbm9uZTsKICAgIC1tcy10b3VjaC1hY3Rpb246IG5vbmU7CiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7Cn0KCi5hZGd1YXJkLWhpZGUgewogICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50Owp9CgouYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLXJpZ2h0IHsKICAgIGxlZnQ6IGF1dG87CiAgICByaWdodDogMDsKfQoKLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi1sZWZ0IHsKICAgIGxlZnQ6IDA7CiAgICByaWdodDogYXV0bzsKfQoKLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi10b3AgewogICAgdG9wOiAwOwogICAgYm90dG9tOiBhdXRvOwp9CgouYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLWJvdHRvbSB7CiAgICB0b3A6IGF1dG87CiAgICBib3R0b206IDA7Cn0KCi5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tdG9wLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi1sZWZ0IHsKICAgIGxlZnQ6IDA7CiAgICByaWdodDogYXV0bzsKICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoNXB4LCA1cHgsIDApOwp9CgouYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLXRvcC5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tcmlnaHQgewogICAgbGVmdDogYXV0bzsKICAgIHJpZ2h0OiAwOwogICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtNXB4LCA1cHgsIDApOwp9CgouYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLWJvdHRvbS5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tbGVmdCB7CiAgICBsZWZ0OiAwOwogICAgcmlnaHQ6IGF1dG87CiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDVweCwgLTVweCwgMCk7Cn0KCi5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tYm90dG9tLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi1yaWdodCB7CiAgICBsZWZ0OiBhdXRvOwogICAgcmlnaHQ6IDA7CiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC01cHgsIC01cHgsIDApOwp9CgouYWRndWFyZC1sb2dvIHsKICAgIGRpc3BsYXk6IGlubGluZS1ibG9jayAhaW1wb3J0YW50OwogICAgdmVydGljYWwtYWxpZ246IHRvcCAhaW1wb3J0YW50OwogICAgd2lkdGg6IDFlbSAhaW1wb3J0YW50OwogICAgbGluZS1oZWlnaHQ6IDEgIWltcG9ydGFudDsKICAgIGJhY2tncm91bmQ6IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlWVlJHTFRnaVB6NE5DandoUkU5RFZGbFFSU0J6ZG1jZ1VGVkNURWxESUNJdEx5OVhNME12TDBSVVJDQlRWa2NnTVM0eEx5OUZUaUlnSW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTDBkeVlYQm9hV056TDFOV1J5OHhMakV2UkZSRUwzTjJaekV4TG1SMFpDSStEUW84SVMwdElFTnlaV0YwYjNJNklFTnZjbVZzUkZKQlZ5QllOeUF0TFQ0TkNqeHpkbWNnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JaUI0Yld3NmMzQmhZMlU5SW5CeVpYTmxjblpsSWlCM2FXUjBhRDBpTVRBd2NIZ2lJR2hsYVdkb2REMGlNVEF3Y0hnaUlIWmxjbk5wYjI0OUlqRXVNU0lnYzNSNWJHVTlJbk5vWVhCbExYSmxibVJsY21sdVp6cG5aVzl0WlhSeWFXTlFjbVZqYVhOcGIyNDdJSFJsZUhRdGNtVnVaR1Z5YVc1bk9tZGxiMjFsZEhKcFkxQnlaV05wYzJsdmJqc2dhVzFoWjJVdGNtVnVaR1Z5YVc1bk9tOXdkR2x0YVhwbFVYVmhiR2wwZVRzZ1ptbHNiQzF5ZFd4bE9tVjJaVzV2WkdRN0lHTnNhWEF0Y25Wc1pUcGxkbVZ1YjJSa0lnMEtkbWxsZDBKdmVEMGlNQ0F3SURFd01DQXhNREFpRFFvZ2VHMXNibk02ZUd4cGJtczlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MekU1T1RrdmVHeHBibXNpUGcwS0lEeGtaV1p6UGcwS0lDQThjM1I1YkdVZ2RIbHdaVDBpZEdWNGRDOWpjM01pUGcwS0lDQWdQQ0ZiUTBSQlZFRmJEUW9nSUNBZ0xtWnBiREFnZTJacGJHdzZJelJHUWtVNE5YME5DaUFnSUYxZFBnMEtJQ0E4TDNOMGVXeGxQZzBLSUR3dlpHVm1jejROQ2lBOFp5QnBaRDBpMEtIUXU5QyswTGxmZURBd01qQmZNU0krRFFvZ0lEeHRaWFJoWkdGMFlTQnBaRDBpUTI5eVpXeERiM0p3U1VSZk1FTnZjbVZzTFV4aGVXVnlJaTgrRFFvZ0lEeHdZWFJvSUdOc1lYTnpQU0ptYVd3d0lpQmtQU0pOTlRBZ01XTXhOaXd3SURNMUxETWdOVEFzTVRFZ01Dd3hOeUF4TERZd0lDMDFNQ3c0T1NBdE5UQXNMVEk1SUMwMU1Dd3ROeklnTFRVd0xDMDRPU0F4Tml3dE9DQXpOU3d0TVRFZ05UQXNMVEV4ZW0wd0lEaGpMVEUwTERBZ0xUSTVMRE1nTFRReExEZ2dNQ3d4T0NBMExEVXdJRFF4TERjMElETTRMQzB5TkNBME1Td3ROVFlnTkRJc0xUY3pJQzB4TXl3dE5pQXRNamdzTFRrZ0xUUXlMQzA1ZWlJdlBnMEtJQ0E4Y0dGMGFDQmpiR0Z6Y3owaVptbHNNQ0lnWkQwaVRUYzNJREkxWXpJc01DQXhMREFnTWl3eGJDMHpNaUEwTVdNd0xEQWdMVEl5TEMweU5pQXRNak1zTFRJMklESXNMVEVnT0N3dE5TQXhNeXd3YkRFd0lERXlJREkzSUMweU4yTXhMQzB4SURJc0xURWdNeXd0TVd3d0lEQjZJaTgrRFFvZ1BDOW5QZzBLUEM5emRtYytEUW89KSBuby1yZXBlYXQgMCAwL2NvdmVyICFpbXBvcnRhbnQ7CiAgICBmb250LXNpemU6IGluaGVyaXQgIWltcG9ydGFudDsKfQoKLmFkZ3VhcmQtYS1sb2dvOmhvdmVyIC5hZGd1YXJkLWxvZ28gewogICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F4TURBZ01UQXdJajQ4Y0dGMGFDQmtQU0pOTlRBZ01HTXhOU0F3SURNekxqSWdNeTQySURRNExqRWdNVEV1TkNBd0lERTNMakV1TWlBMU9TNDJMVFE0TGpFZ09EZ3VOa014TGpjZ056RWdNUzQ1SURJNExqVWdNUzQ1SURFeExqUWdNVFl1T0NBekxqWWdNelVnTUNBMU1DQXdlbTB3SURndU5HTXRNVE11TlNBd0xUSTRJRE10TXprdU55QTRMakl1TXlBeE55NDJJRE11TmlBME9TNDRJRE01TGpjZ056TXVOaUF6Tmk0eExUSXpMamtnTXprdU5DMDFOaUF6T1M0M0xUY3pMalJETnpnZ01URXVOU0EyTXk0MUlEZ3VOQ0ExTUNBNExqUjZiVEkyTGpRME5pQXhOUzR4Tnpkak1TNDROVFl1TkRZeElERXVNRGs1TGpBNUlESXVNelUwTGpreU0wdzBPQzR5SURZMkxqUlRNall1TVNBME1DQXlOaUEwTUdNeExqVXRNUzR4SURjdU55MDFMaklnTVRJdU15NHliRGt1TmlBeE1TNDNURGN6TGpVZ01qVmpMamc0T0MwdU9UWTVJREV1TnpFNUxURXVNVFEzSURJdU9UUTJMVEV1TkRJemVpSWdabWxzYkQwaUkyWm1aaUl2UGp3dmMzWm5QZz09KSAhaW1wb3J0YW50Owp9Ci5hZGd1YXJkLWEtbG9nbzpob3ZlcnsKIGJhY2tncm91bmQ6ICM0RkJFODUgIWltcG9ydGFudDsKfQoKLmFkZ3VhcmQtbG9nb19fd2hpdGUgewogICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaVZWUkdMVGdpUHo0TkNqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK0RRbzhJUzB0SUVOeVpXRjBiM0k2SUVOdmNtVnNSRkpCVnlCWU55QXRMVDROQ2p4emRtY2dlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklpQjRiV3c2YzNCaFkyVTlJbkJ5WlhObGNuWmxJaUIzYVdSMGFEMGlNVEF3Y0hnaUlHaGxhV2RvZEQwaU1UQXdjSGdpSUhabGNuTnBiMjQ5SWpFdU1TSWdjM1I1YkdVOUluTm9ZWEJsTFhKbGJtUmxjbWx1WnpwblpXOXRaWFJ5YVdOUWNtVmphWE5wYjI0N0lIUmxlSFF0Y21WdVpHVnlhVzVuT21kbGIyMWxkSEpwWTFCeVpXTnBjMmx2YmpzZ2FXMWhaMlV0Y21WdVpHVnlhVzVuT205d2RHbHRhWHBsVVhWaGJHbDBlVHNnWm1sc2JDMXlkV3hsT21WMlpXNXZaR1E3SUdOc2FYQXRjblZzWlRwbGRtVnViMlJrSWcwS2RtbGxkMEp2ZUQwaU1DQXdJREV3TUNBeE1EQWlEUW9nZUcxc2JuTTZlR3hwYm1zOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUd4cGJtc2lQZzBLSUR4a1pXWnpQZzBLSUNBOGMzUjViR1VnZEhsd1pUMGlkR1Y0ZEM5amMzTWlQZzBLSUNBZ1BDRmJRMFJCVkVGYkRRb2dJQ0FnTG1acGJEQWdlMlpwYkd3NkkwWkZSa1ZHUlgwTkNpQWdJRjFkUGcwS0lDQThMM04wZVd4bFBnMEtJRHd2WkdWbWN6NE5DaUE4WnlCcFpEMGkwS0hRdTlDKzBMbGZlREF3TWpCZk1TSStEUW9nSUR4dFpYUmhaR0YwWVNCcFpEMGlRMjl5Wld4RGIzSndTVVJmTUVOdmNtVnNMVXhoZVdWeUlpOCtEUW9nSUR4d1lYUm9JR05zWVhOelBTSm1hV3d3SWlCa1BTSk5OVEFnTVdNeE5pd3dJRE0xTERNZ05UQXNNVEVnTUN3eE55QXhMRFl3SUMwMU1DdzRPU0F0TlRBc0xUSTVJQzAxTUN3dE56SWdMVFV3TEMwNE9TQXhOaXd0T0NBek5Td3RNVEVnTlRBc0xURXhlbTB3SURoakxURTBMREFnTFRJNUxETWdMVFF4TERnZ01Dd3hPQ0EwTERVd0lEUXhMRGMwSURNNExDMHlOQ0EwTVN3dE5UWWdORElzTFRjeklDMHhNeXd0TmlBdE1qZ3NMVGtnTFRReUxDMDVlaUl2UGcwS0lDQThjR0YwYUNCamJHRnpjejBpWm1sc01DSWdaRDBpVFRjM0lESTFZeklzTUNBeExEQWdNaXd4YkMwek1pQTBNV013TERBZ0xUSXlMQzB5TmlBdE1qTXNMVEkySURJc0xURWdPQ3d0TlNBeE15d3diREV3SURFeUlESTNJQzB5TjJNeExDMHhJRElzTFRFZ015d3RNV3d3SURCNklpOCtEUW9nUEM5blBnMEtQQzl6ZG1jK0RRbz0pICFpbXBvcnRhbnQ7Cn0KCi5hZGd1YXJkLWEtbG9nbyB7CiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2sgIWltcG9ydGFudDsKICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3ggIWltcG9ydGFudDsKICAgIHZlcnRpY2FsLWFsaWduOiB0b3AgIWltcG9ydGFudDsKICAgIHdpZHRoOiA0MHB4ICFpbXBvcnRhbnQ7CiAgICBoZWlnaHQ6IDQwcHggIWltcG9ydGFudDsKICAgIHBhZGRpbmc6IDEwcHggMCAwICFpbXBvcnRhbnQ7CiAgICBmb250LXNpemU6IDIwcHggIWltcG9ydGFudDsKICAgIHRleHQtYWxpZ246IGNlbnRlciAhaW1wb3J0YW50OwogICAgYm9yZGVyOiAxcHggc29saWQgI2NkY2RjZCAhaW1wb3J0YW50OwogICAgYm9yZGVyLXJhZGl1czogNTAlICFpbXBvcnRhbnQ7CiAgICBiYWNrZ3JvdW5kOiAjZmZmICFpbXBvcnRhbnQ7Cn0KCi5hZGd1YXJkLWEtbG9nb19fc21hbGwgewogICAgd2lkdGg6IDI0cHggIWltcG9ydGFudDsKICAgIGhlaWdodDogMjRweCAhaW1wb3J0YW50OwogICAgZm9udC1zaXplOiAxMnB4ICFpbXBvcnRhbnQ7CiAgICBwYWRkaW5nOiA2cHggMCAwICFpbXBvcnRhbnQ7Cn0KCi5hZGd1YXJkLWxvZ286YmVmb3JlIHsKICAgIGNvbnRlbnQ6ICJcMDBhMCIgIWltcG9ydGFudDsKfQoKLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi1ib3R0b20uYWRndWFyZC1hc3Npc3RhbnQtYnV0dG9uLXJlc3BlY3QtdmsgewogICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtNzBweCwgLTVweCwgMCk7Cn0KCi5hZGd1YXJkLWFzc2lzdGFudC1idXR0b24tYm90dG9tLmFkZ3VhcmQtYXNzaXN0YW50LWJ1dHRvbi1yZXNwZWN0LWZiIHsKICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTVweCwgLTQwcHgsIDApOwp9CgpAbWVkaWEgcHJpbnQgewogICAgLmFkZ3VhcmQtYWxlcnQsICNhZGd1YXJkLWFzc2lzdGFudC1kaWFsb2cgewogICAgICAgIGRpc3BsYXk6IG5vbmUhaW1wb3J0YW50OwogICAgICAgIG9wYWNpdHk6IDAhaW1wb3J0YW50OwogICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbiFpbXBvcnRhbnQ7CiAgICB9Cn0K",

"selector.css": "I2FkZ3VhcmQtYXNzaXN0YW50LWRpYWxvZyB7CiAgICBvdmVyZmxvdzogaGlkZGVuICFpbXBvcnRhbnQ7CiAgICB6LWluZGV4OiAyMTQ3NDgzNjQ3ICFpbXBvcnRhbnQ7CiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlICFpbXBvcnRhbnQ7Cn0KCi5zZ19zZWxlY3RlZCB7Cn0KCi5zZ19zdWdnZXN0ZWQgewogICAgYmFja2dyb3VuZC1jb2xvcjogI0ZGNSAhaW1wb3J0YW50OwogICAgYmFja2dyb3VuZC1pbWFnZTogbm9uZSAhaW1wb3J0YW50Owp9Cgouc2dfYm9yZGVyIHsKICAgIHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50OwogICAgei1pbmRleDogMjE0NzQ4MzY0NiAhaW1wb3J0YW50OwogICAgYmFja2dyb3VuZDogd2hpdGUgIWltcG9ydGFudDsKICAgIGJhY2tncm91bmQtY29sb3I6ICMxM2EzNWUgIWltcG9ydGFudDsKICAgIG1hcmdpbjogMHB4ICFpbXBvcnRhbnQ7CiAgICBwYWRkaW5nOiAwcHggIWltcG9ydGFudDsKICAgIGRpc3BsYXk6IGJsb2NrOwogICAgZmxvYXQ6IG5vbmUgIWltcG9ydGFudDsKICAgIGJvcmRlcjogMCAhaW1wb3J0YW50OwogICAgZm9udC1zdHlsZTogbm9ybWFsICFpbXBvcnRhbnQ7CiAgICBvdXRsaW5lOiAwICFpbXBvcnRhbnQ7CiAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmUgIWltcG9ydGFudDsKICAgIHRleHQtYWxpZ246IGxlZnQgIWltcG9ydGFudDsKICAgIGxpbmUtaGVpZ2h0OiAxMnB4OwogICAgYm94LXNpemluZzogY29udGVudC1ib3ggIWltcG9ydGFudDsKfQoKLnNnX2JvdHRvbV9ib3JkZXIgewogICAgZm9udC1zaXplOiAxMHB4ICFpbXBvcnRhbnQ7CiAgICBmb250LXdlaWdodDogYm9sZDsKICAgIGNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50OwogICAgcGFkZGluZzogMnB4IDBweCAycHggNXB4ICFpbXBvcnRhbnQ7CiAgICBvdmVyZmxvdzogaGlkZGVuICFpbXBvcnRhbnQ7Cn0KCi5zZ19ib3JkZXJfcmVkIHsKICAgIGJhY2tncm91bmQtY29sb3I6ICNGMDAgIWltcG9ydGFudDsKfQoKLnNnX2hpZ2hsaWdodGVkIHsKfQoKLnNnX3JlamVjdGVkIHsKICAgIGJhY2tncm91bmQtY29sb3I6ICNGQTgwNzIgIWltcG9ydGFudDsKICAgIGJhY2tncm91bmQtaW1hZ2U6IG5vbmUgIWltcG9ydGFudDsKfQoKaW1nLnNnX3JlamVjdGVkIHsKICAgIGJvcmRlcjogNXB4IHNvbGlkICNGMDAgIWltcG9ydGFudDsKfQoKaW1nLnNnX3N1Z2dlc3RlZCB7CiAgICBib3JkZXI6IDVweCBzb2xpZCAjRkY1ICFpbXBvcnRhbnQ7Cn0KCmltZy5zZ19zZWxlY3RlZCB7CiAgICBib3JkZXI6IDVweCBzb2xpZCAjMEYwICFpbXBvcnRhbnQ7Cn0KCiNfc2dfZGl2LnNnX3RvcCB7CiAgICB0b3A6IDVweCAhaW1wb3J0YW50Owp9CgojX3NnX2Rpdi5zZ19ib3R0b20gewogICAgYm90dG9tOiA1cHggIWltcG9ydGFudDsKfQoKI19zZ19kaXYgaW5wdXQgewogICAgbWFyZ2luLXJpZ2h0OiAxMHB4ICFpbXBvcnRhbnQ7CiAgICBmb250LXNpemU6IDE1cHggIWltcG9ydGFudDsKfQoKI19zZ19wYXRoX2ZpZWxkIHsKICAgIHdpZHRoOiA0MDBweCAhaW1wb3J0YW50Owp9CgojX3NnX2RpdiAuc2dfbmV3X2xpbmUgewogICAgY2xlYXI6IGJvdGggIWltcG9ydGFudDsKfQoKI19zZ19kaXYgLnNnX29wdGlvbiB7CiAgICBmbG9hdDogbGVmdCAhaW1wb3J0YW50Owp9CgojX3NnX2RpdiAuc2dfc2VsZWN0ZWRfb3B0aW9uIHsKICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOwp9CgouYWRndWFyZC1wbGFjZWhvbGRlciB7CiAgICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBOEFBQUFQQ0FNQUFBQU1DR1Y0QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUF5RnBWRmgwV0UxTU9tTnZiUzVoWkc5aVpTNTRiWEFBQUFBQUFEdy9lSEJoWTJ0bGRDQmlaV2RwYmowaTc3dS9JaUJwWkQwaVZ6Vk5NRTF3UTJWb2FVaDZjbVZUZWs1VVkzcHJZemxrSWo4K0lEeDRPbmh0Y0cxbGRHRWdlRzFzYm5NNmVEMGlZV1J2WW1VNmJuTTZiV1YwWVM4aUlIZzZlRzF3ZEdzOUlrRmtiMkpsSUZoTlVDQkRiM0psSURVdU5TMWpNREUwSURjNUxqRTFNVFE0TVN3Z01qQXhNeTh3TXk4eE15MHhNam93T1RveE5TQWdJQ0FnSUNBZ0lqNGdQSEprWmpwU1JFWWdlRzFzYm5NNmNtUm1QU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh4T1RrNUx6QXlMekl5TFhKa1ppMXplVzUwWVhndGJuTWpJajRnUEhKa1pqcEVaWE5qY21sd2RHbHZiaUJ5WkdZNllXSnZkWFE5SWlJZ2VHMXNibk02ZUcxd1BTSm9kSFJ3T2k4dmJuTXVZV1J2WW1VdVkyOXRMM2hoY0M4eExqQXZJaUI0Yld4dWN6cDRiWEJOVFQwaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wyMXRMeUlnZUcxc2JuTTZjM1JTWldZOUltaDBkSEE2THk5dWN5NWhaRzlpWlM1amIyMHZlR0Z3THpFdU1DOXpWSGx3WlM5U1pYTnZkWEpqWlZKbFppTWlJSGh0Y0RwRGNtVmhkRzl5Vkc5dmJEMGlRV1J2WW1VZ1VHaHZkRzl6YUc5d0lFTkRJQ2hYYVc1a2IzZHpLU0lnZUcxd1RVMDZTVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRG8xT1VNNU9VRTRNRVpFUXpVeE1VVXlPVEF6TTBFeU9EUXlSamM1UWpJMlF5SWdlRzF3VFUwNlJHOWpkVzFsYm5SSlJEMGllRzF3TG1ScFpEbzFPVU01T1VFNE1VWkVRelV4TVVVeU9UQXpNMEV5T0RReVJqYzVRakkyUXlJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSjRiWEF1YVdsa09qVTVRems1UVRkRlJrUkROVEV4UlRJNU1ETXpRVEk0TkRKR056bENNalpESWlCemRGSmxaanBrYjJOMWJXVnVkRWxFUFNKNGJYQXVaR2xrT2pVNVF6azVRVGRHUmtSRE5URXhSVEk1TURNelFUSTROREpHTnpsQ01qWkRJaTgrSUR3dmNtUm1Pa1JsYzJOeWFYQjBhVzl1UGlBOEwzSmtaanBTUkVZK0lEd3ZlRHA0YlhCdFpYUmhQaUE4UDNod1lXTnJaWFFnWlc1a1BTSnlJajgrOXJKbTl3QUFBQVpRVEZSRjIrN2cxT2ZaK0xYL0VnQUFBQ3RKUkVGVWVOcGlZSVFBQmhoQTVUSXlvSEloZkNTMURLaGNFQi9GSkFaRzdBWXpvTmxMTHk1QWdBRUFNaWdBYXI2VGNxa0FBQUFBU1VWT1JLNUNZSUk9KTsKfQouYWRndWFyZC1wbGFjZWhvbGRlci1pY29uIHsKICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNZQUFBQXdDQVlBQUFCOXNnZ29BQUFBR1hSRldIUlRiMlowZDJGeVpRQkJaRzlpWlNCSmJXRm5aVkpsWVdSNWNjbGxQQUFBQXlGcFZGaDBXRTFNT21OdmJTNWhaRzlpWlM1NGJYQUFBQUFBQUR3L2VIQmhZMnRsZENCaVpXZHBiajBpNzd1L0lpQnBaRDBpVnpWTk1FMXdRMlZvYVVoNmNtVlRlazVVWTNwcll6bGtJajgrSUR4NE9uaHRjRzFsZEdFZ2VHMXNibk02ZUQwaVlXUnZZbVU2Ym5NNmJXVjBZUzhpSUhnNmVHMXdkR3M5SWtGa2IySmxJRmhOVUNCRGIzSmxJRFV1TlMxak1ERTBJRGM1TGpFMU1UUTRNU3dnTWpBeE15OHdNeTh4TXkweE1qb3dPVG94TlNBZ0lDQWdJQ0FnSWo0Z1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNGdQSEprWmpwRVpYTmpjbWx3ZEdsdmJpQnlaR1k2WVdKdmRYUTlJaUlnZUcxc2JuTTZlRzF3UFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdklpQjRiV3h1Y3pwNGJYQk5UVDBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5NFlYQXZNUzR3TDIxdEx5SWdlRzFzYm5NNmMzUlNaV1k5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5elZIbHdaUzlTWlhOdmRYSmpaVkpsWmlNaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVFXUnZZbVVnVUdodmRHOXphRzl3SUVORElDaFhhVzVrYjNkektTSWdlRzF3VFUwNlNXNXpkR0Z1WTJWSlJEMGllRzF3TG1scFpEcEVOa05CUVROR01rWkVRelV4TVVVeVFqVkZNa1pFTVVGRlJqbEdPRVF5TXlJZ2VHMXdUVTA2Ukc5amRXMWxiblJKUkQwaWVHMXdMbVJwWkRwRU5rTkJRVE5HTTBaRVF6VXhNVVV5UWpWRk1rWkVNVUZGUmpsR09FUXlNeUkrSUR4NGJYQk5UVHBFWlhKcGRtVmtSbkp2YlNCemRGSmxaanBwYm5OMFlXNWpaVWxFUFNKNGJYQXVhV2xrT2tRMlEwRkJNMFl3UmtSRE5URXhSVEpDTlVVeVJrUXhRVVZHT1VZNFJESXpJaUJ6ZEZKbFpqcGtiMk4xYldWdWRFbEVQU0o0YlhBdVpHbGtPa1EyUTBGQk0wWXhSa1JETlRFeFJUSkNOVVV5UmtReFFVVkdPVVk0UkRJeklpOCtJRHd2Y21SbU9rUmxjMk55YVhCMGFXOXVQaUE4TDNKa1pqcFNSRVkrSUR3dmVEcDRiWEJ0WlhSaFBpQThQM2h3WVdOclpYUWdaVzVrUFNKeUlqOCs0OXNiRHdBQUFsOUpSRUZVZU5yTW1FMG81VkVZeHE5dkptcEkyU0JaakNTTktLR3drREUwbThtZzJRd3pFdGtOQ2VVakd5VmhZVGJUVUlaRU1XbWtiQ1ZsdzlRa0c0bWFtbWJLNXpBV3VMcWVrM2NoM1c3ditaOFAvN2QrdS9jY3p6M25lTTd6UDBIdGcxMmVSNndVa0ErZWcyeVFET0xBWWVnamlJa0VyMEFqeUFQUmZucDh0b1c5QmUyMFFvSEthMHRZRWhnQ1Zkd0JOb1FWZ0NtUUtqUEl0TEFLTUF0aVpBZWFGRllNNXNBVEo0T0REWWw2QnVhZGlqSWxMQUpNZ0hpRk9XSk1iR1VmbWFac0hZTjk4QnZzNmhhV0Exb2x4MnlDTWZBZC9ERjErUHNsNXJ3R1BXQVlYSm44cjN3TlhqQjdMMEVOclpMUnd5L202WkRvcnc4a1NxZXdVcERMN1AwRXBtM1lSUkJvWWZidWdXNWJQcFpESzhhcFRuQnFTOWg3V2pXT0xYeXo1ZnhQUVNXanowZFdjbVByRWhkSk5JRXBySWxXMTk4WjdhVVYxU2FzUVdKbkFwM0R6dytGcVd4bE9tVjJIZVhWZWNiZWdIQlRZUzVZWVZ5MXllanJWSmhJcHhsdUZQYUI2VjFXaFNXUVRYamNKcXlLakZWbmhhZ2FiQmhGRms3dGduUG1scCtvQ2hOYm1NWE03MFhnTDNOZW42cXdqOHkreGZ2NTNmUVpLd2VGek41eFc0Yy9DZ3d3ZTlmQXVpMWhJdUJsTW50SFpPS05pckF5aVErTkxiQmt3OGZFRTlJTTJRU25CdjE5SStvV1ZndVdRU3h6cm5YNkVWcnFvVjJJMTVrUzBBeGVTc3pqbyszMjZoUW0zaG9TUVJxUjZtQ2VMMkJWNXgwVlNqWVFvakRITm1nemNZbi9VeGovSDlTQk03ZmtNUTk1MVR1dzRhYWdlRU1wWThGVUhuUHkrWFpFQ1hiUlRVRnhoZXpFcUNpWkZmc0ZSblhkZzF4aGdjVDlCRi9CSkcyaHRSS2lEangzNzZFWDlNZDM2SG9SL05EcDVqSjFLOEFBY1FCbW9vWmhUZ1FBQUFBQVNVVk9SSzVDWUlJPSk7CiAgICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyOwogICAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsKICAgIGhlaWdodDogMTAwJTsKfQouYWRndWFyZC1wbGFjZWhvbGRlci1kb21haW4gewogICAgYmFja2dyb3VuZDogIzc3OGI3YzsKICAgIGNvbG9yOiAjZmZmZmZmOwogICAgbGVmdDogMDsKICAgIHRvcDogMDsKICAgIHBhZGRpbmc6IDJweCA0cHg7CiAgICBwb3NpdGlvbjogcmVsYXRpdmU7Cn0K",

"mobile-style.css": "Lm1haW4gewogICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNjY2M7CiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2NjYzsKICAgIG1hcmdpbjogMDsKICAgIGJveC1zaGFkb3c6IG5vbmU7CiAgICBoZWlnaHQ6IDEwMCU7Cn0KCiNhZGctcHJldmlldyB7CiAgICBkaXNwbGF5OiBibG9jazsKfQoKLmVsZW1lbnQtcnVsZS0tc2xpZGVyLCAuZm9vdCB7CiAgICBkaXNwbGF5OiBub25lOwp9CgouYWRnLXNsaWRlLWJ0bnMgewogICAgZGlzcGxheTogZmxleDsKfQoKLmVsZW1lbnQtcnVsZV9tb3JlIC5idG4gewogICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7CiAgICB3aGl0ZS1zcGFjZTogbm93cmFwOwogICAgb3ZlcmZsb3c6IGhpZGRlbjsKfQoKCi5hZGctc2xpZGUtYnRuc3sKICAgIGRpc3BsYXk6IGZsZXg7CiAgICBwYWRkaW5nLXJpZ2h0OiAyNXB4Owp9CgouaGVhZF9pbi0tc2xpZGVyIHsKICAgIGRpc3BsYXk6IC13ZWJraXQtYm94OwogICAgZGlzcGxheTogLW1zLWZsZXhib3g7CiAgICBkaXNwbGF5OiBmbGV4OwogICAgLXdlYmtpdC1ib3gtcGFjazoganVzdGlmeTsKICAgIC1tcy1mbGV4LXBhY2s6IGp1c3RpZnk7CiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47CiAgICBjdXJzb3I6IGRlZmF1bHQ7Cn0KCi5oZWFkX3RpdGxlLS1zbGlkZXIgewogICAgZGlzcGxheTogbm9uZTsKfQoKI2FkZy1hY2NlcHQgewogICAgcGFkZGluZzogMTBweCA2cHg7Cn0KCiNhZGctY2FuY2VsIHsKICAgIHdpZHRoOiAxMDZweDsKICAgIHBhZGRpbmc6IDEwcHggN3B4Owp9CgoKQG1lZGlhIChtaW4td2lkdGg6IDUwMHB4KSB7CiAgICAjYWRnLWNhbmNlbCB7CiAgICAgICAgd2lkdGg6IGF1dG87CiAgICB9Cn0KCi5oZWFkIHsKICAgIHBhZGRpbmc6IDEwcHg7CiAgICBkaXNwbGF5OiBmbGV4OwogICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwogICAgY3Vyc29yOiBkZWZhdWx0Owp9CgouaGVhZF90ZXh0IHsKICAgIGRpc3BsYXk6IG5vbmU7Cn0KCi5lbGVtZW50LXJ1bGVfbW9yZSB7CiAgICBkaXNwbGF5OiBmbGV4Owp9CgouY29udGVudCB7CiAgICBkaXNwbGF5OiBub25lOwp9Cg==",

"button.html": "PGRpdiBjbGFzcz0iYWRndWFyZC1hbGVydCBhZGd1YXJkLWFzc2lzdGFudC1idXR0b24tZml4ZWQiPgogIDxzcGFuIGNsYXNzPSJhZGd1YXJkLWEtbG9nbyI+CiAgICAgIDxzcGFuIGNsYXNzPSJhZGd1YXJkLWxvZ28iPjwvc3Bhbj4KICA8L3NwYW4+CjwvZGl2Pg==",

"style.css": "QGZvbnQtZmFjZXtmb250LWZhbWlseTonT3BlbiBTYW5zJztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBTC9FQUJNQUFBQUJmNWdBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFDL29BQUFBQndBQUFBY2MxVjdKRWRFUlVZQUFLL0FBQUFBSGdBQUFCNEFKd0hNUjFCUFV3QUFzQmdBQUErR0FBQWd2cnBzL3BSSFUxVkNBQUN2NEFBQUFEZ0FBQUJRa3p5Q1MwOVRMeklBQUFJa0FBQUFZQUFBQUdDZzA4U2JZMjFoY0FBQUJzZ0FBQUp1QUFBRDVoUTJIQWhqZG5RZ0FBQUxtQUFBQURZQUFBQTJFS0FLdm1ad1oyMEFBQWs0QUFBQnNRQUFBbVZUdEMrbloyRnpjQUFBcjdnQUFBQUlBQUFBQ0FBQUFCQm5iSGxtQUFBUFlBQUFsL2tBQVRjRUU0NGFiV2hsWVdRQUFBR29BQUFBTmdBQUFEWUhJVWRNYUdobFlRQUFBZUFBQUFBaEFBQUFKQkRoQ0pCb2JYUjRBQUFDaEFBQUJFSUFBQWNZTk1xMFNHeHZZMkVBQUF2UUFBQURqZ0FBQTQ3M3U2d2FiV0Y0Y0FBQUFnUUFBQUFnQUFBQUlBTG1BZDl1WVcxbEFBQ25YQUFBQXVrQUFBWXR6cENWS25CdmMzUUFBS3BJQUFBRmJ3QUFETFd0L1QwYWNISmxjQUFBQ3V3QUFBQ3NBQUFCQjg0cTBWaDNaV0ptQUFDL3ZBQUFBQVlBQUFBR0FGOVoxZ0FCQUFBQUFSbmJid0dhcWw4UFBQVUFId2dBQUFBQUFNazFNWXNBQUFBQTFmdXczdjlsL2c4SldBZjhBQUFBQ0FBQ0FBQUFBQUFBZU5wallHUmc0RkQ4dTQrQmdUUHhmK3IvVlp3UkRFQVJaTUI0REFDUHdRYUdBQUFBQUFFQUFBSEdBRzRBQ0FBQUFBQUFBZ0FCQUFJQUZnQUFBUUFCYlFBQUFBQUFBd1NrQVpBQUJRQUVCWm9GTXdBQUFSOEZtZ1V6QUFBRDBRQm1BZkVJQWdJTEJnWURCUVFDQWdUZ0FBTHZRQUFnV3dBQUFDZ0FBQUFBTVVGVFF3QkFBQTBsL0FabS9tWUFBQWdoQWtJZ0FBR2ZBQUFBQUFSSUJiWUFBQUFnQUFKNDJsVlZXMmhjVlJSZDk5NTl6cDM0S0pNTURqSEVnaGhEVWpRbVVDa1lBMUsxRm9KcCtxQ1VwQlJET2hRcWJTZStZQWEwUnNRUHNSU0prUDdZbUdJa2VnTlNhaHJ6VVdxOVdOcFNQNForYU1tSFN2SFIycUlGV3luR2ptdWZ1WGV3QTR0OXoyT2ZzL2ZhYTUveHIrSVo4QmY4QmZoQ05HRWlhTVc0Q2RBais3RGZqcUpnUHNOZWJ3SGpmajhHaVY1Wmo4MWNLM2kvb00vZmo0MStGaFArUmVRNE4wb2NKMGFJWVdJVk1VNk1KZU1Dc2N2dHo2SXZHYitzTnRpQ0Zuc0xyOHBsd0lTSTVXZVV6Q3p0SU9FaE5wOXd2SWpZN3lTYXFnV0pPYzk5b2E1ZFJHenZSa25tRW51ZWEydXhTL3JSU0w4djVEQVFQb1lXS1NNajJ3RFp3endPWUpveDUybDdaRFc2ZzNKMVdjcmU2N3h2V0U0aENvNmlTRnVVSVJUOWFiVEtVMmpublpGM0V4OTZONnNmU0pQN2pzSTFpSFJlUG5mN0kvVUpWdEgvR1BNOGdaVmNtd291QWJZQmVjbWlQYmdNUDVqbS9YK1N4M1hlRDdUck5IL2xudlpMUW5sWnlWZ2VzYTlnSkZqaVhuS3MzeHFmRjZPTmN3UEtVd3A3dW5wYitYSmMvUTkrWi9VcytUTEtTUXJsSTRWY1lMeWFid0k3aTJHWDk5Q2RZTDd6eERXWFl3cm1sVUp6Y3JIb09ZekRuYUV4cVA4S3RQcTJ1cXcxVXA3Q1RwVENEZGlyOVZHTzBub29KM1U3NlFsejNVbUxOQmR6RkkzU3dPOGJ6Sk8rVGdmTVRiVVFQczc2RnBJOUoybXY0QnVwb01YcFIrTTZ4VG5WRlAzTjgxaWg1OWtEalBrdHJOZTlici82dmNaelZFK0xOUjA1LzdtYUZsVkxlcWJ0WnN6VWtWbmd2cDJZeWZpSU04THZyV2kwaDduM1grSVNlak1QMC81QmJTa25IMUhqdTZtSlRlUjdIenFVRnpNUENVNWlyZnpPT1VWSTdFSFdIRXZHeW5IRjZjbHBNWmhDaC9KczNpTjMxSkVzY1cwQmsvWTNSUFlHSXNiU1lXNXhicEw3SzFoalgrTDNBTnJxZFl5UjAvdTVWbFRlRXgxZlV5M2JONUMxUHpvZDUxd2N2Ti9WbFBlSDMyUGNEckVubjZSK2YwVStmSkM1enZPK3A4bnJDN2dyWko3bU9zZUg2UHNQN2drUGtydjNlY2JiNkdOK3pmWlI3RGJmWWNyZVN3NDFweVcrTlZmcG05aUdFWlF5dlNqeWpwSzVIOFh3SytyMFdkb2oxQ1B2MVhvSForbTNTTjQzc1U1bFhLYzJLc1NGY0E0ZDRZc3ViK1ZkdWVwaS9qazV3YkgyWWg2eDR6eVBMdHBHeGhkcjM1SXpuL0dJMWw5cllKaVRQT0h5aitVaFo3c2tRTTVzUTFaTzgveHpUaitSM1ZETFBmTWNjenpPc2I0MWZ6TzJWUFA5eUdxZFZOUGE4M1g3TGQrZDFXaTNSMWpmZ3p4dkIyYVl6NlRxUjJhZGplVmRudmNtZXMwRDZFbXRhbHgxcWxwaExQcW1SYWJzM29tcytaampNeHlmWVV4WlYvOFoxVU1ZMUdKVTMzcFBKbGJmQ2UzeHREZjVyby9KVm95bU5yMHI1VVhlb1QzSFB0TCtvQ1pTNi9KbUxkT2ExbXRMM2F2MnRFOFMvZHhoMHhqVHVtaS9PTTJtOWFtUXAyNXF1d3pyM3NyYjdNZGxjcGhZLzFQQXF4SmJhb0IrSDZJZDQ1citEeVVJZnNKZytEVUd2WTFvZHREL3FRVTBLNEkyMml2VTQzMllVRjkvTzkvWDdSalFjMlVDZmRhd1o5cUIvd0Q5bmJ4V0FBQjQycjJUV1VoVlVSU0d2MzI5YVZtV2pRNlpIYTNNUnB0TEd5MmJaMjIyc3JLSjVqa3JzM2t1R3lnS1NoUEZDZE9Ic0xRY3VBMElZZFJERVpTQ25vcGVnbnBvZ09qS2FuTzhOR0RRV3h2V3Y5ZmFuSE8rYzliNkQrQkdmUVNndEtLcWRhV3MycTRjZWwvSEtCclJFeStTU0NPRFRITEpvNEJDaWluQndYMGVVc2xUbnZPQ2wxUlR5MnZlOHA2UGZPWXIzM0FpeWtQNXFTZ1ZvMkpWb3EzQzlzcFdiVDlxRjhQVGFHUDRHNEZHc0JGaWhCa1JScHh4SXlpNGkxTkVVNzB3TkMxZDAzSTBMZjhQV2dWUGVHYlJxcWl4YU8vNHdDZUw5bDNUN01wWFJhcG90VUFsdUdqWWp4c1kzb2F2RWVDaWhmK2l5UmQ1SS9mbG5qaWtYTXFrVklxa1VHNUtnZVRMRGNtVFhNbVNUTW1RZEVtVDY1SXFLWEpWcnNobHVTUVg1WUlrUzVMTWxVa1NKYUYxTlhXUDZ5cWRPYzVzTTl0TU42K2JxZVpWODRwNXpqeG14cHMrdGVsVmorbzcvTitXdTgzVG1pZ051QXFiSzdQOTR4bjFkN3BoMXg1d3g0UEdOTUdUcGpUVEUycE9DN3hwU1N0YTA0YTJ0TU1IWC96d3A3MTJUd2NDNmFpbkdFUXduZWhNRjBMb1NpamQ2RTRQN2FkZTlDYU1QdlNsSC8wWndFQUdNWmdoaEJQQlVJWXhuQkdNMU42TFpEUmppR0lzNHhqUEJDWXlpY2xNWVNyVG1NNE1aaEpORExPWXpSem1Nby81TENDV2hTeGlNWEVzWWFsKy8wMDZ0ckJONng3dFl0alBBUTVhWDNhWW94emhHTWV0NmdRbnRaN1NjWm96MWtreVp6bG5aZkVzMSswbzA5aysxckJLUFdRdEszVzErYmR1cmZoTEJ3ODFPRm5OZWxYT01qWlkxVFZTMUMxMVc5MVZKYXBJRlZ0bjU3WDNVUStVUTkzN09ZZzdxbFJ2RzltdWRRZGJ0ZTRrUWVzdWRyc3UyVXVpMWt5eVhYV1cvbmV0OVFQYnI5TzRBQUI0MmwxUnUwNWJRUkRkRFE4RGdjVFlJRG5hRkxPWmtNWjdvUVVKeE5XTlltUTdoZVVJYVRkeWtZdHhBUjlBZ1VRTjJxOFpvS0drU0pzR0lSZElmRUkrSVJJemE0aWlORHM3czNQT21UTkx5cEdxZCtscnoxUG5KSkRDM1FiTk52MU9TTFd6QVBlazYrdU5qTFNEQjFwc1p2VEtkZnYrQ3dhYjBaUTdhZ0RsUFc4cER4bE5PNEZhdEtmKzBmd0todnY4SC9NN0dMUTAwL1RVT2ducElRVG1tM0ZMZys4WnpickxEL3FDMWVGaU1EQ2ttS2JpTGorbVV2NjNOT2RxeTdDMWtkRzhnek1SK2NrMFFGTnJiUVNhL3RRaDFmTnhGRXVReTZheE5waVlzdjRrRThHRnlYUlZVN1hNK05yQlhiS3o2R0NES3MyQkI5akRWbmtNSGc0UEpoVFN0eVRLTEEwUjltS3J4QWdSa3h3S09lWGN5ZjZrUVBsSUVzYThTVW83NDRhMUJzYVIxOENnTmsrei96eWJUVzF2SGNMNFdSekJkNzhaU3pyNHlJYmFHQkZpTzJJcGdBbEVRa1pWK1lZYXo3MHNCdVJTKzg5QWxJRGw4WTkvblFpMDd0aEVQSmUxZFE0eFZnaDZmdHZjOHN1S3UxYTV6b3RDZDIrcWFxalNLYzM3WHM2K3h3T2VIZ3ZEUVdQQm04Lzcva3FCK2p3c3JqUm9EZ1JEZWpkNi82SzE2b2lydkJjK3NpZlR2N0ZhQUFBQWVOcEZ6cjhTd1VBUXgvRmJKNWUvNG1LaU5CT2p2RXJoRFNSTkZFYVZtK0V4YUdtVUZHcXZZR2FqTWw0dVZpeTYvZXg4aTk4RG1pUENTWlRvTGFzYTRHenJRcGxxak5xV21LN29PTmdSS3JPdUJNb3NSMm5tR0dYNVUwZ1FvbU5haDFsK2oyNk1nQkJlR0Q0aFdEQThnajlsdUFUdnlsQUVkOEp3Q0dySTZCS2NHYU5Ia09rSGdER3YwZTgxTVlTMHBwYkZqajU5NnZUbXg2UU45czAvR0ZDUWJMKzBtSm9YcWJOSTdBQUFCQ2NGaWdDVUFFa0FZZ0J5QUhZQWZRQ0dBSXdBamdDUUFOWUFwUUNZQUtFQXBRQ3ZBSUFBcVFDakFIa0FuUUNhQUVRRkVRQUFBQUFBTEFBc0FDd0FMQUI0QUs0Qm1BSVNBcklEUmdOa0E0NER0Z1BnQkNJRVNnUm9CSllFc0FVQUJTd0ZmZ1h5QmtZR3NBY2dCMFFIdkFnc0NHb0lxQWk4Q040SThnbGtDZ29LUWdxcUN2WUxPQXQwQzZvTUdBeFFERzRNbmd6U0RQZ05TZzJXRGVvT0xBNk9EdVFQVEE5OEQ3b1A1QkI0RUtvUTJCRUdFVFFSVGhHQ0VhQVJ1QkhpRWw0U3doTUlFM0FUMGhRbUZPSVZMaFZvRmJRVjlCWVFGb0FXekJjYUY0SVg2aGdtR0pBWTlCbEVHVzRhSmhwWUdwUWF3QnNlR3pvYm1od2dIQ0FjZmh6aUhVUWRoaDRnSGtRZVVoNytIeWdmWWgrSUg5Z2dKaUNhSU80aGRpSEdJaEFpWmlMYUl4SWpZaVBHSkRJa3VpVVFKV1lsMkNabUp2d25saWhRS1FBcGZDbjBLbVlxNUN1QUs3Z3NDQ3htTE5RdFZpMitMaTR1dGk4cUw0b3dQakNhTVBBeFZESG1NaUl5VERLb013UXplalFVTkk0MUNqVnNOYWcxNURZb05tdzJuamJvTnpJM2dqZjJPRnc0a0Rqc09WUTVjam5DT2ZJNmhqcmlPekE3Y2p2VVBFbzhoankrUFF3OWREMmFQZkkrTGo1eVB1QS9KaitnUDlKQVBrQ1FRTWhCSEVGR1FZaEIxRUlFUWtSQ3VFTHFReVpEYkVPa1EreEVPa1NNUk5CRk1FV21SZnhHZUViNlIyQkhoa2ZjU0Q1SWVFamVTUjVKbEVuR1NmcEtQRXAwU3NKSzdFdFVTNXBMeWt3R1RIaE1xa3prVFNwTllrMnNUZnBPVEU2T1R1cFBWaytxVUNKUXZsRTZVVzVSeWxJMFVtNVN2bE1LVTJaVHdsUXFWR3hVeUZVOFZYcFdDbFplVnJ4WElGZWFXQkpZV2xpZVdRSlpZbG9DV21KYklGdWdYR3BkS2wyQVhlWmVSbDZpWHZwZk5sKytZQzVndG1FNFliSmlMR05ZWkg1bE5tV3NaZ1JtWG1hVVpzcG0vbWN5WjJSb3VHbFlhZDVxWG1yQWF4NXJmbXYrYkN4c1dteWViT0p0U0cyMGJnNXVhRzhDYjVSdjNIQWtjR3B3c25FR2NXQnhvSEhlY2lSeWNIS3ljdlJ6WUhQS2RIQjFDbldPZGdaMlBuWjZkcWgyM0hjc2QzNTN3SGdDZUZKNG9IanNlVHg1bkhuOGVrQjZoSHNRZTVSOE5uektmT2g5YUgzaWZreCtzbjhzZjNCL3hJQVdnRjZBcG9EMGdVU0JvSUhzZ2dxQ2VJTWlnNWFFVUlTa2hWU0Z4b1pZaHJ5SEhvZThpRmFJMW9sUWlmeUtwb3IraTFLTHBJdndqR3lNNUkxc2plNk9UbzZxajBxUDVKQ0FrUjZSYUpHdWtpU1NtSk1LazNxVDlKUndsSjZVMEpWWWxlQ1dWcGJLbHlDWGRwZThtQUtZQXBnQ21BS1lBcGdDbUFLWUFwZ0NtQUtZQXBnQ21CQ1lIcGdzbUVTWVhKaUVtS3lZMUprWW1WNlpvcG5RbWl5YUxKcFNtbmlhZUpyNm0yS2JnZ0FBZU5ya3ZRbGdGRlhXTmx5M3F2ZTFxdGZzVzJjQkFnbDBrNFNJTEFvaWJzZ2lvdUtHaUxneXdaMVZFUkVFUkVBUVhCQWpCRlJFcWpvdEltNElLbTZNaW9xb3VJeDdkQmkzbVZFZ2ZmblB1YmVxdXhNUzlKMzV2L2VkNy8yY0NlbDBvT3VlYzg4OTV6blBQZmRjUVJRR0M0SjRzWG0wSUFsV29Vb2pRdld4Y2FzcGUzOVVzNWozSFJ1WFJIZ3BhQksrYmNhMzQxWkxUdXV4Y1lMdng1UmlwYXhZS1I0c0Z0RlNzcEplYWg1OWNNTmcweTRCUGxLNDYvQ1haSVo1dnVBUVBNSkZRdHdwQ3BXcXJUb2h1Z1haVkVsVWI3VXE3RW1ZZllMUFZLbC9hM2FiQlZ0bHd1TVYvS1pLMVZPZGNMTlh6WDZQMDFPWmNQbUVycVpLVFNhVm10dWorRFNiV0Y4dmFFNVI4YW51K3A2OTZuckhvcUZnd0JJcEtmZkhwTWhkMS9YcDE3OHVkcnp2MWVnbEUyOGRQTEQvQ2YzTWx4MUt3cmhtU2ZQRisyQmNLTzlBSVM3Z3VFeXhoT1FXYlBCVVM1VEFLRlZwVDBMa3d4Qmx6VW9xRXhiMmsyYUhwMXZoa1JveHdkTjc5c0pIRWZpYWxTaS9oUFJQVkV3d3o2ZndpVlFRbUE1NkNZTHBMWGhXcmxCSXpoUGlPWUpRR1ErR3NtT3hXTndLejQzYm5DNTRuUkJJanRWZDJTd3FlZm1sNFpnbTJGcWFBK0dzM05Kd05HRTJzVjlKY2tFaC9zb012N0xZSFc3NEZWR0xxdFdjUFlsc3IxQUk0OHptNDdSNWhlNm15cmpWNXFoc0htZzEyVUhuc2hhQ1h3VDVMNEloL0VYUUQ3OEl5cG9UZnVGaS8xNHJKcFZxYmM3Vy90dC91VVlJVmpxMjl0LzN5Ni80UXMyUm04VWNxeC9Hd1A2MDRKL3d0R1o3dGcxZWhPUm1SOGpweDA5cmRnZGQ4QmRrOXFmQy9nemduL2gzd3V6dndML0tZdjhLUGpQWCtKdzg0M1B5OGU4MEZ4aC9zeERmbHdiS29vUUN5d3BxSkMrL29MQ3EzWC9xd0J5Y2lKcGlmekY4eFNUMkZTeG1YeEUvZnRYQnIzcVI4UEgwRjFJeWZPNXcwbVhFTFNPSVFMOGRTSHgwejRnNUkraUhwOTg2YkJVcEgwZy9KSTB6eU1uVHlIcDZObjVObzV0bjBBdElJMzdCK3ppbmtuRFQ0VHVrL2VZdmhDS2hRdWdoWEN5b0JkVnFia3d6MlZ2VUx0RjRnUW4xVzVCdkJ4T3ZxbFp0ZTdSaVQ0dGFMR3Y1cERKdWNwWkdvOUZFSHRONDNPM3ZBaitwZWJMV0Rhd3F5OU9pVmVQM2JtQmRpb3kyYlNvQTJ4YlF0bXNLU0V5cElqVzlhK3RxWXNGUTJGcGVvUlNJWU8zV1lLUUdERDRRQ2lzZVFtcHJlcGRYM0RSaTk1a3ZQL2ppUXpQajYyS0xsNjljTWZSbGJlYVZiMXgzMWhVWGppZkg3VDV6ZXRPSzBoNWt3NEIxdDk2MHhxYytiaDUwVTcyVGp1MTE3ZzJqYjMwczlKZTlKZExVazg2cElEZkk1N1NxQmN1SG5Ga0pNcHVGQ1lmM202bDV0ZUFVZ2tLMlVBWjJ2VTZJaDlDYUkvQ0gxdFhTRWcralBVdndoK2EzdENUczNvamtodVZpYlVua1Y3T1grZFlXb2tiWm9uY3hVMVJkc3Fid2xZVS9XV1F0QjM0cTV6K1Z5MXAzK0ttSS9hVEZRQytLUy9FMTI2VlFkbW00WHV0ZURqK0U4eU5aOElPZzJidkNUemxGNWQzeFYvNTgrTUhpVWdUNEFjeWlkMjNLTGRRRlFyR29Ja2RLTEg0U3M1UDJ2MEhsd2U4bUxGNTB4NHBsaStmZGZkdlE0YXRYRHg5NmcrUmYxUG8zOHRxU1JiZmZ0L3pPK2N2bkRCMDVZdGl3RVNPSFNsL3MrK3liOXo3Ky9KdTlUVTNrWkRKMHphRWJ6Zk1QWGs4MjdQdjB5L2YzZmY3MTNuVnJIM3A0M1lNUG9zMU1BdjJ0TXo4b0ZBcGRoUnJoSmlHZWpickxSOTFGWEMxeEI2b3RaZ2NGMWFLQ3RDSlBTN08xQ0h5aDFrMXVVWXRrclNjNlBYanBsclVBdkF5Q3JkVEI5NTVnSzA4NHBQeEl1UXpTcW01RkxhdFhBNzY0RXM2cHI2OVhnNHFhRGVxSlJSVGZac0hxRHVlVTl6Q1VVbGNsMWhnS3NKTCtwQzRtV2tta3drTU1iZFFSajRobTFaOXd0VXk2YmRQSVl5UFBQL0pBNHRhVlpFSHRjYUUxeDg4aEpaODBYL1BYcFc5OXZXN0ZqTy91cFdkZGVYYmx6Qk5HejdqbzRsRmpyaUFOTTdlUFAvZUNpWFZMMWp5MCtOSk5ZK21jWXgrNmtINi9tSDY5Y2VMWnU3WmVQZWR1Y3QveFo0NFhueDAwNWN5VHBvMDQrWUx6QllHZ2J5WTF6RGVYY00rc3UyV2ltako4c21ZbWxicnZSYitMTGhmKzdYRDZzcWpBdjNVTFdRSXpSQUloQkxWcEJXMTUrYitRZlhVeEM2d2JYemhTTGc2L2U5R3FoWGNzbm52Zm5jdkZJa0xJdGtlZXBnUDN0OURCVHphUkxialdpZENYdmt4YWpjOFVqTTkwN3RGTTZjK01oWHpCZ0dpTjFQcHFlb3Q5VjkyNS9PNUY5ODFkZklkNS9xTjB3T0hEZE9pYXplVFpsdjFrRzM3ZUtQRks2UWZ6VnhBUnZZSXFWV01VeElDR0gxTm5sbUpTV2Rqc3R6cEpoWDlVUHBuVzdabXU1SlpzdXVpbjlSdnUyL0M5cVZpN2t0eEVaMTJwRmRBWHg1SUxhT05ZY2l4KzVnUmhuOGx1ZWdEVzVtaEJGYXBWYTB3ajRJdk0wYmhBMEJjSkRudGxuQWo0a2tqb2xselZxbU9QS2taaGtiSzFab3JHN1E3OHRkMEtmOU5oeDVjT3dRNFd4MGRXVTZ4QW9BOFdLeEZsQWxsMEcxbE1HMjRUcDl4R1Z0Tnh0OUh4WkJXTW9kOWhnVndrZkNQWXdEZkFHSERXN0RocmRwdzF6ZXhyMFJ4Z3JtWUovSm1OaGMxYW1JaXdSYlQyeXhuZzFqelpGL1ErTEV3Z1hjOE9qYU4wRW56ZUNQSzZXQ1dleit3QVBrOGpVZ3Qrb1Jsb0F2Z0Z5WWVmYjloQlRYRndCUG1Zdkg3WFhhZ1BoanVFNzBFZlZRSU1BTWNDZ0VQL3hxUUhGMlRodUlOLzB3V3R5L0FJZHgxYjEyZkF3THJvY1JPUEd6VG91QUdEKzNGNzhFTlFmNG5aWndqc0FkY3dZVVlCdytKamlaRVk4WXRLWS9JSDlBVU1BNHcvdk4va2hyWHZGTUtBdGVKMlhQUmVSd3YzbFVFSENKWEZ6TlFGY1FKY29nOFVaUUhyeW9idlB2QjVtbDNDV0JEMHdrdUxVRi9QckRnVzlTbXlHQ2tSTTErUC8rYXYzL3o0N1E5Zi9yQm15ZXFIRmk5K2FQVVNjU2U1aGx4QzU5TlZkREc5RzE1UHBLL1RyMGdCaWNMLzh1ZzNUS2JOTU1qTkRLZFZDSEZUV2labnRXcmFvMGx5aSthQ29VZ21CRDFXRG5vZ0dFV1UzblVlWXQxTWJwejNnQzBRMjJXNmxKUWN2Rjc2WldaRG9NYzY5cm5qQVB1WUlXWmtDOE80cnJTdzFCTDNvdFIybERxbldyWHMwWHllbHJqUGdpYm55d2Jycy9qd3BRV3RMeGNVcW9VRk1CbFNyOW9WOE9sdUgzTmZzUnJTWCtSZXlWckJwd3ljVjdBNE9JNWN0K0dxMnZsVHozcGczSmt2ZnZQS0Z5dmVvcStKSHl3Z04yeThhK0h3cStjY2M5cWtOYnMyenFVSFhxTnYyWmF6TVk0OXZGODZCR09zRUJxRWVCbU9FY0o0UEF2SHFEaGFFZzU3V1JhRUxnY090d3NiYmdsTVVvbXM1aGJ0VVRRUHZQWlVhN2tnZ1NjWGgrMnh3N0M3NHJCTlpTeHl3N0ExVWdLZTJPSFRDZ3JodTZMRUE4SGMrbm9qcGhjcGNuR2tKaFY3ckJYOWllNlRnd1VrR0RBVmw1U1BQZmZ0ODBnRHZYemhvblhiNzV4Nlh0UGxJOFo4T2ZQTnIxWXUzTENXZmtPVERjL1UzOU9qSnlraTRvSzdicGw0UTJ6d1ZTZWMvbHpUM0kzNXR1Q21PMTcvc0lUajBHNHdGMFBOUzJHT2ZjS0YzQWJqSXJwWHdXa1gzWWgvTlVGcVllRFhYNjNhOTZpdXFHYnp0cWhTTkc1ai9zQm1nY214TTFCcHg4bkJLR1N6ZzVBeVluQjlra1JGOWFKOTFvQjl4SUlSc0JGSURuclhSU3pXYm1Mamh0Mjc3MHYrS01vT1cxVlhNdVFPNmZuV0lVdnBWakprS2RtNzRQSHo5UFUxQytZakNiYVlJMHpuTVZJendVcHg0M3pJVWt2Q2I4OTJ3M3o0TVZMbWdxZmJvNFZncGVSeDVEcmc1WVAzTThEcXJ2S29ybTFtK0JjSFBLcXlUZEJjU2xVVmFYWUJodFR4SXRGQ1ZqQm5qNWVockd4anJ1TEVHVXJQRFV5S1hGeGlyZkFqa0FRek04RjhSRXBtRFg3dG9rZWZvOHZPdlc5VWpiZzkrVXBwdzZUUENLSGYvdlBIK3ZzcW80MzNrQzU1dGVLS1pmVE0wQ2N2N0R1SXVwOE02OThMTmhZU1NvWExoSGdBcGNxMTYrdmZCaS9NK01JQzV1WXBEaUJTOHRoQXZETG1FOEpnWXM2b0dwYTFBb1JBc0JiTDRYdEJHQ0NPVGZJRU1PZ3JDaVJxS0VkeExyd3J1QlFuai9HeVVCd05COEdxUkNtVzhtdENYWUJMaHVibUlaUEpDV1RBVlFOT3Z2RExuMXl1Szc1NWZ0L1B1L2JSWk5Pd084Zk9YN2xvNFZsTHhvam5rNGZJYXYrQ2JQb0ZmV3Y5Tnk5L25DUW5KeTdlT09IeHRYYzBEcDNKNTJ3czJKWVQ1c3lDTWR0cytBKzBKNkphcXpVYnJnZUNGaUxWYzE5TkltU3NwQ2FmYVJaUE5mMXoyYXlEdjVyK2lSZ0pNS2JKenZSVUFwNzdRbDFUT2FBZ0czNWVkNXowYXE0VlFFSm1YSUVSZUJGbTBCcDFvM2JGOTV5Z0pJUkxYUUgxUEdFVEF6bEZIZ1lTdStmQXo0TFpxUlNWNnlDb2pBRnFmYjNoY21zREJRRUxaZUlmaUU2M1hmZmw4OXUvdUdYUnhpWC9mUCtMdjY5K2FPbVN4aFhQTHI2bDZ1cDdGMXl6Y05yVTI4bmx2OHc3ZGROVjkyNTVZdlZsajUwNDZva2J0TjB2TjE5N3k5d2J6bDk2UXYrN3hSdk92bm5nTWJlZGZkRzExL0UxT1JIa1JmOFlocGg1cVI0WFBJWmRSTUFjZ3JsMk5JY2dta001RXp3TGhNeVN0VUl3ZUNYS2NFMEZaZ3lnWE0zcEF2ZFNxRFRiUFZLUXlSdUVIRmwxMVdzUk5BdXI0Rk4wcVNGZUFHQUJ5NjZvQVVsOS9rZ2E4NkdzVmZDVFplS3ZyeTMrNE5yazlJYmpUeHZmOGplSHMxYjkwek1mcjE2NDZLemxvMCsvODl3Rks2UVhQaVprT2YzeWhkWnQvZ1U1cEpoMEhUNzY4OWNYTkE2ZFB2aVNqZU9iaFhUK2J6cWU1UXgxR1pFWVBFekNvd2ZqRUlvRnprWVB4S3Bzdk5MQ1I0UmtCUkw4ZHNINW1oc3lRN1Qwd096WkxGS0xESTlNZ1dmYndOL1ZDcXBjblhEcVQyVHVMZUhtZklQa3RnUEdSbmdTME9FSlpPU1FlcldCS0ZMcXVTbXdVb0VQN3RNM0E3T1luc2RuRCtaNDdIdkFZd2xZRHdKNHdxQ2RCQ2RJYTVNTzhaL2lyUmVRdDVmUWxYVDdVaHpqTlNRaEhaUmVZanhFRGtjNUFOc1FTYUNsMjZxUmE5RFJEWUd2YTZTNXJWT2t1U1J4NjYxazRadzVmTzFsUEt1dXhrN2djUlBFWDVOMmFlMzNTOG14NVBJbHRQb0NOaGM1aDcrVWlzRFdjb1Z5WWJMQVhMK1c1V3BSUzZzVEJicGlLcXBWeng1a1hDQTFiZlo1OGp5VmlXSStLWkIwQkZFOTNoYXRpMDYreExNS1NqSERLRlkwMFllWmhpL3U4TnRSY1ZvV0pLMXhzeHVESEFZRVRGLzlmQklCTG5oSVBvbGdGbXNzSzZzL1RkdmtiTm01ZFZmNVNkUEdEWnd4NUlKYlQ3anBodE9XWEhEM3RYMzZENmlMSG0vdVArN0pkU2RlY2VFVm8vNTBibEh2cTVlTy9OUGswOGRmV1ZwOWFBUG5ka0RHNnc2ZmFyblZQQS95cXdIQ1BFR05WV3RWdGhhY2IxZE02Mk9GTkNxcTlxdldzdUZWUmJWbXdrVTFrRUhCU282Q0t4bE5vdFZDMUt1VnRRaW5VcEFZT1E3ZWpkUXF2b0YybDhtZlhWSFZNOWFYTGJDcUdDeXdYdldxWDFGNzFtdjkra0NTWlJQa2tEZFNpVzQ1VzFIeitIb3JoZERoUStsQnhBcSsycmpiQ1V2QkFQTTFZbW1reENRRzBXUFhCUzJSSW9IQSsvNDYxTTkxYjVHYmYzdWJuS0NOdm0vQ3FHdWMxb29sNDVlcy9XcnI4ZXNIWmMwNmE5S2Q5TmZIOXRKdGo1QjZVdmJHUjF2MzB3ZnBOTEgwdVZkODdoTkd6YnhUN05aSzV1L2RSSjk5Wi81WE15ZWNQdnFDblJ0ZS9qVXJTUHVFSG50cnZVcXNkemJUNWcvcFhycDkxS3dSWkRhNTdwK2tPaG5ZeE93Ri9qTzFtQmVEWlhxRTdoeTlxVktNT2ZhRXhTWVFjRXNXOU85NitxSVJHM00yUFh2MUF2d2JrWW9sZjdGVVhtR3hpcjNtaTFVYjFPVE94MXZJYTJ1TFNrSmR6SXNQTnBBZHRKODRobXdaTmZYOFAzRk9aUWM4NzE2SUlSN3doa1hDUkIwdklrcG1zYVRJMlpMSUNyUEhaaUVXSzJiZTBBdkJNU3VxZW1YTkQxUGs5TFdvZVJnQWNEbVh3QnQ1aUpqdE5yVEpNTHhVbmZWcWxnSUJGK3l5eUtlYUVVZ3F4VVVjYkprVWlPMWx4VHd3RnRmd0Y1VmtCMWxDY2xydnVJME1vb2Uvb1p0Smx3MlBhNXZwMThTNzZaNUhuLzdaUFArUnpUUFhaam5xNkpmUHYzZkhuRHR1bmI1dzBpMDNYSTdyY2dyNDlrZFpMQnVreHpFdndDdXZyQ280UWgray9DYUdnMUdIWVk3K1lkUlpxRXE3QXV0SHNMcHcvWmdVMVpJeW9yQVZERUpRWkNHbVc4bVV0YVQyN1UvWEQybHMvSTcrVE13L0xYOXUyVjY2azI0UWQzNUVUbTRldWVoVStpcjlpWDVIMzZwWlhFZW1zM2tGUFp1clFjODJRUkg2NkZxMk8zVXRLMDRZalkrTnhnNnF0Y3VZRnpGMStuRmdDc0k5UTIwNGp1S0tHUDhlMlVHYXljbmtUM1EydmZmTFYwa0Y2UUpQM1E4WkVGMUN0OUJHdXZCT1VrTHlTSkRrb0c1Z0ROS0hNQWFuY0tJeEFra2ZnUWt3bnBtYmx4bFY0MG9OQm5OVWxzTGFuZlpLeUYxNXNxb25ianc3NVY4N3BIQnlrWGhxTWlGZWJaNi9sTll0VGY3ekx1NHJqZWZhR2V1YndpbjRUSnVaUGRPR3ozUjA4RXhJbS9VSE90czlNUFU0ZUZqeXdGM0poL2l6WVA3TlFlWnZiOVJ4ckRkanpoUCtRTFlKY1N3K0w4K1lmcDBQUTBnYlZ4aExxL2poaWZrNjl4VTMyYlBSSmtLS1pyV2dVWHNSdDRicXRZQWY3TndGbVNFZ1dOVUtSdU5yWnpSOGtxSjFDaGkyQXY0SExDZE9UdnZMNXk4TzNLYlJKUDJZWkJINXJqdm9Edkw1NUpaNzZIUDBIdkdsajhscDZobExSdEEzNk4vb1grajdKZVNKdTVMRFNrdkpUVnlQcHQvWS9BM1FQWU9WZXdiVkhFdElEcVpKS1QxN1R0Q2tHRldkTWlKQjBDbURMY2E4NFFZQzVwS2d5Q2J4KzZhbVpOQThQOWtramoxNHZYaGZja0pxM3NpbExPY3VicGR6NDhkTDhHbjRaVTU5NG80bVBmVVd5T0VKZEFFNWovRTNQWVM0QmNmb3JOWkVISnluV2pYdjBXdzZqYU9KVHJhTm9GcDR4TEl5RUFnZmhvR3A0cjRUVHI3dzRxYXRtOGIyZnROLzdTVDQ5RnVmZWkzSEdKdHBCOU5GejNhNk1NWGFLb0NKekhDd0p0bnI2L2xRa1lhTUVDc0tQM3RIOG1YeDlPM0pROHRBQThlSnp5ZFh0bjRpcXJjbTMyMWp1MmJERzZPR2RUMVlERDNFSldhdGtobXN4cHBXY0JBK0hkYkNJZWZ5bEQ0dEErR3ovTUxaK21kWjNiSFVEQkkxd0Q3UEQzSFF6K2FNVFJnQ0FEOE8zZ3Z3U0xVcHphTFpqYmhhdFhMb3lVV0xTMDV2dlM0Y0JBTE9Fa1JBeEVnb3FPejRqYnhnSXkvOTJ1UzIwZHhiYVlIVkRZT2FaRnA2OEhwcDZhb3RoN0pOTGN2LzNEbzFOVVp6bUkxeHBLNVh0ejVDWjBjamRIdVBIS0VtZXVDN0c5UnRNb2FuU2Q3VTRNb3JJQXJqRE91RDJ5cVpiYUxGY3Q4enJRZHNYaGpZQlRtTHB2VjMyS1NxZzllYjFyMjlxZlZENWo5eFhTOXR6K1c0REM1SFNuTTV2alNYNDh2Z2NuRHFkUzVIc05UcmFScGZuMFZDSnBjemhaeEpqaUZSTW9ZK1RIZWhVOS8waisvKyt1TVAzLy8xSCtLcjVCd3lnMDZuRytoamRDcTVpWXlsbjlFOXBDdWc4QUp3dkhzTVAyOGF3bnlkVHpnKzA5djVJSkxhK0JxMVlTVDFwN3lkSTRvZTN3TWpOWEU4TEdnK0J5d0trKzd4SVVJV1I3TDE1QkZEWTRQb3B4L1NIOVl2Mjdkank0NHQ0T3pIdi85dGNyZjQ5S0w3NzVqUGRFVWZaN3J5Z2hjY0pjVGRxQ3Uvb2F2c3RPdVRRVmN5QjErb0svUjNJUmx5RnNucHRxT0Z3WkowZ05MOGJoaU1IWUZWTzlVaGNVMnNuYWp2bzFmSWlCL285eldkcWZBSHVuSWdmWkFjSjNha1NLN0hSMEdQTHNoaHh1cVdhT09XcUFWZExaaFZvQ3FkcU1wUWlzVnpSdzFmanNFenJEdHd6V0VGZ3pRcklJU2d1ZEhmV0JsRm4wWWlzaGtrS2M3VThSeGlQa0MvSUxOMjBFZm8zczhmWDlPMFpZOTUvaXV2MEsvSEoyZUx3NUp4OGFNRkN4Yk80R3NHOGtucEM0ZzVwWmc3czIwWkUyaGJ3YUdHSk00b2VQWm8yVEErdmxXSXV3eU1UckJDSUhuQzVGSkNCUkhVZDVHaStRT01HSWx3WWlTa05CTlBvSWlSRFQ3Vm44R1BRTFpZb1NmUkRKMVlnb0VDRW1iTVZhUms0cGcvVDJoYTEzZkJIUzgvK3V0cjcyb3hkZDB0eTJwbnpmbjBZZnBUUzJ2VjZyTEtHUTBubjM5NmJNajJWV3UzRDF0OGNzUEY4RlAxOE0xTG4zNmJ5Nk9BN3V0QjkxYmhHUERkbWJ5Q0t2Rk5Xc3NlelF4dXo4em9RN09FOUtFNVJSK21zeWNrcmhWVEY5cC9yZW0zcFVzUDJVeS9zYzlQQUVZRERBZlBxUlBpWHRTWHhjVjlxdXFJR1VBSTNLb3F5V3piRjJhV0FVMDdzdGhlbGlKaWdFaEZDclRHUk5QMlo1dTNOOUdQRGd1SEJmb04rVTFhMmpvKy90enp6ZEo5clZmOFFyOG5ZUzRiNHVzSEdPY0tNYzJCc3JGdGFHc01hVmZrV3dWTk1CWWZlS3RRdUxZT2dmVW1NcVJQY2FRUEdheFJzc1k4di9XSzFjdFgzUzh0eG1oSElJY1VyQUg0ekd5d1dvWTVWQ1hHUGpaT2JKNVlMTVlZVnhDSndIb2pmS1Y3d1R4ek9YdjJ3dUVmeXhoN0pzaHE5allQL0ExVjNMWjErOXY3Ni9GZHM2cFVlZFRBTnMzdVBXQldiZkNMTmZ0M3d5K2Nha0J1OWdVVWYyV3pILytNdzU5Rjg0dm1SeXlRSk5hcnZub2hJZHA5L2dEYnFDVlBpa2daWnVzL0dsU2NoK2cwb3BDTktNY1paQkhFSC9PajFINHVQSHlMRURBMkM2ejFuRTJmVllWeVluUVRjVllWK1dPZmJxSnoxdERQZzFFU3FxTGZQUVJhV2JabHVmYW9kSDdydlhjL2UvdkwwdVVRWHpZUDJPYS9lV1hyY0taN0craitHaGF6eTlNcldqU2luNnVhUjJvUjQ0WEp3ZUtGbmZEL1IrekVSdDZuSjIwbUY1THhLaDFLUG55YTNrS25pMStKVGNrM3hWN0pjY21nMkpCY3JNL3YyUXhuQXk2d3B1WlhpckV0RWVzZXh2RGpsb2pGQ3NLTEtEeC9nZE1OenlKZ3NnbHlJNW5hVE12WEF5RG9LNzdVZW4veVE3RUE5N25nc3d1WWI2OHk0cmVrWTB1SkExaUdValVyWjJVQjRDb2NFY1pxU0RHU0NjWEI0ZUtQeVFycG9hUlhzc3d5WGJkczFxR0ZPalpvcEMrTDU3STFCMnVDdzJON0MxSVRPaWVCK2JMVkp6aXdMaUtLaTgvNFNZb2FDMDZIeG8za2Fmb3R5YUl2VzE2OC9lQ3cyK0d6UStCUWR4cDdKNUtoazR5OUU1emswQU9pdnpHRjM0UmU5R1d5bjQwSE1Ec1hFY1pqcmRZRWZUeldQZkJvNUl3Y2ZBdVp3SG9sNEJsa1kyQldnMGNKRnpQOFc5eUxaTVBDZklZTzFzengydzhjeTUvVFV3eVpKUE55d1FMZVFJZFZPblhKZGp0dzVudVNwZ3ZKbisraUsrZ3pZa2k2cVhXVytFNnlCMkxNVnZwbmFlYmhZU0JYR1BmMHNIb0R2eklFczRKS1ROSXRyVFBqTnd1RXpEQWx4SVBtbjJIK3VnandGQ3lJY1NNQkE0a0gyWk1RZlVJM0U4OHpOTkhLWnJCbkwxSVRBNzhhakZUQnYzNnA4RS9kTGgrdzBmeEpZSkFheTRwdVpmRWU5ekhBV2NEYUx4VnVGZUkrMUc0WVRTUGYzaEozRTdRUmUwdENMQWtqZlM1YVV2eHlEcWdyUjlhS0NKdEJXY1pJblBEeGdoSmZOWXNPT2JnUTdBN01tcFc0MVIzR0hNVG5Vd05nc3lYNW1Lb0cvUEFXSzRyQjhPekdhSTNCdWF5T01Uekdsb1lTcWNoZ0dtdjdJUmMwVnBTZXVQTDZPUTlIVDMvNi9PZTIzRmhrSGY3QTlROGtIcm44Z3JzZmE5ejJLQ2tueDNzdHg4KzRjZVMweWw2UGJFMTJXM0h4a0RYTHhwemJ0UHhDcS9VeXpqRnVBQjgreXZ3VjRNUkM0V0lkNTNqWVZoUFN4b1FyQUF5QzFjcUF2QUVac1hqQ3p5VU1zSklEQk9oWS9jSVNLUWdtQ2txWW8wQnVnRUV3UDZ6NEVoYUkxbWErOTRTZTNvcUVPa2NhNVJVUnF6K2plbUJEbzgzVzhQSHViNzk3YStKang3aEtxcFkzTFZ1NmRHWFRFdk5YZE9uMGNhc2htVHBFRDlKUFRoMSt1eGo4eXdzZnZQYldHOCtpL1RYQS9EV1krc0xLNkdmd0JiaERpQUk0bkdtT3dLTnpCTjRBS0J2OHEwT0pnOS9BOFVwNjBvZnNRQ2hzcllJc2o0VW1aQXBLeEFaQzlwOTJUL2RvemN4ZTlKa0g3cCt6NFBLSHZrbUtidUlra2VMdzdhRThPdjdGM2ZXTDZrZ2U2aFRHWWdxRFRuMmcwOHVFdUF0MUt1T1FRblo5U0toVGUwcW5mZy9ENFlCeFZXc1U2WGZJOWZTaUl2U21xTmxzMEd5eldmS3dLZ1VYa2hxZzJCQW9WckNZUFc1OXZ3TFFXemhXVFJDU1YwUncxSDdkVXBoaUc3NTlhKysxTHF2VU9EdGthL2prN1cvVzNiMjRhZm1LcGp0V2lBcUJvUERBYWFjUTlXRHVuUStSZkdKKzQ2M0VLeVdmdjdDUDJ3anE5aGZRclI4aTVDVkNYRUZSbklaMnMyQlpCR3dLOHV3QmZWZEpZR21oR29oaTVWUlFSNlY1V0hWaFl4a08wN2RGMGR6TVBwd0tUSVVIRXc1TUh3TzhYb2REMFh4U2pEQ3BMb2gyTC9pTHVSeko5MTVwU1ViTWlUVWJIaDY5OHNxLzBoOGZGYnZQbTNuelN0RkpDS21tQi9aZTh2VDJvWXRMaTBnaHVlcWVoOVp6LzRRVDg2djVSeUVnakJQaWZtYmxPSHJGQnM0NXFpcmc5MHd0Y1JGam1VUDMxY0ZxMVkrYi9Kb1B5MGFpY1orZjdiSEtBSkw4YkkvVmp5QXBoTmJrOExCdGVZU21WclpGVTFjakYrdUFEbVJnK0Nudk9UTG1qS3U3blhmODJMT0lsLzdVS0QxNjBqRjl5YnlTV1FWVGJqdGhSdXVaMHFPTXh5dW5FWk1DdXU0RzhlTTQ0UVhRTmc1emdCa3NKQnIzc3RmV0ZyVUxwMlpyd0RoYzRIK3F0Yjdva1k2dlZsMTd0RDV5UzNObEg1Y05nSjZYUlo1SytOWkhWZ3VRT0xQQWEwdTFWc0RlMHZyQm5JVGhyL2NLOTRPL1hnWTU0Q0I0cDA4bDIycFNDeEJvcS8xOFR5bzUzcEl1VlgwSG9PMzFVcGpqcXFrQ24xWW1NQUliLzI2T1Q3TVV3RTk5RmMyZUI5OEgrRFJYR0VOL0dDdGxXTm1WQVhPTGc4WldVUVdnM1ZCZmd1dzE3dE9tTm80cVNZbUZtVzVOYjFCZytmVEpYZnNNT0g3a3BidTNqUnBFR2w3S3JkeXp0YnJieEtGam50bjRGUDJLL3ZqVzUvY3RuZnY2aml2dWVtSFMxREV6Si8vMWg4blRFdVB1eVBhZjF2dVlNVjFMMWx6MitIT0JTOElsa3dhdjJtcXJIZFc5NjlMNTJsUDNMUjV6OXBSTHp4eDBtVlRhY1BWWFAwd0YrOWdBbUNBQ2F6WWtuSjdPbCsyb2I1L3UvN2dIQ1RIL3A0WTQvSFBMeko5b0lZRXhlNm9ITk13U1ZCLzZmTE9sUHUzd0RDZXVNQ01PS3VEbklGNDE3TmpSZVAzTWgrOEY3MVkzc3ZiVXM3ZSttanhaVkcrNStjazNHVzhoQ3F2QWVNZWE0NEMxdkVLOTdrc3dISUg3MENRM1RMcXNid0N4UmVhRjhlQjN6Snk4QmxNaXRDM2lRc3k5cXJaclJaOCtGVjFyUFkzbUUrdDY5NjZycmFrNStJT3A0dEFIOE16RHkyaUVQZE1sWkFrblFPWkErS29RUVJHaGFrM0dwMllqK1FPclFyUEJFLzN3UkF3RE5qTThVUTZoL0tLRDBka0dHeVFaR0I5M3pUTHJ4cTRjZE55cEp6YlNUODQ5aHRpTk1kSG4vQ1BQTU8wNVZFdGZ6cks2OU5FSmZJNmtKTXlSalBrTW15TVhueU0yUHdyUGhkbjhNTjVBTnVaQTBPenNwU2RqT2pBZDROVFJodFUyVzdmUlpNenpkQ1I1WXdlOWZZcjVxOWJQYWhyNlhraXVwSDJURDVCL1hrcXY1ajRFbms5T2hlZEw0TmY1OC9HNU9vc0dlc0N2Tkl1Mm9kSDgxY0ZjL2Q5WlZzQ2FqZ2hUZEx5cDVDQmZCQ09QV3drek5hMFFsUXRKV1NuN3RJamNncFZhR0FBaU1pWVlXbzdNY0laUDM4UXV3eTBWa2EvVFhFVXpZV0lNYTlDQjNMd1BIYW1nRlFwSUFaanNEaVBzaHBrTmhvK3d4TFJKenM2eDlWZzM4Y0JwdHVvbnJra2tHcSs2ZXNXZGpWZGRzM0tocVdMSmFXYzljY2E0cmErRGRTWnV1bWxqYy9KeC9MNzV6OG5keHRvQitRTENhRjB2emd6cE5GbjNwaHc5R0hJQmRNQ3FHTnhzUnVJaW9Bdmo0c0lJZlBhUWVjb1llNmpkWUhzMVg3VnRPNnlmOWZmQkNJZU5ZY09EeGZQRW16QXNQUTRQaEhHaEhSdGNrMnlFNEpDZG16R015dTFoZFlGK3ZXNElUUm01RXIxdUNLbVVWTjBRZ0FNaEtBdVJraXFTV2ZMWVFFeGZmMHFzOU9EWGQzNTg0N28xRDZ4ZXUvYkIxWTFpa0Vna1F0OVAwbGE2Yjg2aGg5L1k4OTZ1MTk1NWkrTXU4UE9qbU02S0VYY3hiZ2RDYVliYUNsamVRTlNTRk80S1JqT1VoMGJoZ05GR2RPWEZUVEtMcTJBTlZqZU91eUFMNElISklTc1Nod2VHRWxPd0t4VE1KaGt5V0RjQU1PamZkUG03WDNQbzVWcmVOUC8rK3hldFdTTFNpTVcwWk13dytnbkl3YURYZVdmUVU2U2YvL0xDWnp0MnZ2ZkVTeHdqZ0R4aGtBY3h6K1ZDR3U2Z0tHbk00MmlQZVNDRFU3TWg4NUZ4dHlSaDVkSlpPZVp4SUpvRXlJTlNXUlhOektUU1FZL2JZODRFUFhVNlVab0dQWFUxQnVqNThIcGIxazJORGxmRFozLytldDN5SlkzTHpDdlhNdEJqSm1WTlN3NjBrcDNqQmo5RWlnbDU5WjJOdTBvL2ZYR2ZzZFlsTDhnakd4eDl4c3k0TUVsTXVSdWNFeXl4WlM1SFpKU0RvTGs2c0Y2ZDRGRTJ6UEhaK3E2LytNUSs0ZU5pczU0MFZieDA2V1RYY3MvYnE1SXY2eHpVMmZEY1VtR0NFQSttS2wwSXIzVFJzdzQxREREUml6Q1JWYlg0dkhwVkM0RHNKeVNiTjVoYmdxSGFwOFF0c3BsdEtlY0dZVnhoUmpzTEZoL1cvQ0xlTlJ2bHZlMm9Kd3pOQmo5VlhsRWxUbnpucVExcjZ4Kzg1WnBydTQrNy9iazVuK3g4OS9wVDFSRTN6YjFpMWJJWi9hU1NXMVlNbVgzODBBR1Z4OWIyUG1IQjVjc2FCeTJ2NkRGaTVJQ3pqcTBiZFNuVFpjSGgvZUl5Y3dIRTFoa2NlMmt1TE5waE1qSDhGVGV6dWlpekNiQVZZakFXYklON21GbmdIbExRcUsxVXZkRjRrSlZUQlFGOG9jbEkvSXdCWkkwWWg2V2dUZ2E0L0l3U1FWRHBCVnpHazBCL3pRQVNDeUljNHlhQ3NMSW9teFNzSEh3ZXFhR3ZuM3Q2NWVsWnVSTzYwdGVsUjRjTit1TFhHY2xGRjA1MFc2ZTVaWEtDZUNQSXNScjhTYmFwQXRic1dMNWlXWm9JRVo4dlcwWjZCWThndldRa3NyRXNBUGZJM2RYTTJ5RURwbmx4M3greVBRK1M2eGE5bXFvZEoyYmtmS3ZYb0pkcm5KTmxpMjZhdlAwRjBpQSttUndHTU9IUFl2V2hEKzQ4ZmRRV25ST1R2b0R4T1pFVGN6SitnREJ5SmszS0NNNFVKK1lQaFdPMVBxUU1ObjUxbXNmbXVQcmx4K2hWejVncWt2TS9PUzVHQm9tRkFBWVk1MkQrTzN4bUhyRUo4VHpHUU9kQzdNSVBiaVoyeFZjYWhrL1A1N1NZaDlGaWlEMTg0SmdLT0MyMjNmeWowNkRGOGpndEptM2JldXpIZjYzaHRGaHVsVWZOMmFaWm5BZVFGZXYzMHcvZjR2c2VnT1NxZDV0WjljbXFmeHQraUp1UlpVUnVGb25rcjl6YWIrN2ZMbUx2V09SbXF3WFBQM2psWnRtTERCcjhoVFNERm9kZlp2d0Vmd08rQ1UvYWNrVEpZdlhLQm85R0JqcHQvcHpjdkxidjZnUWJxQzBQSFN4TDNaRmx5U0c0b3VzWXd3WXZVSWNTT0ZTTFZZcUVIcGw0cGRYbXJQYnRlUHk1T3IvTlZQTFVldnJoOHp2OFVWdEYvaXRQbXlwb0F6MTNhSjBhRXk5S1ByQitjbVNKK1BLaEQ4U0crdGNmUFRlNUZPZXdIT2F3aGMxaEpyZEcvaGkzVms3bTBFVmJTQllKYjZhTHlKek5kQTk5Unl3U3JmUXlzaUo1SVBrWjJVUkh3RFBBb1V2ZndET0NRcVZnbUFoYXBzL09TSGhXT2FUNTNJeWtWUVVJeUhLS1QrVFNva215NHFjQlJOejQ3V2srbTN2NHB4dHAzZUFuYmozNXhKcmoxNTNZRjZ6b29iZk9qZjRnWG5ab1NPSnVlWlp6NndyT3UwbWo0TG4yMUI2YzFkWVNONkVma0d4SDhtNnFwQnpCdWcxT2ZpcStuWHhSUEdXU2RPeU1HYTN2ek5CcnpNWEh6UE1oeHhzdjhGSTNPNGVxUVU2OUVaUUxiRFI3RCs2ZStsaEZZTnlYemRLNUVKN3ZpY2F6V1VhWGpSbGRBVnNuUVR4RGtnMExsQ2hzWGFwMkFKQXVwb2VhL3FSR0FiY1pCRjhlc0FZQmxBUkM0V0FWdmxuZWQrYmt0N1ZQUC9oZzhxUXRyMDBsWDl3dW5uMGU2WHIzK3JtV3Arbm5iNVc3eXQraW40MC9oOHdUbTVhVDhnbG5Db1I4U2d2RlN4bW16QkV5NFNTNGRQemljQkpUZXZMcDdiVFErdkp2eDNBc09nUmt4cHJqZkpUWmd6SzdRZGg4eHV2cG9oTThWeVB0VVIxUnhsSXAwWGlPaEZMbWdNeHhLWWZ0ZE9hRCtJRGlDMUhtRURPcUhIYnNRYk5aK2Q2ZlEyRlpIQmU1cnFZY3ZsWFVSSFdaTVpvRkxOWWhWelpjY2RYZWZmRmRWOTkwdzlTZFcrTGtuUEdrYU5KMWZoQ1hGRHh0bWZ2SU12cisrV2VKdDU4NWdYNjRiSjNJNjY3RS9pYTdkSXdRRnA0WHNBaEdrR014Tm0yMmFIUFE3clVCeG9raFZhbVpYTkVvYmdveWVnVDh5VjkvM2Y0Vjh5ZUJLdFZXaFVqSTVEK0FSSVBzUDdEMSs5OTIxREd2WUpLYnpTYndDczFXL0JNNWRpVWdNNDRkL296RHJ6STRkbXQ5SE43R1YwcTkwR3kyS243T3Radk1WcHVzdE9YYStkWWo0R3NZbTJKRUZWYUt4T0lsSTRzZ1pHSUo0SVJ4QzQrLzZzeUJGL2FvbWQ1Ny9Qd1RwZzBaZWxaVjcybGkvN3N1eXkzTHplbGZ0K1NLb3NMQ3JPTkFGMXNnNWovTGFoMEFDV1lKK2ltZ1JFakpRbFlsNUd3QmlHVHM5YkdTYVJtREhkSndZUTZZSUVhR3MzQSt3d0c5M2lHY2hSV05Dc1orQlJBVDVPeXdtalRCejFGc1dVMHNDTEZlai9xYzVNSnpVT1hpRm5MejdKUG1WMWZQdW56OXFuc2Z1bjMrSlhmT2V2RVo4VTJ5LzlqMUQ0cEY0WG5SWGJ2Ly9GTDlvaHJ6OXAyRnhJN25GbGpldkFyc2NMSytwbk1sQ0FOUmRsb1IwWGJDYkJHY2JqYWRaaHZQY2JoWldxTjRZZ3RwalN4bWxsbjVXQ09TeFl5VENTUGhhaXpFOGt6azMzTXhKN0J3cXNpcHNBT0xzWnJhZmlSU0UxTXlNQXlTNTFpUVZCenN0M1BidGcrZTJ0TFU5KzRGTjB3aDk5Q0pBNFpLMHUwOTl1K2RUcUliZDQ2Y2RjcVV1ZlR6Nlh2RzNWcTVIREVLeUhFNnJLZVFjSzNBQ0ZCanZ5RWhLeDRCeG0rUGFiSU5QVWNpRUdSdm1HTmFBTjZ3UmhsYThleFJmVkYyd2dpOGlkdUQ0M2Rqb1kwbEd2ZTRXV203REQ4Rm9neW1ZQUVnMzdNSTZuc1dmclpuZ1dQbmJCRTRQUGhmckdBanVZSTBQRUt2RkE3VE4waHYrc1pxdW92RTZLNEQ1dm5KQWVJTHllQzBwbW0wbFpqZ215Q1M3cVp2cEdIbWRXeHZ2UWJyUmRVZ081VlpZMExncEw4eU50Z3R2aGFrK3pFSDgvRU5kblEwR2FsNVdjWnIwajFXV2xaVFUxWWFJNU43bDBacWF5T2x2YzBueHJwM2ovV0UvL1R2akw4YWQzaS9KUUMyRElZcDFDS1Rqb3lGRmpEcit5dDU1cFpFN3lvWDF1NzB0clVrSWwzWXl3aDYvenEyTnlKelBDY3pTcDFSVjVYTTJyR1dFQTh1OVVGN3FGUjhUN29DcHJ4SVdjL2V2Skt3TjY4azdLSnN0c2xaUlVKNVQ0UzRFWjlhMXFhQ1VEUkZTa3JGdW9EUEZJdVcrb3l5UVhNbUJBNFpkR1A1dU8xazFJdmJ5Umt2UGtNZmUrMFYrdGl6bHp4Q1N0YzlRb29mZllSK3R1RmgrdW1qeExYbnFlblg5TGxzMkpUWjAyNDZZMHIxUllPZWZWVjhDZi9KZHZyWWk4OVQ5ZFZYeVBCdEQ5TjlEejlDaWpZWS8vTDF2eDF6ZGE5SGxxOVoxWDJLUC9jN3pKMkdDNU9sUlZLallCSGNyT0kxYkNkVy9kdHdjc3ExOUJ1U2ZXMXZjdHJWdElXRXJ5YXRPV1RCSUxxUmJqaUJMRWk5WkQ0MWZlWkhhSE9pQjB5N3piejBnSmw1cUtPWjZjNW5wcnUxSmQ2OUNvMjJleEVZYmRkb29xU1cvYUtrczNucUFmTlVGVlY3eUZxVU1DSlJMVHRpMXFJOUlEdHhCZkpNbFYxd2Nzb1V0VnU5bXVWVHUrTDhkWWVzRG1aT1lMK3FWZjdRdkVGVTVKWG4vb2lVVVZmeEIrWnRZckx4N3BHbmZMUG0xZG1YRFR2L2pITW0vdTZrSmRkSzQyYk9HblpEUHIyWm5FVWZKbStPNkQ5MElPcTg3VjZVVUowd3BmZWkrQ0VwSjkrTDBpeWNJc1JGVm9PbkJjSElyR1JHOVJXRkwzWjdwTDhwa1hYc2hnR0JBVTlGY1I1TGFZUWdiZTBUb3B5MVVPVnFUVFR6WWhPelVXTE1LcTdkWnZoVUxPNndHNmU0L1ViMWZWM015bGR2UlduMytsTlBQKzJ5MFZmVWJscTJ0RmQzdXRSYVh0TzF0N3l4b1d6MitSTnRuT01mQmphNDBMREJPanVwSTBGU3hyOE5JeUg2M1dReWpNWUIrQmt2TjVQUlpOUWdlbDBPdmU2RTlFdGVpOHBxWDYzSENJRGpoQ3lqVmpCZC9lcExWNzltczFweUI5K3hROTdGWVVleXhjZnFqWHlzT2kraklqYTFoM2RFYmV5OStwNWVsM1kxc3RaeWZZL3YwSjlTeGJLWjR3dEIzRHFpT2plY0hsOUJOWWRHSk13aVVPWlljQTdaY0hBa1V2c0IzVFJ0ZktneGROblVhMGZQdW5XNHBkMm96SzJoVzZkMzZUcHJacWptcGx1aXJXUFRkYndtUGpiTDMyQnN1TnRTanZzdGJVY1hNRWFIREVScERBdG8wTDhYUkZrQnVnMFFnbzhoQk9TSGluMjg0TnhqNHhBZ1Y0RlVJb3VWbmZ2VUlPb1l0OEd5TXVYS0pJcTVVSmx2cFFYY2FnU0VhbDI0KzFOeFFaZlNjcWNlRnc3OXhnVVViMDRGQ3ZFd0ZRUUx4bHZ3RDVoTm95OVNoVmk2a05YUGlsUVNIdG1GNG5wWVdhc3JWZFlhd0owT1BNRmhWSm02R0VNZ2dyZHlHSld0UVJiUklpUmQyUXBmRW9Ib0tvcE4wbVBKWGFJNytZc1lTM2FsN24ya2dHalhwS3BkZVhXMTJNaHJzQ0o2SFhKWDRUYStzNWdvTWdsRnBzcFVNU3BXdzJlYld6UmZRQzdhVnEwcExoaGd0OHdpdGp4d2hLVjh6VlppV2JVTEhHRWdYRmdFS3hPOFhhblNiUGVhaWxrY0MyQUJSMkVKbmd6UUZCOVB3T3hLcXBqWmQ3Umlabkxrd3Urc3ZwazgwTllqZEZ6dm5PemFnWjlnZFpTd2R2Qk15aG0vVjMwYytwM3E0MmEzbmJXcjRPcy9mRVFwY25yWFBxTW9PWG11c1lGdnpGZHFsYmNiMzRuLzd2ZzZISkxodkRPSDlKbnV4MU5ETXJlbUhIcm1tSEtFRWI4M3B0emZHeE51cExMOURKZWI3ZTBjT2JxVVc4b2NZbG1tUjhvWVo2WXI0dWNJcEEvQi95Q0dqQWpYSDMyMHlIWVZ4eEplN29KeVU5c1hSNWx4Rjg0NElrNnNsVVFzWE9EanV4ays5UHplNEpFaWRRSkpNMlViM3dFNk5TUk11YUVNbUFyKzUxWDRZd3pNaVFlaWJBV3ZYb3ZMckd3RllxeVhuYXBsQWRhSGxhYVkrTU93cExiYVJhS3VMbE9yODV2YXF2T2d5YWpEa1FRelBLK0M2UldyT1FjWk8za2kyOGxUczFNNDNaL0s5RElBT3A3VDhNcXNjVXVJRjNoMnNLZVgrYlBaVU1oelRSNURJeWxGSEdEbFFha2YrZmhZWFM2ejBiQlFqQ3VuZzhyY2tvNHFjeU42Wlc2elpNL0s1K2ZtZnI4NE43MktPaS9USldQMFJmVjc5YnBpZG1xdHRaV2p2Qk01S2pxU28wdUdIRVYvVkk1Mk1LQnpZUlprMnNudkM5Um1VVEpjd09SS3JjdHE0YW9PSk1OVFBUMWlpVnh1U1JWZ1NUMHpKZFZYbTFvZ2E2WHdzaHU4N0phV3Z4ZDhMeTNBRGlIZW9QU0g1ZTlrY1hhdWlIZU9YS3EvcTQ3SGpsakJJcTg5aFhsV1lEV2QzRkgxYVY0bUVlK0hDQnhnVVFZSkk2TVdGWWtTZXdDYm5YakQyQlNsdzRMVWRBeHFYNXJxMXVOUUJ6V3FscExNMnJMMFdJdUV2aDJOdGJpalN0a1NmWjhnN3ZYbDZBY3FqeGhjTy90ck44SlhNNDJ1ZzFHYWZtdHZaeElmSzlpWkFzaTRxM0RCa2FQRkFGVVJTd1M1a1JWSERheWpqeDdOS2N2SER0bmkxbFFwdkN4Tnk0VHdCL2NsTll1M0U0azZjL2Z0bGU4ODBvNDZrTkM4NEVqblQxak4yeFR6ajBKUFlhbSt0NGVOZUxROGU0dmFveHJyTlluYWk4blVVMjVSZS9MVjR2S3lOWVF5K2VXV1pxdS9BSHZMZ016ZHF0bnhEc3g3UzN1Q1pObUFyMVdYMG13cXFjQmVNV28zWDhJUnlpdG1pVzJCb3RsbGdIWitMRXRVWUlubENReC9xejJVdU5XZnJSLzgwS1cyZXNpUk8zSnNRNDZrejM4V0JaVU43NzMveWtjTHpxek5PZUhVZWVPZjNmamt4SDRyaHJ3MS9JcHA1dzA2WWVpQVc2ZlRmNWdXYlh4aTVjTFpmeHA4WEZGaDE3cm91U3N2dXI5cDBQTHlLdTJrU3djTnYyRmt2NG14dXJOaXcwYnVQZFFBODgvcUlDR2Z4VHJJS21IVkg2cUVyTTZzaEN5SHBWYkJsMXBGNTNXUlBUUHJJcldLY25pVkgyWVZrczFXZDdmdWJQdnkvNThTeVhUV2VQUmlTWWV4bW85YU5HazZPYld3TTNYVlJZZ0pkMlhxcW5zYlhmVks2Nm8zMDFWWDBGVlhHYnRWZGFpZEdqeDlqK1ViZGtkT0x1cWlXdGxzZFljTENrdTdwRFNqeW9wV0VzRkV1VmYzZjBGRDdSUFkzNnNwdlNYVGw1eDB0QUpUVTJtYjdMWWhzOTdVcE90c0hiT3Zuc0t4d3ZZL1lHSFlCdXlZV0tJTGR6bTl3ZVgweTdRNFJJK1ZQa1lVcHMydHVVNHVnaFhhQzk3dlZhM1YrZHBwdUg4Yis2c3M0OXZqdlpTNE85OWF6ODYzYXIyUGdlOTF4bEdPZjlzTU8vRnJSemZLanJ6Y1VlMVRhajdDNFRFN3RSeG42Z3YrdkRmRW44ZUVlQVZtMnlVeHJRZDR2TndvcTRSRWZ0NEdQOVpIRTFLMHdvTW5FRUh4TmFEclk1bXVtYXRqYmJSd0R3M1B3TlJFOFJoTUxXNDJBSHpBVXNKdXFGQ0hFOVRXVTRsN0tteW95R3lmcGtBNnE5WXE4VUJ1Q2I0VDVwMWNCSzFIQmFpeHNGNk5LczFDVmtFcHRoNno0YjQ0YmptcEhrVjE4dktFQVNSVHVXRld3cEpQaW4zRnhnNStSWHRkbC9GQzBiRS8vYk41OGpVTEg0Z05mZUdDbVE5MjZkMTB4ZGEvSk0rMmtsNW5yUng1eHVLTDZMZFRoejEvQytqNjB0RjNyTGszc1ZxOGgvdzIvYnJyNXBMeSt4KzNjZ1YzNlQzNjNOSG4wK1RlUyttc2t2TEZwVVdmVDcra2FlbTVZOWJlZmFIVmR0blhLOWMwR3JVdmV1MXhWOXc5eU9RSWpBSmtuU05JRVFPZXpvaUJnWGJKNGMwa0I5VGlkcnlBbzRnZGIvYXhvbVhsYUVYTEhWQ0JIZFl4LzlpT0RlaWdyRGw1K3hGY2dNVHJnc0gvSVZOVkt0endlNVhCWmUwcWcxSDZmQjRwOHROMXdsaklFc3pIUWhiRm1WVlV3cyt2L1l1bHdtbmYzMm5Sc0V0Mys1MFVENHR2Wi9qN3R2SmUvbCtWdDQyRU5zV1hrSnhLYmhFWE1PNzJGTmYvYXlJYW1WU25JallhZVZUSElwTDFhZTQ1VThZU3NPYnIyc3RZQVRKR3VJd1JlOHFjVWNZSWs3RlVseEhOMllidUlBQVpQVmp4WnBBMUs3dUFUNmV2MmUzSjQ3bGlXM0VqUnhHM1BlSGFTUzE0bTBSclJHZUY0ZExEbVRFcStSS1dpWnQwMmRmcHpHc1UwYy9SWmhqSmpwNHhiUCtCWWFrYnVNcFl1eG5YT1Zoc1hxbFBmbk1QU3hEQ1VvV1BlWVFlb0tuZThJdUtZb2oxb0NETXUzRHp2VnRQV09lV0hxQytmOUh1T3drMm5acUlwNE9zckpNRmNVejdBQ01lZmdLYzRDQ3dtVFpjQ3NuZ1V1US94S1dja2psMXR6V2FFcGx6ZE9oVVhwME1ObnA0UHp6UHkvWTUyM0FwNUk5eEtYSUhYSXAwRkM3Rm4rSlNHbjFIN0gwZWJNRmhwWDVNK1VYVFFOQUgxcDJXcERpSXRwV25rWTRxVDB2MXl0Tm11NVJkd05iSEh5ayt6WEFCSFphaGJqWFdmOGZscUdSM3UvV3ZqejBYNXZKc2ZleUZ4dGpMN0x5Ukc0dzlEOGFlSjdNMEZjZmVGUU9Zb0p1c1dxSThZVmQ4NFZ5SkwzZ3R5S3JDeXdvN2xxWkRNTnBCWmUxRG1SWnlaU2RsdHRLSmJkYjJPS1BxMXFUTHRvN05DNkxQcXpxWUdTUzVxbUtKUEc1QlhhSkdLcWpQRko1REx3UmpLbXdETzQzNVk1dWZoYnpMcXZ6SDU2K3oxZHJoYlBic1lLbDJQTEhpaEE1NEUxYkRDUE1iRUFwUS9rNnFHQXN6VS9xUXN6SVI1bkU2M0VsTkkrNEIyOWs1TDY4dkowL3ZwUHBINmhyVEVicGRoZU5hSXgwN290TFJYSi9KcmFUbGlXQUh3azdrS2YzZHFreWNUUW5ORnkxVnRTdFBlSDNaT1lYc09MZWIrVjZYb3VVWDFQOGhrZG9ZY3p1NXJtL0R5Undobk1uYmpvL244cTBEK1lxRTdzTHRuVWlJSlRYZFlva3NicldsWUxVOU1pWEc0Sk1McHBvcnM4SnFGbjA2MFVNVmhxeGNrTkJuZ1Joa3IrQjdVSDkwTmp1eDVIWTYyTmhCVm5Pa0poN3FnTGVYZU8waTZDTW9GQXM5V1ArTk52V0xhTG1Wc1VRMlYwUlpsTFdRRG9HejhxV2NWUmNmYnhOZGdqV2RabE9Rd2E0L1dPMG9kU0pneDFXUWJ4d3Bad2VGa2ViVE9xcWpFZWpwcHUvMC9sRUZxUjRldmxpYjNXQ3M5OHV5dExScEtGWElRbTdJMjRLTFV0Q3k4dG5PTlFybXpZRVo3YXpQRk9sZFd4ZER4c2xJSG83b08wV3VIalhrdXVNSGplMWFNK0NZVjlzM29UcjQ2K0Rac1lHWDl4dnJ2dHpIeGorV25pNzlSVDlQMjF0NFZZaDNNZXoyeUZTZmRScXp0T1dVYWpvNVhkczEydHlkWmZhc3lLUmE2KzV0bDluWHRqbHhXNFo4VWppZmRieUd2SWtsODNoQXBrdTlLdnUwcWxoOVJodXlzQkl2Njk0VFU2eC9OOWx2cjh6Zk9hWjdYNFppajU3ZUo2OXVvMmJlVDhYMHFQVVl5RDJML2tDbnJPSlVwNnlTLzFxbnJJd05tODU2WnBrTW1OSGhackxwcmpUS01NNlVOb0RmeG5GM2ZHSzNPSFZpdCtSZk9iRkxNbEJSQnprdk9kMFliZ2ZacnJRaFk3Q2lzQU5zbWZmYnloVW02ZmoyaUcxUlBJVVp0T0R1cURlMWw1djNPN3VodUFlS21OVHY1VUJVQytad1B0aXI2TWNuTTNkQ3plMnNLbU1IbEQ2YXVUYU5yYytEN2Raa0E3MHFkWTYzbTNCL0I5bU4yclZhSzdXMFRXTXJPMGhxU3J6WXhEZVYwWGJIK0dKakhXY1VQRnlpQlV0Z3JSVjBaY2Q4bjNCN0NrdkxLeGdjS3UwSzhsV3dMcjY1SmVVNGlVNWYzSU4wMEI5UGJ0b3ZyazZUR2pJOFF5bWRwRE90NFRZNll1ZUUyVnk3aFdQNUdRcnNhY2FhVytpTnkxVVNaY3JBeHI1TzF0alhZYS9VVzJEWjlGMTViRVlPWWJFc2JHWlRaODFiMzBTS2pxT3J4YXRiV3k0UlN5NlNMTW14ajF6L0JqMXBPZGxmei90c3RZS2hoY3hmOGJNYnJPWkxyR2I5cit6OGlUSStVZS82SmVHSDE0V3RTa1N4bWpZMXpqbmh0Y1lyeE11dmtXekpjV092dkQxNWhuajhrRlN2dWpENEJobm1lNHdlUVJ4NjVNQkRJYnpVUUdZZWxQV3pjWGo1T1czWktDOVFyVXF6NkZSQ0NJTWN2cmhrTnRXblcwRzUwcTJneExwVUg2aU1BZ25XRWNwTmVFY29rcGVxa1RoMFFRN0o2NWR1REpWUkxNSFB4ckdhWW81UnorcjBSR0hoVVU0VUZyVTVVZGhzc2daem1QMzkzcUhDZENyVjluamhPcU5Pci8weHc0ekNQZWFMTFhIemd6RHVRanpweE03QXVjRjZHRnJMY3VsOWl0R2UySTV0dnRTU3NMdDg3SllIOUJiOFlGd1FrRXFRdDFYQW5BT3JpWE9NYW1LRzNuS0M0TFJsbjhSbXdvVzRKWWUxeVJhUWFiSHhNalhldXppajhnbDlPRnRUZFVvNTYrNDBrdFNPSHlQK21ueEpEQ1cvRS9zbXcrUFBwanZvSTVzTy9Iamw2TkdYLzN4QWZKV2NSNmFHZEUvaUp6UEllYmdyVzJRYWxVLzM4dnNZTE45Q2ZDOEFUOUpMdUVkZ1VWM05pMm15QTF4RGxIa1VySm51QWs2bE9wcW85SVJSemtxN2NZV0ZWdWhKWlZGWTAxNFp4YUkxZENRWW5XSjZJcVZKZWZYOFZEVWV4ZWp1aTl0bDFqN0RaZER5Y3BoWHRzRmZ3ZjB6dFJMaVdXRVovcFV1QmpYcU93cHJMR1IybmpCei96S0pmbm5Uem1QN2JKMjY0NXRrUHhzWk9QYiswV2ZlTllGK09lWFkxK2ZzcGEwUEwzdm9nV1YzUDlpNFJQS0w4czNUcHkrRTdJdVF5TFdUcnJ5ZUh0NTNDWjFkVXI2NHJQREx5ZGVRQ2tKMnZmZm02M3ZlM0QzeDN0V3JlYjlpNlF0WWo3aXpOckhERGxQVkhYV1k2cWwzbUJwbzV5Mm15cnBXOFM1VHpmNUF0MHBtMS85bW82bTAyUisxNWRRK2ZSVWN0ZldVeGRzbWRyTHpqTENXVWVZck9qelJXTjNKaWNhZStvbkdnWForcEZFWDI2Y2tMTEpabC92Zk85ZVlkbFZIUGVFSWNZUExmZlNqanVTalRCNkY5Uyt5L0Uyd3NjenR6TFk5akxBMVZrRXM0ZUpaU2xhVWdSMzdIdXdtaGR5VWxkTUp5RmpwbVJ0bldUcnZkTlJaWHBMcWdQUjBSeFZTNmFaSXBzbEg1aUFpNzVNRTltb0h4TkJ4cDZSQU5TdXpQRnFucExTU00zb21KVmZyS2pXYUo3V3BsMlBueEZoTnRiK1RrMkx0bm52a1NiSE1wNmJPakZHLy9sVGo4RmhtMmJVaHIrVWdQRGVJMGY4SWVWVi90ZVoyODdwQkIydTd4NC9LSFUzNmpNbklsUDhwbzltQm9RRExuVWFqQTBQK09CdkhNUjNJL3p2ajZFQWJiVWFSMWtlSk1RcERJYWxtRUt5MjNXUktTRXNacjF2SjdrV3h4MUxsN2Z6dU1idFBzUElMeGNBRkNYcGkyYTRHa1pneUdZKzJwSzRna292aEdVSExLRmJYTkFUUHJHaGVNOVlWYXBMWjZBV0pyWEQ4L0xZalgvb2VzYzV2OStqc1hpSnk4WFhqTHBweTQvaUxycDF3VEYxc3dNQm9yNEhtV3k5b3VPYWNDNjZaZkVGdDM3NjFkWDM3TXJrRkdOTnVzd29qT2tGQVU4T09XYzVvczAwS1FON3B4VE9GVVdOb1lUNjBjT29pTUdOb3pyRGVMUk1ML2pINkZJaDRQaXlHVWFkS3hPUDJSSEQvNmV6dVo1d3lwTEJubGZkQzkxWG5kaDErMnBEaVhyMDhwc1IxYzBxN1IrcVBoVytWcGNmMC9VK3B1NTNlZWQzdC82VjFvemYrVit0R0FmZ2UzbS9PWWVjdUcvaDVhTlViNDkwYmZCS2ptR1M5VkVwdnM1Z3c1N2hUODFKUXJlYnR3ZXRPVU1yY1BKUXlGNXN1NXJITFQvTHdTSHN1OS9uWTJRR1B2Z1dSaW5QcnhWS3NFMk54TkpSUGVDaExOWGRpL1JtbCsraHdjdlBPOTU5NzlMeWEyck11bW5EVFBMcW9DZnMxMHN1ZjJqai9xVGVDUzN3M1huWFQ5RW5KWHF4OVk0Wk5tUVd2NFdkVHM2VTNsdUh0SVFXalBTUWU3azdwMmQrMkZQcktGTDVmZHNpUjRjOTVMKzluQVJkbkNlZnpPODgwQlk4dnlLb2ZHWXFBVWNFSXdEamg5SVFRSnpxbFZITU9QTTdnak1ZOWJBd2V0NTJkRXhFMHA0Y2pIaHY2dWxUUVo3QVhnNzRKTzhiNTBvMit5U1F5K092SEJxOTk3Q042S0Y5OE5qbkFRYVNmVnUyNC95UDZISDFNM0VuT0lITkczM242ejk4dHBiL1M3NUd3dVBGL1lUL1FmNzBQOUg5Ni9mTC82VDdWb2lBYy9zN3lWM2F2VGtSSWNPWUV6NnZrT3ZHd3E1cU5oZ3hoSW01SDR3aWdJVWNVdTJISTROeDhmTms3b3JqQWNXRjd1UHRpMSs0MC9EcVBuV2kyVjNsVTZ6YXpGZ2dmOEtpaGJhcFZiclpaN2Z4cXgyQW80SytNdzQ4WnpRemdQV3htMEd5MUJVUHN5UElUOW9EeDJqaXVqSmVYcUI0UXRCK2VEK2t2K3Z6RlNneGJFWVBUS0hZd2Jydk1PRG5YczMvVmdHNDF4dzhRbDE0dmRxWC9hSVdFOElHNmthZk52WFNReVR0clcvenA5OGFMQzNMNmpmK0ZhT1NkNUJyYThNcDdwdC9vYUdyNSszVk50ODI3N1ViRHAxanpXRS9ZSEt3ZWRldDY4dWt0OGxtSGN4azlJdGdNdzFSNGZwWVRFUXJ2YzY2dzFsckdTWDFMVlBYeDFzWU8za1FPY2o0Zk8vT1c3bjZla2tkSmliS2pTV3hZZDczWWhmNldwQzhrRjB1aFdjODN3L2g1YjNRK2R1eVBmdWR0OCtaTU1YcmxNci91UjZ6dXkyQktVbjVjOW1VZVAvTHg4WUlmVjFqckFBWDl1RTloUFFYUWp5c01FVEEvSHN6b28xdWNvaHU0ejk1TC9lVFduZTgwVFoxTDUrbk9lck5LVGVTYnFXMzl0T2w1OE5NT3lDVTY2cExPZTQ0NGVKZjBVS2RkMGpNZGRwTjQwN1BKTzhSRk81TU44WlRmVG80UU55VlBUMWFJYnlaN3RlZGtYZ0w5ZElVeGVJVnNySHhoWTdEclk3Q21PdU5LWHJiZmhKZFMrdmlPb1kvMStOSHNYdFlubDIreFlVOHVWY0hPTERDcGlpOXVEYktrM202VStiRFJtOTBaM2JwU2pkRFQrNFV2M2V1MlNubUorMlJiNnhlWHBaQko2MTgvVWsyckQxNHZ1WGZzT1hST0dxRG9kN2pzTisyMmxyTjdwQ2J6VTk1NHpveG5aYmFZV2xLdDVWcGI0cmtsTERDSDdmeFVIWGo1OEI0dHk1dXFhUzdVMisxa0FjU0wrMHM5T1BZQ3BkbHNDckh5bGtLZldvVGR0ajI4QXczdUtDbDhSNGxneHhWc1Erd1JqZkFOUC9IR0FRd1lsdWM4U2Raa3VXMjVUbkx1SnRwMzVPeTFOMTR4OHB6enJwZzFrTDY3MG5iMlZSZGY2RnpwM05qY0RINjU5Y1BxcWhFaEthL1ZzYm5wMVB6R2JoZk5OVDh6WWZqb0MrOWRQSi83ZXJySTlCWGpySWVtTElhMXZCZWs5SldHNlphOUdadUZiTG80empMcHZldmJYamFBbGdzR3RMZUo5dHVBWGZGTi96aDRQVjFFcnY0ZnVQZUVyNDJ4ek8rSFVtZXJQTTVNMUJsSzQrSndxb1dDS1lVb1lOMGk4K1RUUFF6ckRocnlwRHdNTGxvQTc0dzlxRWg1RjJsd2N0eStwNytmM0pvOCtPMldoemU4eXpqM21qTWZXZkxPYTNmT1hEei8yditkZDdJY2NZZENCbHEwZElRV3JSbG9rV0ZFaGczWnZIbm9Jbk14bXpjL29pdkd0SHVrRmsyd1JLTnhKK3VmNEhUejNpd3MvVlowdit2ZW8rOVpZelEzV0JMY3ljWkdoSWljR1NOS2NBc2xMcGs4L09CRUhUWTZNdTdKaUJCd3d4YlJjOVhkNzdyRUdjMnJXaXRXa1J5eGtUNnJ2TEs4Vlh5VGREdmtUQjRnVjlORm90VTA3dnZrVlczdlB2bnZ2bk1GVnBSbEhvdW5CaFBnOU1SNHQyM05iSXZ4TnV0ZTF0akdJMk80NUZmTllJT2dacFBWTGZQbWY0d21Tc1dCaUVKRThmams3cWZFTHF2RnJsdVNiNHNEbjB1K3NUcjVodmlCcUxFZ3dMNlNaUmdJOEF2R01SUjhKOTdIMGdWUEpGY1k5enptc0tPNmpwYUV5MW1SQS9LNzBJNjdzdjdjZVBKRFJzdk45N1hFNVh6VWdvd1VkamRHRmxSd0lPeFVOSUxWd1M2ZlZsUmNqemRCeFVQaC9EWTNDS0xGSHZWK3g2SG43YjE0MjBzZjduMzM5WjBmcnBwenhXTlhqN2pvbDlrZi9oYS9YOXRDMzZjLy9WcC9UL2RlUzIrL1pjNkNPMisrZEhxdm9YODY2WlJ0alFzMmhXMVpteGJ1L0lUcG1NVTJkaFo1WkFlUlRjNk1iRVlzVTlyRU1vZWlXZlVlUWI4YndUTGpWdnQ0bFlxejVUQ1dmR0hKRWFNQnBLUUZJRVFGV01JWXdKWWlZZDVRSlQxRVJObUtGL01yZG5HQ0hyaU1nUmUyR2JqTTJxUEJYT1RqOWpmV0NXVDVJSHZCeWcrSDhnZUU4YmVKWHBtaTFiU1BWKzBDYzV0WWhmaUc5Zkx2Q04wNE05R05xM04wazRscDJtSVoxaHZ0OExlbUJNTjNpN20zQVZUYUhIVDZQTHdodWxQV2lFTy9KOUd0dXhybkhnTytNWlErOWRkM0dVcTNBVXEzQUVwM1p3Rks5MjVyMDRETTQzVURTbS9iY2d6ZVE1UWU5MWlzaU5FVE5qZC9wU04wQTVrVDlGRGduNndPWXFrbzZYMU03TFMrNTlTS2g1cG9yS0R2T2N1bURnWG9QZm90OFVTeTRlRDFwdDlhYURVZDlZajRmODlkTlArTjl4MzkzM0xIRE5mTFY2dzNmM1ZicE1RaGtzMjRleHNTUVFiRk1EdTNHN0dENjhCVTBwVHNndW13NmJkRHR2K01lMnYrVSs5dSt6OS9Id3JMTDFnUHFSNUhaaGNvS3BmeEQyWUduZVlDSFlGL2hqY25ndDIveHU2TExoRXFqWnR5R1JtU0NPVUhMSkJ6UjJKYXlJR3Q0QkttSXZaR3Q1aG1jdUl1TTFHNzg0b3JINnU0WXJkNUZrU2oyS2RWczBhaVVYUWZlRldxRzJhcUIwcFJsSThCZ2xlMjl1NVAra0tRRG5LZ0RKWkVncEVhdmN5MUwrQ05Fa3ZLZWliTy92dTY0OVlQWHZmTHJNV3RqM1paMy8zUlEzYzg5djZMNFRydE5mSHNyQjE3ZHliNmlKL2UrK1BjVFp0dS9lbmV4a016UC96dzV0WUhuOTh0eWJ1U3o3NzdiT0wxLzdiN1J5Qi9NaS9Neko5MHN1TDM4eWM5YWNKRmF3VGR0czRyWnVSUDYrL242Uk1Ibk54WE5vRnNEekYvZnBKZTY2bWZ1MDBvRmtZa0cwQTQvVUQ0ZE5VZVpaVlM2Tmpka242NDFLTG8xRStxVnBOVmFTZ3NWamMxVFZ0dy9vYTFUVTJMdDAxOGRhODBSb3dsUDd0dWNsNnRtQUJQZW5MdnNpM2NQMWtIWnZwdFF3ZHMyWmp0c2FPSWJ0T3ZoV2lmT2lLcktBNkIvNjgzWk1mMFVUQnlWdXZMREllTlNUOVBzenFqS2ExN2RLM3JENWVQL25BTUlVYVhkdVdJY2VqVFVMTmVyR3RhdHlvOUdtTTJST1l2ZnRUdnJocWg1eWh1WjVyZVQwaEJaeXAyaFJoZ2NMUFlGWGV5bG05T0pJTGN2Q09xMWRpa0M3clp2VlhNa1Nqc1RteExwRmp4Ryt0RElkL3ZUeExIb1ovcEdVMy8yTFQyMFJjL0JCZVRYTFB6VlNUYkRxMjRiZDZ0VTQzYzByeVBZU1kvUkxsUitqb0l4Rmc1RnpNWjdQM21UOGZXckhheDFjc0hoZXJDeFI3MjhCNXdtdCtwanc4MXBJOHZSYXNSTm4vZndnQmJmNkwwQjdYcDhlM3ZTbThDdk9NanZHUGV2RGszSkNkeTFwakhvcnZaR0ZPeFNIUHEra3RJdnZUWS9PM0c1dEVWeG1OUjVvQ0tpOWdsNG1VUWxUQ24zZEZFY29oRUZIcmc3M1FYS1NIam5uaUZIc1RSN05yeDB0NDdpV2YyTk5ZZkZQenlKZUFYYzNEL3dhN0hJLzBLWDVqRmdCOXZjRWZXbGpHUnZqMXFrSFhUai90WUdQRDVlZE1WUWZQYWVjTHRWN0MxZlFEM2VpSDV4dkliMFplNnB0Zmt3MnRvZWFFQm9BVkl1OHRMSXlYV3Z1dS8yazE2cnFLcmFXTGZpdUhyTHlSVzRySWxoNGhiUXZUQXUrdFhtVThidVlHKytENjlpMDZwV3h3b0psbkV0dXlUZ3lmckhNZmgvZFpIQWMvNGhBSThYOGhpT3R0eUN1bDdUWEVyNitDR0ZxbTRyWVpXZVlHVWoydlZ4eElEUkZOK24zSGJDQ004aXRpSmRrVDRtTUZrSzVxYnRWK1hNQkE3VW1mU1FmTytOQWFTaWhXU0FZTmdGczRPa3lFa1RMcVJVK2htK2dIZFI1OXcwa2RFMHplZmZmSDFsMy81dkFVeEd1bEJCdE5wQUljZW9UUEl4ZVRrNUFSeEovMExmWStCb21KU1J2ZWlyQURXVFQwWUw1QytMdzd5SHlhZ0h5Q01TeGFzUnFJSlM4NlU2bmZsNEZkNkE2QmhhWS9IeEdsK1NNMElRN1N5aS9NQ01Ia00yQkRjWmludGl0bHdNZkhMeFRFTVU3M0lvdnNYd2RRNHlXMU5BTmdXRGlNTmUvYkZ0NGhYOW5yMW51ZDJnV2NjbmxTbDMraFhZdUcwLzRmdkRMb0cxbFBNL0RQNG5SSmhZYnFtQnd5TzdZNmJxNDNqVFZtczFTNm1ueGFRMVJkRkxnQnIxa3RaU3FXVzV4QklRNnRlaFZCbHJub1ZreXozTXkvTTVPMmZ6ZGdtR25JcjFiWU5qTkVHaVJQN2s5MTNscDlsYlBscWhYZzN1K0R5T1kxdThIV2xkV0VUU0dsY3VCRmdiVW9DdmxnUjNqM2hJZGY4K1ZNU2VxZUFxa3Z1V0doMUhmdmNwUzkrUkwvNDdIQlQ0M3FBNWIrY2RQdlY0Z3h5SHBuYnEyL1pvajdGUlQvc0duRWUvY3NCK2kwWlErb1AwMytRcWVUU2ZoUFEvMktOWXFXcFF2QUEyaXRNYzN2NmtReXQwTkdTQ0hQbU1leEkxZmJoMmJNdzQvWjh2RkJSelVWRWJKTDU5VW01bUhIWTJQSUw2ZHhlV05Hc3RucEdLcWZodU01OVdOQU5abEo3a2VJTlpEZFplTU9WODJaOHVCdjhZUmNTbXIyQzdpUHkzVk52bUVyZk5sWFFmMHk4MG0velQ3MXlXZVBjcDg0OGZjRkpaNXgybk43ckhtWEo0UFZRQnBNanpldkpuZko2RzhTYmFiR3BZbjdyZUdZYlhlaGkweEQ0TE9UMUxqQjRQVWRiWHM4T1lkRVY1ZVVzaWkzTjYzblR2SjYzcGRsdThkb2dWL0grVVZvUDAyZUwyR1hVTGNza01XZmwvY25zK3c2U24zNXdMMXlnRWxCQjY4WFVUQnJvWW5KSXluK2ZEdmxmYzYrUkNYQkEzRlFHV0NXU3dROW1zb0xlRkN2WUVSRm9JbitoSjZoazh6S3lSYVdEeWVkYmFmZGx0SWRZSWtySnBQR1YvRVRNU1g2TlgveVp4NFBlTGdhOWxlQk9VTEhBNzVTTEJ3bGZBQW1IdlRqb3hsYU8vSmdqNUZRRmVJTVNXbm9XMkpHYk5mZDFZOVYwS1VaVkNDYU1DN1NEcDhZcmhCdytMU2UzbnRYQSs3Q1hTdERZSWVlVlBNV1JtbGdSdXhqSVdxRTNTdEZYUThueDJ1YUZpK2p1dTY0aFZYOC9aZXI0K3JVN3RyeXpjMXJEMzk3K3V0ZXlNOGFkODlUdDYxZmxkcDE5OG9wYjRuMnNwWE11dm11dGZuZkpRR2F2UXpOdUo4WGlWVXVNN1IybmlUWEdNbnZaTmpLajBQRENIeGkweFowbXlZeVNhTVZMR0Y4eWdKQU5LNnlTT1BDVnV5VnpjcnVwSW5tK1ZpZk5QL1NCT1AvbW1hMDM2clhPQTgyZndQTnpoZmxIakVETnJ0WjgxaGFqV1RuQVg4QW1xZDVHc0VnOEVwYkZlTnNNc0Rsa3M4T2JRUytyb3dyeHN3V0FrbkdBWExGb2tLRFdiSGJoTllDWUVCWlJIa1VHcVEzTmx5blJoRFkwWDN2NXpKK2thVDdkeit3SFhiZmwrVWhibmsvK1BaNXZReU41WGFVMTVLZG5hQzQ4OEpCb1RoNU9mc2l0a3dqeTRaK2xIZkFNV2VqQ1QycUFOckZtanQxaXhLK1pWVml0SlJZRStQaTlobWhaT3Z2bUlHQkhjakMzWVhhSk9Ha05mU0hudk9WWDl4WnZNSlAzeVdlSFBwQlcwZlgwaW1kMVdjeFdXSGNCN05ISzFwM0RHMHZ0eFFaQTl3RjlCOWpMTDdoeEJrQVkwYWJYS1dIR1A0RHJGOVFjSWVVVnlvYVhTS2hicEFEUTBCdUxBbjNvL3R2by9sakFWSlk4LzRvWjUxd2pQbnZvSTJsU24rWEpDOFExdDV6VXV0VFFKN1BkdHJ3YWFjdXJPZEs4bXR5ZVY1TTc0dFUyTklxakdodVRHeUZjRENMUEh2cUFmRXFMVTJkMi9rUHYwK0c2cUFCZHRPWFNjR0FXUjVwTGs0L0NwVzJRcHE5SnZvTEh1YVg3V2lmODc3dWo1ei9wamtRQ3ExT1FibVR6bGVMaWNCeUNvdzBYSi84eExxNkxOSnl1YTVSV3pRY1VJcTNpKzJiL0kzZGNTTUlrR2pFWG1MOWluWThMaEQvcFBzZ1ZZM2RSWk92bklpd3hkdFM4SUlvQnhsU2RtYXI1T0xLUVBOR29sbzBYUUxpaXJNOE82L3JwMFE5MU1tcmFpZHg5U05Ic0FwOFoxa2ErdDRBY1QwZ0lCZ1E4SGxRdXdLb0tLeDVDK3BNYXVXd1NDZjE2N3k4a1JQZi9jL1ZQdE9YaERWdWI0K1R3bGtmcEEyTHdKNUlmSUkvVGtXSDY4YmMvMDgrRE5FWjIrVW5aL3FmZjhVbDlsVmVTRC9qZjJVcXVLZi92dXFOa0ErRElMZXdaeG40cmVMTDIvQnRweTcvSmFSNUlibWwyV0UwUUJlMXlSL1FiK0xqZWpTc2FUUld0RjB2M2MyZ0l6MXdCUHNRTnovUWg5K1l5YkJMTG5tVXo2ejNNemgzNU14OEdjVXExc1RzN0dZdmlrdlNibU0yeTBZNGJ1YmUyMU51S3h2Zk9hcnlrc2ZHU3g2OWEvWVM0Z2l5bTA3ZldIa2QyZ3F2OXk1RDY5YWxZYWVtZjZkc04rZGt5YWNPOXRSSDc2TndieE00OWpXVHZHa053Nlg3ZVV3UDF2ZFR5THNRenIzQnUrbmxIY0c4U3l3RWtZc2NoNEwwYzh0R0dBSlBnY2RwczdDQlRKd1NjUHFER2xXdE1aYTJYU1BmeUwyb2xrekNYZ1BuNEorakFCUjQ0eGI4WkdSWjRpb1FVY0taaVhKRHpiM0lIL0p2TXg4Vkxvd0taL0ZzeEx6Z3NWdng2SnRXRi9KMzAvT0R0RDk2anNVYlNremlucktSN3dLL1FrKzYrdTNHTnRLcjF1K1p6UmdoNi9tYytuV0VaSC9oVGczL3p4elNuY1NvL0VFdHhYSTZVYzAzSFlFOWFXUmdvUTdMdWRkdlNYWHg4UnA1SCtCU1d2TGJqejY5Q1Rpb1Q0Zm83NlQra2k4Q1E2VWtybGorNGRpNE1EMUVSdThjeGxhTm03QVVoS21mRGF6TTJmd2IwVWgxOGJCWTVjeS9Ja3VMZkZEWWVJOTlzSkVQSmluZDMwZTJrOXVaNU14YlROM0VrOU4xVjYrZWVmYzdaSThHdTZpRG1YQVF4aDNGdjJRSlBLK04rd3FuVWhOMlc3WGV6KzNwWWhtVmx0OVdFUEMxeGF3aG4wR296dURkVGRxcmVsK0JHdXhwaXJBYzRieit1dUZTOVFCMGt3M2o5Q21kQWtLK0tsTlFkTSsvc2g3ZllJWVhKOHE2OS8rSzdldFNzSHZZYkVlbTM5S0hTUmFISUU4MjNyNyt2OTl5Y0V2b0YvUWM5UkQvVjcwVzJTT3crdS9hY1d4c0FrR2RQYzI2T05PY210K2ZjUEduT3pmTmY0TndZRmdneWtxMmlXQ0Z0cmtrbVdmNS92UHJlZ1FNZnZQbXpoMzVIbmwxMC96MUxGZ0VZUU56MjhkL3BYZ3FpZkV5a0gyaXhHTnoxM3B2dnZMNTdOOGhWQ3NhN2x1VTdnVGI4R2pFS09UTDR0U0RuMStRMi9KcCtYK01mNDlkcVk4V2NYd3QwSlVweFNTbnBOVzMyaXlyNW9KSCtRcjhMRUJlUjZMN3Z5UXU1OTkrd1pEMjR2MGZvR0hIL0ZuTEovNUxlWXA0LzNGdnMvK1hlVTY1L28vY1VFZnlBMGZIZTNncGhuaEF2UjJzR2NJZGtaREVuSTRWcUxId2t0aGJWSEZXbGF0YThxSUpkNjR5V2JDcUYrR2F2TUs0WGpGZXd1d1VyK04yQ0xHMzJ5N3kxRWV1RTRxeFg4NVZtbHplVXhVOGZodmhwL1hJRlUrbGluK1p5OGd2Q1lqWHNtc0ZnK3RyZjFJR05tdlN0cS82VmpZQ0ZwdW5YQU0rWmUxcXN2bWJHOVRNZmhsaTRlVm9pTWUwNWRpSHc2NjF2cm1qS21oTm9rdXB2dVhuenJ1U3ZwczI2YjVjcVlYMjBPYnVSWXUza2psaTdqczl1TVA2dUpIVytHUkIweHFrNG5qTXNBaitZamY2Ymtkcyt3eUx0U01kNzJibGVGNjdCbkZUOW9pc0tzQmVmNndYUWdKWUlVUVFQNmdZWitSREFlaS9PK0VDZ2E1OVVzRFFIaHNndEM5UW1OQkRIMzArL3Q2N24vTXRYTjhsaWR2SXJlOU5EODVZMlBQd1RQU1I2aVlPVUZHWGRIbjFnN2UxYlZNd3VjamllK2Q5M2orYi94RjNRLyttOTF2NVQ3Nm9Xa1lleStGaittWThuQ3J3R2RHQnBkNHFQVWlEaTJsaHBCaS9LS2VETmUyQUpoVGhhY01tOFpDODdsTm9hd0J0d1djVjBpcmZDRWNxNGsrVmdwem1LMkZhdFRtSU4rT3V1bCtoWmRQTEJpazNyYXFYVHZ5YnVLZmQrcGhOYWlCbnBNOUlxNnFDbkxHOEd1TWI5aW1VeTQ1T3oyYzJDeHZrTjBDZFlWMWJNU0VNazJjZ0V3TEVhYS84b0p6aUNlbWVHWE9NRWgrWU0xbWVlNGRCbHdETWNYSUFONjhsM1RRZDJ2MFRIMGl0cGpyaWdoYmltTC8vU1ZFWlBJRS9UazViRHlKR1ptc3NBT2NRQi9mNzJBdXhabWMreE9ONGEyR0VNQUpTV3oySkFIc1lBRzhTQVBGYWdtb2N4SUorZHk4dkhHSkRIOThiOWVrZUp2SHdlQXdLSzVzSWplYXk1MGxHY2ZxU3RyMittcDZXdmZIL2tuc1kyWGo3WklNNi81ZWJFbTVuK2ZULzQ5L1puUGtqYk14L3lIei96a2NtYlhwVHk5NW44YVp2ajBDbHUrbWZBaW1HczBUNkNIYy9LWk1lOWdMaGtqcmprTkZlZW5lYktOWm5mbklnWDJsajh3ZnFqc3VaU0NsMWxzczA1T3FBNmttZHVjODZEOXdqN0JOWmVoTjFLMkxaREdBQ0RIR3RMUEtmWXVBdFR6ZWNIVUVON3RERElFdWFCdjhETHo1ZUdZYm5GM1JHQy9GYytudklJRnJOVzdyQWNDLzhMbmNQYW52UG9tRkdpbjdSbjA0L29GZlpsWnQwczVPeW1NbGlyVG1GWXhoa1BSNXN6SHVtTW5hM1ROcFFCSzArUzB5Yzk1STVPZW14b0ZQczAwbnNiZVg1KzZDTzZGSEp6SXN3NnZOODZ4cnhLNkNYTUV1TFYrT3d1TVN5eVZFTlJWbWVKN2FYeGJxUzhxTkh3UTYrMnhIQVU4REI2SEkyalRPLzJvYmh3QzgxY2pXcUc5VlhabmZXT2poZVZkR0dHNHEwR0xWZWk3U1FnOEJhVzhjaXJtWXZxVTVlQUl4MVpJaXE4eVVsTUNSa3NLdDhuOHJGTXNKeHZod3V6ZnYxazJZMkRLOGNlcytqQlZ6YlBIYjkyL1B6Tk94KzhvKy9ZeWtGVGwzeHlnTzcvOWJMMXcyMm5yYjMwTjdwZi9JYWNSSzRhdHFpZ0MvMk1VcnFQUG5NeStKOFRUaWJIa1FvaWtjSXVCWXVHMGJ2b2szUWxuVlFaN2RXZExCTDB1NWpOZndQL255LzA1L2dEZTZNZ2VjR3dpTW5Td3N4U3N5dEk1SURiVjNpYlZIYmJtQUFtRmJkbDU3SThVREhNU1lvSjdNWm1KU2FMVnJ4djJFT2t5UHEvRmZhdytZYk9YNytSa0VxSDdlRmxqYysrcDA0cE1qbjhqNytKcStTY0xiMGZJTGxrWnpLMEFQRGhPaktVTnRMUUoyVDQyYjdzWHZST1dDc2hXT043R0YrWmd4eTNyQ004N0dhRjA2ZTdUbGZLZFVLU0xqUFhpUmZrTU5mcFk1SEFoNjVUWmtmaFpIU2QrcUU5bDNGb0w4ZW5SeTFXOXNTUDFlakg5bEsxVHlGU3U1NHNwMWZzRUl2bzRTUzlkdjJmdDZxSmQxWFQ0TVZFb1Q4c3BpMjA0YlYzVElOYlQ1cXo0TGJyOWJGUE1SMW1zZXBxWSt3Ry9XS09zYXR3a1RGalM0QUFCRTVrMjJXRXE5azZYTlVsa1g5UGtxQWVpVm53eWs1TG9ydDhuUlZKczBpaEx4dlpkWG0xNU9FUDNxUFZqYVFMQ2M5ZVNmZEpxK2Z0M1R1UHZrbjNOSzZSVnJkK3E4ZXVIWWYzVzc0enJ4YUtoSnQxSko4cjhEUEdHZFU5YmdtOGFTNjdZU3pMMVpLUS9ibVFwNnNGTVUzV3kxZjU4YUVpSG9LTEdLSTF5bjNrYU54ZmdBTDVmWURIOFJpUnY0QVYvZjkvN2IxNWZGTlZHajk4ejcyNTJabzlUWlB1VGRPOTBMUkpGOXJLdmdqSUpvZ0lxTWdpTHFpZ0NJS0tpaHVJR3lDS0c1WU9Ga1p4U2RMZ2dqcWk0SW96THFOMVgyWjBIRkZSeDFGSHBUbTg1M25PdmRtYUl2cjd2Wi8zbjFjL2JkTTBKT2M4NTdublBzOXp2cy8zSzRUTk5teDFDaEY3eUpCQStwUXJsNU0ydFkxYUF0UTFtVmxJRnBMS1YwTmo1dDUrN0FlOVJlTDlzYWw2UXI2OTdjbE5iOVA5OUdFOWZSRGhQalZrbERqcnhycnlwS2JxMDhrNGp0RkdEUTc1ZkJhZmU0V3JsRG1qdUhpT01ibTZBaFVpcWFRQUp1cEFOV0EyRS9Xd3hjdHJMRjVzcDFWckxERFI0dmhFNGRqRldjem1WOVRLMVkwQnFsVUN5Um9IU1diaHRPT2RwTTFsZlJJUUx1Z3JWTUtwR1BHNGlmenVwTnNhRzY2WjEvRW5xNmlQL1dTNHQ2Tjk2Wnl6T3oranZWbjBTMDBsSGY3WnQ1Q01kSFJkOTBnb3g4ZXlFZkU3UER6RHZqaDVKR0lwRTdVNFNhY2c5YU1tUEt3RG56V1plRDFPM3hQV1dYbFJXUWUwWXNTRzkwdVRuVmU3c0Z1TytOais3RE1RYnlWMnpKMTRoM2hDbUg1NTgrWU45QXN5bll5WTNGTG9IZ0pZUFBHMjJObndKVlc4ZE1QYzB6cHdQRVoyN2N6QStySURkcWlrOFdCY3FqMlFQQ1pENWpGWjdmdzBFenYzY0N5UzAxdEhLbjFhSTluN0F0bTc0Nlh6Tmk1NXZwZm9hcHE5QnF4S2t2ZG9CWHlKODg2NjlveFphcjl3T2VKZDg5UVlJNkxMc2dZVFBRelJiQXRXS21HckJKQWVPanRIWXppNXN6c1Y0aStGdmN6a2hLQUNpQjZ6N0N3OVQxSTV4R1ZPV0k1QUt4anhpckNWTXI5K1F6aDhoemp0RWZyMTliZmVUTCtLa2x4NmpyaWFOQzNOTnpsS2s1c00xQysySFE2WVZqZjhkRFZXa3YvRjdPbGtlOUc4dEhtUURQTXc4SG53dU5scFM1OUhmdG84d2pudVZuVW1PZXBNbkFtN0EvcUZlQ1YyZDJPT091M3BGOGllcnBmT3UyWFIvaDM3bVM5OFJ6U3I5SVppOEUveU5EL1FWYi9FTThrVTd5bHMvQ3grbHE5azYxQXNsQXI3K1BpN3JUWjNjWmxiQWQrVlNISFdhb1VBMmNOaG94QXcyWGlUdndMczJqMTQvTUdOSE1ZbDJFSmtEM3R4cUdqUDdtZnZPUGdqZjlabUM5bjNRRU9BWlkvUVRTejJJdXhlano5Q2tGY3hoSVphVUNIMzJQRStIM0k3UWw2VVBUR1dBb3BCYllNc1lTK015a1pYTHNabE9udFl5Mk5nNXhDeGhRRC9UWkhvZHZxa09yRVdBQysrVWhZS1MwNERjVjVkZDlyNnBmUjh6Wm4wakF0dW0xdS8rcy9YbEk2WU55T3ZLL2VrMDRZV1g3V0pMR0gvUDNyWGRjZnF5Q2VyVjlNUzdaZzFIWFFjZWVLY1U4cGpNOFQ3S2s0K2g0N1cvRVRIRU01RHpOSmlEV0FiU2xqTU9VcTVubXdldHZwNnVKNjhCazREa0l1TnhCaFhlcUNnWGNyRzc0WHhhN055OHJEWW9MZUhkVVpsL0pJeWZpbkQ4RTJYdS8xakZwM0EwcmNlK3RqMFJjZlczN1pqdFhmUTFISEdUVm5qSnJkVVhQa1FLU0RGWkV6N3dvbjFlako5NFVLNlUrZWZ1SkN1SW1OT0dKMVB0ZVRYM0NHejZXTlNCOTFQbXRUcjhEcTIvbVZDcGZBOUgzL1VZczBwUWdkQVBnVVNESmRMQjZLYVhBRWFCMWg0cDBsd2daZnhDN0dNY3hzb0ltTUF3MVJTV1N0bmVZTktHdnJIbklQdmNVOWdubEd5aDcwNFZNajg0eEhWYTVobjJQYUVMTGFRbWZtSDJWWll3djFEZllUK1VZUmM0bklyOHJacVNwSHpMY2NScWtEZ2tLRVNhT1BVakRrWGhRZzgyRklTTVJnaDlRaVY0MHUxekxYMDhUUzBQMi94T1p0YnZIYUR1TGRMZklaZXlCem03QXR2blZkNzliWnJpa2N1UE5tend6Tjc3ckNTcXg2OHFybVp6aUcvTXE5WmpQZS85NWpYRkdySFhIODdlTTNwcDFYR1pvbzdLazgraTZXdjRjaWcyT25NZDBhUko5VzlRM3N0OHgydy9RcGw3N0RrRk1IZWdmVU1zRHljTS9qQThuZ2JyQWhBL0o2cmhXSnZmQTFzNmhxZzRhMjhidWt1ZzBaUVdZc1JjNDZkVFZvSVM3bXE4STIySExhWWRBdEkvUm1BNVFKbGRMZjBObjE4K2psai9MZHR2N0trZGRwWTQ2M0dzVk9ieXEvcXVyeXVqUGFRQjBnaEtVTHN5QXptZGZmcC9CTVcwc3ZJbUdtajhxbWUvSnczZUNaOWpJeTVzSklXTTk5N25mZ2hGaGhNWjJ0YzJpM0NjY0xUUXFSWk9YdGtZUnViK2poL2FIUXdmQXpiOVljRm9NeGxaS0ZwaFQvczFSNUEycUFKT1BOVzVtK3RpREVOQndFTURFaXpBZXpCaUVERU1nQ2J2QUZ4bUJjSVQyU3ZhSTJyVWxqc3c4d2F5ZTR1OEZiNzY1dUhqUjdIdWVyQkx3Yll3NzR5Y0oxanhyR3JkQVJLVWd1dEtNY1dDdUtoaDcrZXZVT0ZJK0l1R29CNnVnQURyMjl3YzJFdUc0RFVFaTJyelMwVmZ0SVU1Q3lFYmhjK2lmVkJwWWRWQmpaVGdGRTBLMy9XUWJscDhOLy84ZnpEZEJKdmF6MWoxNkpwZjNxODVZTDZGVE12bjNuNWtBYS9wN3IybkxvSG50emR0ZXM1ZXBCK2UrMlZKOHc0OWNJTFIyMGVQZW11RVFzWExueXcrNnFMVnhuMDExNUhKT3g3YlI2NWVISCtzR1hCdk5hckY1OWdPYzg0ZWJUNzBldlhkT2ZxM1E5ZS8vS3JCazN6NEtZR25iYWlzMEVqY3o0TUQxMGpMWkRMaFRIQ1UwS2tRUzFhNFpxTThvY0hNUitFMVdBL2ZQNXdrZllBa3RnZGk2dlJ4SExvSmh2UXlJVHJtRXNPRG5Eb1h6VjdYQktJbUtzUi9jY1dKRHlXdmFJSitwUWRUcmVIYzhZUE0wbFdWMjUrUmUyQWhyWVJvK0E1MlJGdUg4NE1YRzBQRjZIYTFhQlJiQTBHZzFaVGZFWHFjRVV3WmZRNUlxNzhhczdJRUhJcksxS21OQkhIWVlNdEZaVVpsa1Bud3I1aWk0aUxNWlN3djdFWUdOZkM4L2hEWk5UbU85Y0RzbkRzOWROYlYxdzhjOEZGNDlaT3YzSm9vTlpkTlhEQmdPVnJYL251cS9kbW5WMDNkc2EwaSs1YldaRTl0ZW5CeTJmZWNPZktKUmVMbXNkUG5YSGRqaTFlMzFWTjF2UG41QVd1V1RUVmNxNXg0akg1MTU0WkdhUWJ2Vy85TmtuTXFhNnByOWJJRmVzY2JvMjhsTm4vYkhZLzNvYzhVNU9GaUNmZXE2Wm5FVVUwVCt1QnlNd1lET2RsSFVCQVlGRnlJd3k3TDdPMEIyL05oZ0RjbmVFNDE4NEpwZUthZSswRWkyNmMrZ1k2dHZCaXJ5Tm4zL2ZpMy9LNkN2NzYwdjNYOTk0M29HdkEvVDlmTHoxQzNxVDFqKzZWeHZjK3NnY2UxMjM5N2lJNm1ZU1hmOGRqK1E3cWswK1JQMlVSM05sOHJDRlhFTmpwMmNkSHRJajIxT3BVdUlZMUdITDcxZmhOcVVPdy9Rb2dxamsyYUVTRDJ3VkVRWkNWWVRTWHcrc3JEanNDSzRDQ1B1U0lOelc1MlhkVXdxc01RdCtGekdaUkpuUjBQaHpwZVBTNXZMTE9JZlFyK25QSFlZRlMwU05hWTEvLzVlOW0rYnhmTjFrL2VmN0N6N2JSbjcrbVA5QzNyYlNSdktMbjV3WlNVdStvZzBWeTA5TzdSOTNzRHVnMEdTQ0pkSnJpWng1UTJuQUdsRjVTdGlWajNUMC90WjNVYVVxR3ZTWGFTZlBnaU5kWmpvZlcyajROcFdIVDl4OS85SjJwZDV5MHkzYnczWGQvNk5OWFdrUmo5Q2RpSUpyMS8rdjlWZFh2UUl3ZVJOVFQwMUY2ZUlwb05xU2htczM4MUpCajlyRDd4Y0tObndUYkE5eEVSdGdlejVPVUNhUUM5d3gzYmJtend4aTdUTHpDZXZmbTIrOUl3KzlkRUgycysvSHJ0dTM0czFvdktaWTNDeTdJQWx5OGx5bVNKZkxxc3kwQjJzTHdZZExCRG16RnpxNnpoSng3d2xyckx5SGRIaUdpMVRreFRtQS9zeE1NU0RZWGlCWm9lRHBneG9vS3lYRTN0N0Q0TUg3NUU5L0Q1Tmd4cGNXanRyUWR2K2pFNmduTkE5dU9HMFNmZlZwZTEzdkJNK3V1ZjVmODlQaW1vYzYxemdXaFhsbFE2enVhQWsyRGtBT0tOOEJwRmpFUlBsaEV0S3U5bm5hbzI4c2FwWkRqY0FlYjgwblM1MHErKzk2YjY5QzdKNTlTTnZxa3FiV0ZCZVVEQnhWODk0bW1NdllRN1oxN0FUUFhnT1VYQlkyWDZLZk83UDJmcWwwdkYrdmFtSjJLdVNKNVJsdlZjTTRhcnNNSnJRV2xYSlBwOTFvdjdJVldDMWNoS3JwRU5Qa0ZXSXc3T29zbVNBVEw0NDh5VzVudTJwVi9XdjBwTGZlUmxpZzhDTzdNWkhkZFJYYjdmU004TmM4T3daL1ZlMVY3YUFvVUh2a2FZRWJzdXhhMS9wQ25KNXpyUUpvMktINzRGTXJ5WEErSExKU3k5S29JYng0c1Vpb3N3TFBkMzF5NFROUEx1SmowcWZUWlpWNWUrYU5NODF0SmZZYVRsRjcyT3RoZjQvdFJIVXhVYldtUGVHREdKVUdRUktpSnMrcW1kN2pYcDI1Sk5lV2NqZDBBZWdnc01XRjVpR0RTT2dxVVhwck1QZS9sR2NyYnpVUEpTclp2K1VnZWFhZDc2Yi9vSi9UNWg5LzUrOTk3M25yOXpmYzBFM2QrTThHcHo1cnk0VTdhT3ZLUnE4ZVBiUjQyKy96U1k5aFdOcHRjaWx2WlRucEp2RVcraXBTU0VsSkIzeDhhdStlbCtiWC9GWmNjR2hPK3c3WTZhOEdKbTVIRDNxZHZVekRJZGREakhOL2YwQjY1WUFadk1DSG53NExGMm9ROTBwREo5YWxiWEcwRnMwY1YycU82RlhISzNWcWhzRWcxUjJhb01zbFk3czhNWUphR1pxejc5eWZNTkxvdndGVGhON2hlL29kTTJRNWZKY3dUUWxaL05BOXBXVm1HR1pYTmdna0lXcXM1SXRtQmhmWmlwZGV2QnRpclFQQlkwcG50Nk9aNWJORzd6U3dHNW1LRDNVSzJzWmlIWGV3MXBSWHExTXNoTXRXQU44aHdxRjBtT0xNZFBIeHFkalExaXBYd3BGWmN5WlpPbjcxaVdRNmJUaGw5bng3T1hib2ltODNwdllmM1BXb2YwN1NvNk5GOSt4NHRXblFlKzhrV3Y0cXNyRDNyckZwNk9mMkl2ZmJ5MmtXTHFzaGxwUFlnZmFleXJueGFKYWs2ZUpCVWxFK2ZWazQvUU96NWJacjdOZXZaVlRBUTV1endBL2JGQWhKTi9xZ1dINkhVaTlKMHhuWTlueUk1REZJdlBnL3FlbHRkT09jaUIvdk42dUxTZTFYMmJwTkg4Q202ZEpLaHZKYlB1ZEhSd3ZVbWN4eXViRkdIcHphVkZTTEFhWEhlRU9WejRVbjJmY203TCt1T0dkUTh4TER2L1hlZk53eHBIdFN1Zis2ajdSZGZrOVhXdU1COTVZcGVjM3REWTF2V05SZUxybjhTdDYrNXVxYWxuUDdydlgvU2Y1YzFEcWhwOXBIQ2p4OTRwYWphTzdib2xmdko5R09xaTR0cmkvYnpXRVEzV3RjcitJWFJ3Z2xrbmhBWkNIdDlKVDluY1NubkxGNSt6cElmQ0EzM2g0WUZ3NDA2a09ic2JtMGNycThORFdLNWs0NzUrV0RBYWs1UDNoS1k2MGRIYzZENmFGdDRIUHR0R3Y0V0dUY05Bclp4WXd5MTNjSzRTU3h2bXNZclBXWE1mMDdrZDVEdkxuN21BTjVCaHRXRkJySDdoQzNjcFBzbE5NZ1dIcXo3WmZmWHEvYWEyQit6V0E3UTNkdzB5Rm5iM1FMZjJhdTZod3diekg0ZEN0OGo3RThKanBSUVMydUVQUTJQaHJRSzNTeUhHb29aLzZOTnpTMkRCZzhaT3F5dUxzRnBHSzQzb2NLV0ZlV1ZSMk1EeXppV1JOUTB5aUE5NFpuR3RqRlhzYmV5RFJmYk9wQmQwelhxd1JHcWpPTEJVVEhiNzQreFI4Wk1tZ2JKd25CSGFFcW1nNlJtakc0eW5TUGhNUkluNml3UzI0bExZZlV0Sk00bVlQRVVteG9STjdEeTF3OXZYVGF5Wm5iN3pWdGYyVFY5ZTN2ejlsbVB2TEwxNXJhVGEwWXR2L1hEWCtpQlE2ZDNqUi83cDBXOTlDdXhmc201Zzg1ZHVucUN5WDc4dWd2bjE5UzFuYlNzeUZjMHMzbTQrRzl5SEZrMDVhYWlHdnBQdUp6b1g0WU5iaGxEUnBFeU9JQ3FLYnBwQ2g1QWJhYUxLL3dEcXNsNitkYjhCWXQ4dGI1bHZwclNRSU9Odmp5NnF0SHBzT1htSHp1aVpRdVBFZVVlN1d2c2ZqbFVtRVRPNWRvOG9iSWdOT3F4T0paajFJdVlYeGtocit2T3E1TDBTRDUwakQvVUhnejdtWVBWQjdvYi9jZXdaNFBCY0F0enNOcEI0R0NUazdWTldiUVJIY29kYktndFBKTDlOcEU3Mk1pSjRHQWpoNEdEalJ6TEhHd2lQMkR4c290MWl1SmdOYy9FME1IYTYwTEJ1bEE3YzFmbVlFRmJlQkE0MlB5OTJlaGc5YmJ1aHZvZzg2Z0FmR2V2Nm01dEIzOXJnKzhSOXFja0J3dTBSdGpUOElodDlOME5nZFkyN21EMURZSGdvTmEyOWhRSEcxb0wyNFdseWdET010SWUwZm0xNENRVEhSRmJCUnpLaFZ6MmJtZFJXUk02bUtYS2ppV0RQT1pnSmhzZURyUGJLOFRLK2FnZkhCazJkaUw4bTJNY29mRUpQUUlPRkxKNUErQmcyTXV1SUZhNXIxVnlCWnMwNzBwM3JpVXY3anBtYVdYTGlhUFBQNXRVclRqbm1IT0drN0pGaTBlZk9LaHk2ZUJkTDM3My92clpNNjkvNzNzeWUvRzVnODY3NFBJSkZ0dngxMTg0citiTUdSY1crZ3JCcmN6c2psVlM0bGtUZU8xVmV2YWs2bkp5MjZ1dkJkWjRTdWpIOUw4c3JmaDA2RkNTcC9tb2FPNDVaVFhNbDZwOTgrMTAvNWpLWnFmZDVnRlh1bHZnUGRDNjBkcS9DUUZobUhDZkVLa0hUNnJtTzVSYjJhRjhmSWNxRElTRytFT3RiSWVTRDRRYWJlRmg1Z1BobG5id20rSHBzWXJMRXRmQXFHRGJ6Z2dsYk5rbHlmWEJ4aUVjcU5nOVlHRGJZSGlZNTRoNmZkVk5yZnh5cjJlck1VQzUzSjBsRmVybDdtMXREVGNPWWFzU2JHN05mS0gvMXBFeGxNWjB2a29mLzVyOXk4Y2JMaDVWTzZ2OXBxMzdIeDk2V1VQWC9Cc2YrUnU3cm1jTkdMVnkwNGYvbzE4ZE9uL0hPTU9FSGVld0M1dDhLcFZPTEc2STFwZjRIeDFZd2kvbStIa3l1NWpMeS9tQjhqQjJTMHcrVUw2TkxxbnoxdzhrdDhpTmVYazdGckQvbEhPa2IrU1ZRZ0c3ZWs5V292LzgvazZXb1RMSXJGOGtZejIyaGhuY1d3NEdyNDJmTnc5UXo1dkRlbUQ5S3FvQ0lmYVNJNTg3cytCWFNqSEdqbThxcXZSWnBidlNENkVydWw2VnBkSXBoZldQK292cUgya29oQVBwYzdhWFRpYVhaanFRUHBsMnlxZm01Mi9IaVdLT3hXSmZ6Vk55Qjd2bnoxSXdmTURiWUhVaHN0QnVxSTNUQ0lXYy9qUk9KNGp3SEJhRjA4bHBkMFFNVmk1ZFkwQldKOTJSNklXZ0VsSWlyTHlmREhuajgzdEhiYi8zRzNxQWlMK2UwOUxscEUvVCs4UVgzaVVUa0Yvb1pmb2QvWlIrbUJOYlMxNUd2bWpRZ2I2V3hhWWVPQUhLVWZ1cmNxd3czaHduRzY4VlFlMVdoNkUyanFCVWUrYVVYVk9GRzRIclp5TWt3bUJORzNlYTVqTkhISEoyRnlqaGlFdUkvb2NKVyt2ODYwNS9ZUHYyN1kwVFd6cmRQL1hHMjdBQ0wvVDBQR3ZQalYzSnhweURPTWxlelRUTnh5eVd0SFBFY1Z4Y0FVU01aR2M1KzNKTHNxNGN2eXFkWnd3am5oZm9GOE9KcDN0cE44a2RRUTg4UjF4RDZSZmhaU0V4WjhrMk1yUHpnbTBrT0p5KzNMbWtrOTYzYlhFbmZXVTRHY1RYOHpuTmVkSjZlUzM3ckdvaFpFR0svNGdGb1NvV1dFMEp1c01GU1dkSUdRTmd5RlhPUDUrWDg4eFZONUtvWEZQWE1LQzJrWTdYVnZrYnFqUnZCS3NHMXZrRHpaVURBQmxJaFA5b25wYWVrdTlubjFXRG42WFZIZWdtV291K2xoa1JLSzhVaHJlb2tjdHZxeHk5dkFpYlUwaDhVQ3UwaUw3L1pDM2JzR0hTT1V0V25sRTlmL2wxVXpWN2w3Y09PbWR1a1gyK3I4WUhXZ0d2YXlMaW8xcFpzQWdOUXNqc0J6aGtra0FDZi9lSUVSQUlnbEZtdDd4aFJxQXd0K0hISWJqUWxRMEZSNVpXa3RlSE44OWtPL1BTeitVYm1rZU95L2RZSGM2bWlyRkQwSGJrNyt4ekhsYy9SL0JIalluUGtYcEF2eEUrUjhLMkYwbUFXNnVrVDN4T3lsMkQvSDBwMy84MWtiRVZUVTZIMVpNL2JtVHozWUplcUtMN2RkZklDN0VYdVZwb0VVWUpVNFhUaEhQSkhDSFU2QThQWkxzSXU4WW1zNnlhUFJvYkNCbjlvYk9Ec0lpaCtZR0lFZGZST0pldG82QmRHQWdFV09ZVk9pVVlMbVovUGhGaTAzQWJXKzNoYmZDcTRZUFlYWDh3VzRMejBFaG1ycUZnNXFqQmdrQTBuejlSaldUWnVyamtnNktIRXZJRm90bjhpZElBWkRjc3F3a05Da1JiK0hPakFxRVdXN2lCUFRja0VLM256dzBPc0dBaFBKbzlOeTBRbmNxZk95MFFtbW9MejJYdmZpNS80bHhiZUFKN3hheEE5RGoreE14QTZEaGIrQXoyaW9WYzEyRXhjRFJBRzdWUmdyTVRIWXNTN0o1aXVNZUVHMXJZMHdQYjJOUG56bVZQVHo3eGxMSHc5SEVUMk5QenowYXNJQXRFdTdNdG80K0Q1eXNrOWt0QjZiU1pQTm5nbVlhUEl5NVNmNU5TZmlPcGYydnUvMCtwYjVuOHdpcDUzdnhaaTdVVDVmWVJ4elhJOCtWNUMyWXUwVTZTMitDMzhTbS9rVS9sdWZEclJMbHQ1SVI2ZVZ6VzA3UE8weW0va0FQd1VuaWJ0aEVUR2pUalUzNWJuTFZuNWhLWi95S1RwMDVhTUgvbWdKcUtlcHAvMHVuelo4RWo2Uzh6RnM2ZlZWdFQ0VC9VZE9MQytUTnJhcXNHeWg4L09ZODlWVmwzcUs3dnkyamxrd3RPcXEydDlBdm9wOWZyUnNyYmtXTVk4TFhsTENkc0ZvWUlDNFJRaXovY2FrSktkcm1reHg0YXpQd1R5clJEL2FHaW5sQk9JRndHYkpod0hKRUhDbmFCOERBNGlRVXNURG1rditGQ0lDSE5nODU0SWR3aUl3Y2UyMi9Ed2pIczZWWkhhQkNpZm5MY0xoWTVPSnRiM0RwbTJoYTJCMWRXa09hV29CdU95Z0J0cWRYNVpKWTl0cmpaT3JTNGl3Z0VHczZtRmlnU1ZWVDFyRElQMjczMGdRdm5pTGZkYXh1K1l0d2MyeFR5YXRDK3htZ2I1VHZWY1d6UnFRSEh0ZVFoY2ZoancwZnVYTll5eDE1K2ttdDQwV1gzV0VZOU83UkhMRHVWdnpMMjh0a256ckdkT0ZpV1IrMDViWTY0NXRlSGUxWlpoajArUVg1cjlMTkQzN3BzaGExaXVtZkUyU2YydmoySGpIeXFiVlREVStTMWE3UGd6WU5jei9BbStUMGQ5SzZYZ25JWElnY3RjVjI0VUlrL25LczdFTWt0Z1dzMXQxRGhIUEFsZ3oxZC9JUVJhdlZRSmk1a0R3dnhsQmRnMXREeFhxYmlQblVRcXdIa1B3ZE91ME1GOWxCSmE2Z1FJRG5RQ3FCSFdUbUx3eGxIZzNacmpWa09UbG9MQlg0ckVrOEdKWjh6RStIbzNydU5razRxaUhSZi8vVG11eHo2M244VTNtYWNkZmJDMHd4M1pJVkN1N2JKNjNxL1hQcmlGRTNuSVVQc0VMbEFNdC8vN2FGWnV2SXpKOHlhZGVmTjZ4U01LOTJvK1VyK2lOMzlpb1hOaWkxTUNmNkZRbjg0aDlraUIrSEJPWGtBQnd1b2JDN0F2K0JBL2dXblZTVmlRLzZGUEwyWlBabkxuc3oxZzZOaEJWWUN6RE9tblU1N3lBN2dSaUJkTldQNm11ZUlaTm55RlJGRWsyb0pXVyt3SlN5aFM3SkRIMElHb3pqc3haMnJkcXk4VFIvYk0yR3pic2I1QytZYTdqQTlHRUVRNldWWFh5MnQ2MTBBVFpYaURYZWMzcnRjL21qKzFCbW5Bb3BVRk9vVS9tekEwSjJYd1A5aDVCNDE1Tm9VZGJvb0VlQWhnZ0dsQXlyaysyaVJnQzRGQ2RnZmZnNlJnTlhFN3NSVXFKYlUzZHBGSnREb2JyR1Yva0Ivb1pkMDlaQWwzWHRmMDR6YUdJMXVCQmpnL2pjQUJraHNWMXdxY095S3BsYitsK0RnR0Vic20zSWFPSWJSbUFIK25RL2hMNHpjcVNML25FamM3NFNSMjUxSTV3OGpkM0lNbzltbVloaWRhbE52QXZtWDNrQUtRTzhpK2svUy9NN3I3NzVONndINmwzUEZuZlFEelNXckRoNWNGZnZ4dHRzNnVqU1g5SnA0SHlublNKdUJuSGNGY2R3UW52UVZaQjJJV215SUdMSkFhMEJodkx2R2hneENVSk1CVXZBaTVQaUZteEx3Qk1rQTQyTkphWncreW1ZUDY3UFl6NElFT1RoUXV1bllwcVd0SmNEcTJWTFo0bGFaUFZjUkl6RXZPV3ZaM0EzenI0NTBuakQrckxQV1h2TGt2bWZsZGEvOTlaSzlnMjQvZm5jZThId2FyNXQ4LytnSGdlc3p3WkhnWVJIRDVZcnRDMUphSkNzVWpvUWFYcDJ6UVJ1OHlwR2cxT21nSjdJVzVnRWNDVkkyQWpSOElOdG9OWEhsU2FVWHpSN1hseS9nRVB4UUJkQW5aTHY2MGlmZ0JGTW9GTlI1Y2hvRmozN0l2V2U5K1hsa3lkekxSMDlUcUJUcUtwZWRzV3JleHR2VDZCUWV1M0h6cFB2Y0U2YXM5M0pHQmRNZGs3b1cvT2YxL2J1ZVUzakJEMmdmWXZlaWx1VFYwd0oyVTZ2aVR0TzRYRVZZT2xzeS93Ujg3Uld2MnhLN1hGNUh5dWhZSUVsWGVKbmtVNVBmR3drdDlCbmYyM2FFOTk1SlB1NEVsaWJTUWlmMG5nanZYUWZqUnA2MUU1U2VIa2taZDFRZ0p1VlNGMHh3aG9zME9DYThZTEt3bnlPU1pWSjVuTmgzRnRWR1RLaUVhaElVSlZTOFF1TDA1ajU3M2ExU1JleHljaGM5dlV0Y3ZrRzhhaE8xYjRpdEU1ZHpUbGFwR3Z0UjQrTWdYTnVjYlRrNERnTy9kblVwNDdEOW9YSFk3eFF2b3o0eW1ZWTdTYytsNUsyMXRQdFNXa042a0h2U3FubUUyUU1WZmxPNDdhRnZ3TW5NNHRGeHFuNVRYTmhYRlhJU1ZDR251SG9UYjNaQzlhYUl6bXpEdXhzY05IRGFWOWorUGV5Q2RTVVVmcHVESllKU2JtaktVUXRDOXIxU2ZXelpqT1drbVJ4SHZ6dzA1ZUpSSzY0aFMzLytkaTdiTURiUkxDTjlsTDVHLzBZZmR1WGY0aWZmSHV6TmlxMVgrZ0p5cGZlWlRmT0ZTOU02QTdFSGdtMHNPZy9PUldkTXpNWFczMXdzZkM3NWNiNW9GekRTT2RKazAyRm15cHhDT3J1NjE4Um5GcWUxNWZSMDlwM2l0VFIvY2h2UkNZYy9mT25HZVV0V3JMNzZ3ZENJc1pyS2RmUVpFejFJL3duMXA3WU5nL2U5OXM3TE5ocFV1UERwVFZxMkY3R1lUK1c2dGpwU3VmQnovQ0Vuc2w0NWJHcmprVW9BaXFTQW9EYWlOMmJCL21MbU95V3dWT3pTNkxKTTl1dytWUGxCQkluMnBjc25yenkwWlhZbXd2emR3QndhSjgzbi9GeDBvL3dkOW9HbGpwbGtHTFAxLytxWTA1aTlUbjlpeTJ6TzdWV1d6TzFGejhDNG9DRDJHWHp4bUdnc25heHcvUThTTm5HMi8yaURSaWhoR2FaSytCOXE5b2RydGFtOC82MytVRjFQT0doRm5FOWRFQnlwRG5RUGdsd2NLMWtRSU53R1dLMDY1bEY1VGp4NWE3WkRkQjJxdEVlcVFaUzlOWnpWQVBXT01xNzF5clVCSEw5Zkc4REpYYTR5eUZ2NEtuOUxLK0QyNHNheWhqVXI3cGgvMnRENkkrb0cwUGVOL2dFTHJycndpcGtMYkdpekVYU3l3b2tXRUc3bHJHalJXbTR6bFJndFZPOFBsMnRUK2RHQy9sQlZUM2dnczlsQURtRHJqeW9OV3JYTjBKVU4zR2hDdUJ6cW5BSEFuVVY4VlFQQllJWmFNRmdSVnlQZ0JHb09oVUROZnJRRWF1bm02cDlRN2Z3a1EvVkRycFptSW9WVFdjSllaMHFTcXJQSzgyK0xCemdpQmpoS2R4STJEQm10UUo0RWFHQThuWlhWRUZuUzZjM3hFRG5oL2pvZzlyMXFiK3g1OHNXT0xmTmp2MnlTMThXR2kwL0hibzh0eFNzMGRIWHNUWVZqcGdBNUhLZWtxa3pqZUt4Y0xJYWpLaTBKTW1jYmJvcS9henh4enJJTEg3anorQVJyR1QwZGlHY1N2SG9RQys1bDluR29DT0s0ZllBKzNKbEc1MnJGdG9lb2hVZFMyZ0JuNitCZGdEWVYwZGxpRDdyaVpIOWdscFVyeWMzUHhaNFhKejlMWjY1Y0NScXdhOGpVVjhoanNkdDdQeExIMDNmSUJXZHkyN0N4NUNPZWZVeGFWcVJQcUFyRVlldWM1aUpxNWNVMHJURVE0UHFzZkRTTzFORVFGeHVPeTJldlpHWlplam5SaHVrNDh1RlQ5S05WUzhFd3k4andGMGdPRFo1QnpTVHdOaG0valBPNjFTbTJjVUlmT3Vwem1ZUDhlTUVZWkpHQ0l5MDVRWVV1aUJUc2FuS2l5SFRwVW1TNitDZ0YyR0lOSmk1MndHUDdJQnNmdDVzTzQ1ZXVuaDV4TmRydFJVbzJkV21PMi9qZ2d4dnB4ZUp6YUxmUWxiRTNOTWNKU2grcWRJamxJcm1nWE83aGZhZ1JHOEpSMHRPUVBNQ2x3QmpkYWhyaXh1dmREV1AwdU9HaFIxRDc1MjJlZU10c0l2dGcyWEhMRUpJWXAvUDJEbkkrdlZtUzlQYm1Dbkw2TTNRcWVma1pldDNLRHQ1cUd2djVwR2IzV0Q5WlNkdGo5NUFmejZBWFFLOHB5K3dFUVo2SnNlQndIb01sNlc4QXo3VVNlQ2tFemVsQkZvc1NJV29IMUwzUzNwVVlrSTE4TFY0SlpwdXlOOVo3VzVmbXAwMmdPY3h0eHE1QnpVK0N3Z1dtZVFwNWZvWXIyaHlKVGxkbzRpSXNiRUUxRG9YY3g2aVMrOENOa24xK1ZzYlBCMTR3OGozNWE1aGRkOTg5U1hNN3BJNjFlTjNGWWgvQU5TZDFxSHZTcmJnbm5aQjJ6UUdIbmlYQlVaMitQWm5pMmhUSTlKNFYzNnlVN0V1blQybHZobjFBRmEzWXNpVXVXOEhKeGxHNmd2ZHp2c0hzWUFVZlQ5bVBrc1ppak5mTWpSRDgyK0xFc3FuRFFnSXNrLzdvUm9XVWZ4czdONnFrZjd4WW9CRC9jWTJSSWVnZmt4S01NYkxTRXdDcW5aSkprRlU3V2VKQUd4RVJoVmw4UUhyTGdZZ2VIVWV2aTBmbmZCdzhOa2ZiSENBSDZlNGRNVGMzenFaRFJrWFVnL010M29wNVF2SVlGSFM4M3BBWWd6RXhCbHY2R0d5L09RYXdCUG1KN296ekg2N3RuWnV3QTdYcVBrWk1yc0lJRk1wVjlEb0syTGFUNWNkV1BKdU5BOUROekM0dUdkZk1KWEY4TkVmcEZscXdXQVluUExuY1NybjgxRlB2NEwzK2psem16M0tXR1NOc0Y2eWFYdGxCay9LRVJKcWcxWEhyU2Y4WnNaSlVrMlBwd1Y4M3I3anlFckw0NDM5VVgrTHVpckVyTzdiTVJDUDBEWll0aE9vaFZmZ3lwcFZqR3pVL29SWVg1Z3ZhWmN5MkJjQ3pnL1B5S0gxZytVWStMNVl5eUM2dWNKV29SUlRZVVBBV2p0ZzhmQ0llWlNJV1hwWndlSkltWWxOME4xbXFZQUgyVVp3VTFDdWsrTlRVdzI4SVZKUU1pQk16bmpCdTJMZDAvKzdMVHozcnJBT2RPNGFQMlJaaklUVnRzdEJQNkxjc1FmK01KUXBrMHpzdlo5TVdUdDJJR0ttSDVhaThsZTB0amNLOW5Ca21iRFlCK2l0VUNNdFRLaVdwenJvQ3BWRG5jc0hjbW5oalBRdFdqWHcyMWV4aHRRMXhSQjYyUXMzNGxOMFIxVXRtSzU0disrMVJyZXpLUjJnSlM0RUtTMkc2RmFWMkI1WTY3YUV5RnJnN3d2bFErZ3ZZbzBiQjRSa0Fad0I2Ri9KcXdYbGVpblp0Q1c5aHJoQ2JHZ0YxQitnamxXS3hFcG93Q1VLUWVNaTdrZ3dsRFpmTUhEaDFCaDMrdjgrYUJreWI5Y3g5b1NldVhUSnN4b1QyNXBrUHJKOS9BMzJUN2hTL21uWDgvTVVMWnMxZUlENUN6aUdYbGQ2UUh3dlJBL1J0NHdMaXZPc2dFU245SVVUZm5GYm8ydVNaNnlPclNNWGFuNllOLzkrdER6eTNWK0g5ZkVuekVJdHRhNFFtcUJlaitwY0ZvUDlneUtJa1dwV1EzaGJTb2xvZHV5QnpncFZnMUJ5QVlEYkhDZjZ6K05sc3JRVnZnN1Y0VWdQWFFiZ0ZublVpOFlyV1lxOEVZemJZSXprRjJOaVQ2MURRLzBXVnZGWnZzWWNLV2tOQlIxVEljdWJXcWVUZkNRWVdQQSt0YUZMWk81SXRXRnBIeWhVVEFtRDV1dzltamk5cm5MajV4cTZPc2tiNTJtMGIxOTkrNXV6QThHSDFGZE52dnV5VWl6YTh2MXc4Yy9pUUVWT3VHak5XTkpBc1VwbHpyWFAvSnkrK1lwRFd2L2ZuSng1OVlPWCtJYm5tYTh6aks2NzkzOHJaZHpmVzNySG9zNVhnZnl5SDRobzRGY0lhenJZWkxlYjVRUHpVdXN3UExUeGhSeloyOWRxaHNGQ1pmSWdOcFhVdml6aXJnSHNDUUUvdW9tTDBNcSs5MjJETjFpRGlJYmVNNDAreTdSRjNnUmN5QWJ1REorVUdlMXhKeDNFa0pSMlNGdlgzcDZ4RFhra0sralBMN01UbXBNYjh6SGRZWHNRNVJ5dEFGVHpaRGlyeHFHS0grT1F0dnpsNW96VmI2bWZ5eG1JVUVISzA5ajBwVDZNclRaOTJSdnBTMHBJODV3eGNwckduazJmTVlpbDZFMm9NWlFuRGhGUjVJWk0vWk9UeVFrYmtNVFZDaVZtMmhmVlpTTDBRMGVtUjhVNktDd1J5ZGxOK2o3WnBxdW1RZSs3WnppS29UWWM2SUdaUVl5ZTZVVnFPZmJ6akJZVVlFVnRMSXdKQkRnZzlCQW5LUjl1U1A3cGJMeHYxUi9ISlZkSWsrbWNXRzdEb2FXM3YxeEFYc01DSjQ5OGhadFFETzRrT2FreW9jeVN4NU1DQStuK0FyNFdVQ1k1SlF5SmJLNEUvQUdRSjFpdDg5aWhaUVM3dXBoVTdJQTBSbit1OU8vYWVXQVR2VFgzU3AzaXZyMCt3ZDVqODhURFV4am00czB3S1JKdUhvRWc3eDFFcnpTMU8vSUFkLzVyaTFKV00rdWNPT3FjVFFOZnZuSHB0U0p4NjZDMWFTZDVObW9OTk9JWEhuZW9jb21aTGxtQkdubFoyRzBkMUpEdEVvQ0ZyQUlYbzVFREVpSEdFa1psWGpVZmhYQjlWUkxQVUNWdFNKdXhTWW93bWI1TTZjVkpLUDlwQlB5QmxxZ0ZhTjlFZFpPWW1wWGFrMnNFSlRIMktKakZBMm9GZlN6V0wxWS9KanJVbjVPUUtrTVpBeElLSUU0c0pFQ2NXRlN5RHhUeUxOV0V5UjErVHhVZVlNTnhjWXFRL2RMSjl3SlJrd0hkWDBhM2t0RldveGNUOFBZVHhjMXNpVDR4ck1kblV1SjFuOFZrUXkyaGJXMVY5U3IzQkVpOWdHZUxwY3JwRzA4VmJ0c3hPVTJtNkg2UG1KVXE5czRMbDhXNk1tNVBIUVA3UHhwREtVMXU2b1hOa0tsTXRYUVRKTzdMVkt0ZTlkaG5hNFhSRiswdVdzQUhLSXNjWFF4RnhqTzhJTnRTUFI4RXhTNXprV0htOXNqbG9PZTB2VUxTWUZBWWxlN0tjdEJMRWU5a0dZYUdONHJ0ZFhWc092Y1UzQ1ZYSkNEWUszQ2ZrYzVIZmRaNDZQbVBhK0NCRGxWaUdhdURGZG1WMHR0OGFIY3MwVEFhdC9raURxNUthNlovRXBzN05uYjIzU0Z2WVB2S055dklxYlFITks1YURRWDdoRm80VFZMa3JvSzdYSm5TTGxOWTJlMXpxQ3BVaXNzQ2pPY2pMTGlHL25CRFd1bElheEJSb0g5L0xVcFN2N3I2N3IvYVZrbzRwK2xlYm1WL2R3L3dxQi9xb0ZDcGdRQ2JKd09PRmhzaTJ3UGJxVG01bXM4VVpnYnN0V1RZOUwrVENZWjBOUmdnQ0xuSTJDblNsY2dNbkRWRGhCOTdRdVNHZElaZ3pGU3Nzd1FtdHNCeGdPYkxHdGNKTXdhaExheVg4NkFSeUQwY2c0c0x6SWxjMnNHaTcxSTY4K01pNWNiT3hEUy9xNUFVbFBSWjJvTWlVRmNEZWJleG5RdXZhRXRabDN4VnFZMHhEU3JxNnJycDE1WlgzN05qeHA4dFcwcEhjdEV1WGtxazBhbTRUSC85MXVUaG1xSjIrUzByeG10a3NDRktNMmRldHFuRnpJMmV4OGNzV0dMK2UwMmJiMmZqUjNDNEEwY2s0ZmxrTDQvY2tXeDU2MStTQUtxU2pVeXZwd0NnTGE0RHFWcklMWXlObC9PN2s0YU5rSFRQK3N4ZWV1N3F6ODlJTExuVGQxYzF0SDlXU012cTUrMFJPMFh4UzduOCs3VXJSTFVXKzZHU2wxcWhzU2NnQnA5ZnRqQXFUZHpZZUZDRTFGaHNYM0Nza0pUVnZUbVlQZzZMZHozOTU2WjE3TDExMzVxNzE3RWJ4eUt6ZE8yUDd4WkpsRjNqclkrTlY3bnV2eWxzdHFOcjFRUEtyNWVQUUpuaXJFOVMwcWp4OU5zcE1ZeTdDMWpkNUhBa2FNeHpIenM2VG80dnZlV3piR3lkdVhzclNyOEtSeDJ6YlNDOGdxNS93ajZYdEVPdTFIejZvdGJLY3EwU29GRzRXT0lrTkVIWWc0TWJORWk0VHhFTkFJcUFyeWpleDliVUZ3enFXazNualBleXk5UURzSzBYOEdySURmV2tBZ09GQUtRZWRXMVlINzJxWEJieTFRcE92cE9yWGx0b2pwbXdFVVZnZFliY0hxK1E2cUltTFhLT3dKY2p5Z25iU3duV3NYTjQ4enUvQ0xya1NRU3F0S1BmYW1MbkY5cndibmVkNjVRSXlrbGhKQ1NrKzFHdW0zODdiZDkzaW5zdm9xL1FoNTNXYnlXdlN0SDJ2N0Q4Z25YTnNZMzM3Z2hyaUpZUHBCbnJueU1NQy9WOVJ6ZWFLUWpLVGpMaWdpSWovcFRHTWdSc09IOVE4cG1rVmlsa01mSU5xRitNQjdGSUxseGxTekdHQTB4TTFGRTR6aHdYK0JxYndLcWFvU2pkRjJBc1V3cW9aN0lvWnN2TTVUeW0yUklmTE1oa0ZUODBWUHRkbWhkQzFzcXljVTdvMjVLNTFucEd0OWY0My9OS1hzVkx0amovUHUzUE85RHNXZlUxLzBGSktIaElIckwzeXlvM2k2eVByQjdZdEtOMzNIajM4d2NJOVR4VlhBM0dyNndmTjVYZHM3ZUM1UUR1N1I0Si9sQXJWd3FOQ0pBODh0VEFZempZZGlPUmxJeHRiQVp6aGdwTlVncE9VRkNRNWlTK2dRZ2dVcTVRa25NUVhDUHU0azBEV0FFZVorVGFFSUZsNTIyUGNTQ1dxdnhRamhNQlJEV0lNamtpMnFSSnlCeXZMSmxTVDVYR1RsYURKS28vQ2o3U2NiLyszUFdublo1Mi8wcytPd3BFR2EyZ0hXVmhBcHBBcTFadVlMOUdONkV0ZW9VcjRjNUlOamFrMlZJQVh5VFkwQU9CTmJReExzNkVGL3Baa3YwZytraURtZS9nNXNFOHhaVTI2S2NQNUJYWXdYMFZyWDZOVkhJV2ZjYU9KUi9TMGRWczdILy9ya1IxdHFFUzNrUVZGeFBDdTRtMjRONU16MmQ0c01Vc2x6dk5KU0tQZThmQkxqcGNBOTNaeDFVTGtEd1ROZFYwVllzTFdaRlJkVDhPRk9aaVpjamt1ekJFWFcrYm5NNG9xT3h3Z1FaaWlvc0djZ0FZckpxMHFJYTdGRWM0cFpDNllCOVFjeHZ4RWVOcXZoTHNoalZFd282QTd5VTFoRk94UDMxMVhsYVRUSTNKTktRVVRkMm5TL0gvUHJLMS9jTmFGSUR3dEltUWlrMXhWS3Y0dnMzalZJNmx6N2tmS0trMmJDUEFmM3pOL0tRRE5qcmkvaERSQkZmNlJ5K0VmdVVuMVQzNUxMK0FvTWFPQ3hjb3BnR1hUNHJLRmpQeHNNQlg2a2N2bW1zTmhFbEw4cUpDMDhHWmJEZ0FKT0pvYXl4QUIwaVV1ZXlGMmV4NFpSVTRDVU1TVUZhT1diOXIxTFAzdndiVW5LeUxuWjRsMEgzMFhiazdaQmJmNGlmemxQMzRzaWoyaTFIVTFCT3U2aTVOd0lPcWNqR3hPV2o0blEwcE5OekVuT0R0SW5wTVY1bVJJbWxNYytzSG1aTWhCOWJQa09lVTRnRnNpbVFVWnNSOGQ1TTBJSGYzekQyYy92L3Jxa3dlY05mcXFXM1k5Tm1VbUN5bU01Q2M2VUVPL3ByR2RQMTdSZHFPbi9JMW4vL3FTaHg2SHVmQk44a0xNRWU0UnVFeTdYVUtLWDhuQWt3UXJWMnZQN1VldDNRNXE3YzRrdFhhbnJkdmh0UGRSYTJmUG9WcTdRMVZydHp1UzFOcnhJRm9CbzBsQURDcFk0TlF3WkxkSENFSTBVdFRjT1Z3elhkRTlzbTdQN1gxVjNaVmNMYTdzem5QS2pacHpVR1BxR0NIaVZEbFk4SURPNnVlNlJpNVV6dE1ycFB4NmFPVGhBdTVXQ2ZKY1pNSks4QVR6OGFnYVYrZGQ0eFhQQmRSb0ozMDZmL2FtQ3dhSmwyakpmdkp2SlRPN2kyNmo1eitoWGhzL0krNW1kdksxSVFlQmFka0c1ei9aUXJJT0x2TWpGNzgyWEp3UlE5RndCemlMQTdnRGpDaCtaRE1tblFna0RxVVNLS2hjb2h5WTBXOWlVNVlmdCtJcWNrWDgzRXhQOTlPSXMzQ0RuM3doT3RRekl1YnZ3eEJyTXp2WjMvazRyVm1KY1JvVDQ3UWRjWnpjbEFvL3RNREpEdUxqVEdDYStNSFI4ZHRlZk9LS1dlZk1YM2xCN0dIbEhNMUlZL1NyUVJ2YTk3eEVIb1pESkg3ZWVEL1dDYWI5MGZOR3JpY014Uzl3dWN3SGUzeWx1ZlVpTit5NU05T0JZNXhEOWl1c0MweVBqd2Q3Y3dBRGJFbmhqdTMvcVBGM2pBaVBHdEhwWWc5eUxtZnVidnlRRFdzQm1OTzZoWW0vVVF0QVRqR3VUV0hQaWl0Z3crMEdmVitMK3FDWnF3R1FhZ2ZUZExDM2JNbWdoRTF2RW5Wa0YxUURCS1VlWU1aNndMVDBla0QvUlFBekZnRndvUDU0TGNBaUtkUisvVlFEa2diWWZ6WGcwTHNnWjBsT2pHc0dNZC9Td2ozTUE4cWIvSzV0VC9Bb3FwMW1IaXVTdlhoNFJVbW5DTFI1SUt4ekF0cXFXNVR0RHFUU2MzUWJzNnkyTWxVYU1DcnA5RmFuQ205SkErYXovOTBzVjl6N005bXJKM3YvRjduK21UdTd6SHFhZnpVdDBtbDE4cnBENTJrMmN0K1RObDd4MXFGY3pZRkxkdGYxWHF6NklHcFlldFQ2WGRqaURLYU0xOE9YR3pvTFlMQldqNktsQjFnbjNJMVROUFg0cUpKMDlVcHFQYWlyQjM2WG9xMDNjdEU4ME5aVGRyeDBmYjAvSGtOeVhwSUR1Z3BCeDNhamd2aDVzYVRVQjdSY0dsYUxyWXRoRTR1cFRBZzdOK25adFdZTjROMVkzd053STZqOHdkUnRWbjRyTm9EVXFFdWJ3eE84YnBFNDgyQ3RiSTZJYkhmekxvb2NKRHBWT0VJbHI1UWFNem05RXJLRk5xd1Q2M2FHWWk4OHRDQWxYTHFFdkh4dlNXbE9sYnorMXlWa0x4MnNxMURDcEVPdms4ZW1YWHpxWWpZMzFEMW04V0V1eS9NRHd1NWs1ZVBhRk9YamVsWDVHR2hKaXRnc2k4cGhsa1hRUitHTmE1WlVXUTUwNTFWQkgwVSttMitWTFZ5WEVFYjI0bG10TlUwaEdjQndWWGtBMnFrMFF1TG1aUWx1MU96V0lYbEQyRkdIaGJaUXFUM2tZL2Fvci8wRGVzbHBOdnN0OWVSNUtUWWNmQ1F0WlhtU2F0RFBFNnJLR3U0djJtK1l2M0FGbUlYcEhwTWQ5eGk3UDFRV2pHWngzWVVpWGl6UXgzV3dGZDBYckExWTlOd1MrU3c4RVQzSVU4ZUxwSEZHMUxpUEpJc3djQTlKZmlyaExYdFVoWVpxeFZIK0ZOZHBVRHhHZTdNaTBIRG9aKzR4NGhWeHhRYU40anZiVVRPN25zVTFlNDVDTnh1SVBkcUMwU28rNDBZMjQ4SEpPdHJBcGxuTEpsK2JMS25kM1dJcllSN1Z3SjV2OElkYkhHa2VOQ1JaWXp0Y0N6U0loZXp5Q1RWd0xhWlFpU1BjMk5hS3JHUC9OelMzK3hQRk9iSVdkMzVmWlp3ankzTkwzZWtDT2FpUlFWaytPeGxqRGp4Sk1pbWFEZ2FGWHhyU0cyYTFxTVdHSW5jV0Z0REplbE84ZnBtTm9Ic3VyUTRRY1FPQzdnMmlBU3FyWERkSGFaLzFFUlZxajE4U0M5OThvdGdsUFJEN3EyaU8vWmZkV0t1cCtRTlNSTUpMNVhVYmFjdkcyRSszZ01lSU04Uk9nZThyMnVHYWRxRmFhQlRhaFFjNDBnQ1lSZ2NhZ09Ba1l1R3lhb2cwYUExRXBVQ2xCYUlsTFJDZUVHQ25ZRDVSd3daWmcvUW1FSnNBd0tZSkFUWUEyM0N6eTJJdysxa2pLSkZLcU40ZXNWVHFGWVNCSGRER3pmWklkbjVwSzlMTmhvdVE0WDlnSlM4WUJlemRnZ2NaUk1KNnVIOGI3VWdpR2NyaThpOURTYklidU5WS2g4T3JWaGtyMDcxQ0tYck0vczlQM2VjdnZlR2U0TmhuNWx5MnRhcXhhOUh1ZjhSbTZrakRTYmRQUFdIOVBQckZ4Wk9ldnBKNXhablRiOXgyWjdSRHZJUDhmT215Wld0SXhkMFA2YmdyVkRWT1AzbjZxVFQyenBsMGRXbkYrcktTZjE2NnNHdmp5VFB1dmUwMG5mNnN6Mi9mMXFuMkdrbnZzWHRTRnJ2NmJsVHV0SEVuME9DeXEyVnJJREN6c1EzYmhqQkVHNXdPT2VOMHhhb2pZSytBQVNEZUxDQTAyRGh1R1ZXOFdhVERiMTJBOWNqbUN0U3dNUm5nbkRhM2xTZVBiamkzaCsxSWJSWGdYNmwxamIyU08zYVRPQ0VXRlMrSUdWTjIyYmdMeFc5UlFsdzM3Q1BtNlZBaDI1cXVvZ1Uxc1ZLdW9sWEtGZXM5YkpZZTVBejNaRU8xSzE0aTAyTlJyRHRiTHloaXlucGVDQU45RzVSdEw3RHlpcGdlTmxOdks0b0RSYlBzRXU4SUx2RHhzblEvQW1PbFJ4RFNTcnRmOTZNT3ZpVEZHdlg5YVlWcjNsQ3NFMnZub3VHaWNQN2hnN0pmM29vTWg2cnVPWkROWjRuODJETHFKUGFzVklaRFlKSG5BbllBV0xVbzlJWk9OYzRQNWRvak11cWZzM3VMazg5VFJuV25MRWRJejJHWklFNmphMktYaGNJcTVyUkJXdHB5dnNacU8zendnL2NYdjNJbEdVNFcwQkI5Sy9aVStQbFg5bjl2Rlo4WlJVU2lIWDluV1RGZFJiZlRCK2txY2MxaDRVY2lmNGZ6bU0vVyt0K296NXNQODNDbytyeFkvWlJadnVjaURoUGd1Z3p4TmhlWEE1bEY4dms4ckdxZmpxQWt5M0NuTk1tOHQ0WHdveUtZaHg0VnF3eDhIcnlMdWdubEJiazBINytrVythTEg4b1BkczdaZXZLSld4WWVKTlpEYjc3MDlVTnJWNisrTFl2c1gvajhycEtxbXl1OTlFTjZXS0IvSjVyZHQyL2RlanZjRDNFdDJIMGYxcUpjYUFCODFaSFdBOXB3L2NGb0liOFZWc2ZGTlpUMWdlQzRoRDBzc2FHUUZaRGdEa2hadFdEeXFvVXJTcUROTkNzSHVNREN1UU1BcSszNUEwdEkrcm03SFdGcFkrMFpWTi82WDI1TmZ0OGJtNGF2UDRzbFlQMHJoU0QwWFJ6SkIwRHpxeUVZTGVhMnEyVzJhMHoyaVFKT2t4Z3F0V0hzVk1jZTFqRlB5WXA3U2xPeXA0U3JTcG50bUs4Z2MyMGQwUC8rQVpmcHozTDl1bExzL1F3eFFUL3VKZDNkeDJnU3IyMHpmN01MaGV3K3V5UnpkVHZmSDZvTVJsM2NVRjUrOE9LSTgwbjJLV3dYS2ZSZzJNTHBRRTdGY0ZrUjZrb2NSUm03SHhQMFU5QStQNFBmOUZQVmpnZWl5ZlBudGUzdHl2eFBUNjV1SDkyc3JVYzE2L3dqbHJIN25YVG1namJKSkpIWVgxbjcyUFJKUzhMWXd3YzFMcmJtZ0lVZEpuUXFDRTROdTByVWRxNmtQaTdZVUlZRW93TzRHUVp4ZXFicW5yQ2ZtY0Z2dzR1Z25UMXM3OXZVRmJIaHVZQ05CUVJJMmRUa2g1WFBxNFNTUWFqZEh2YVd3TjZpcWVSQ3JsbjJNTUgyTG9mUzNtWC9BKzFkL1pqeHQ5cThXdnZhODRqZFh0by9aWWlySldFRTIzOFdNRjhxRmVxRU5pSE11NzZnSUIxditVcnE5UW9OOEljR0JhTVYzSzdBd3RUdUQvbDZWSGl4MHZ2VjNWUUVVQm8wdGovY2hGSjZHZnZCam1HdjkxZER5NUhWNitMazJkMTUrWUZCV0syUnZIWkZZREZNc0NQTW9YU0UyWldPTU1kUmQ0VDFZK0grTzhNMGZXM2JUNE9ZUEt1UFZRbjZxcHZsS3JuQStlUlIvZFFLZmdxSmljUG9zWnBydVlwN0h1SU1YVW9zNG9MalJwc2RYY3pEcHcvYXROQ1A2bkNFVFU0NDM3VW9wYllVQnlOZUlMMDNjWThhZThyYlp6eXo3NzEzMTVDUFkvT2xSZFJCTEtTQTl0RHZmd0VIdWZYNks2KzlqcnkyYVEzMUdWNTU4b1Yvc1BIbVVaKzBUbFBKeGp0VjRMa3JYRU51cmtDb1owRzBubzlVN2dsbmN3V2hjRFpJRDFwUVFFNTBZendNcWc4Q0NIM1lZUGNJbTAwcVNDVW5iWlJGb2lzYndQOTVrV2Z2ZnZxMWZjdklvN0c3cFJJNlljUEhsOUIvZlBIcHRiUjMybU4zZFhRdEp0K3N1NGphZGVmdHUvcHQrdE1vaUpXZVkvdGV0WFkxNW9BbnA2SlZnTnJQNWcvYkRRZlV4aTZGNVVQdGVITXBaQjVoV1lzbHQyNmQxWVlWUW9ONkZzSjEzTXl0Y2JLS0lNTG9rTEdEamZ1NU84MDZxU0I2bDAzZisra3NjWXk4cnZmcjkwT2FqbCtYUythOVBZZG15YjNYWEpQUW0yc1Z6R3gzbnRwSGJ3N3FwMVlZb3lONWpLclFuRE1oTk1mY3ZsdHJ0aVFLbC8wb3pIbGR5ZHB5SmVLWWRGazVUUlRHSlNtMit3WVZNQ3VGeS9wYUw5Y2ZLZzlHbmZ6U0xvNmpXWlFoS3ZLWEtsbUtFbU9veHExT01hNE5KSzNEeGxMT25HS3dINFY5KzdsQ2syMitxTzgxbWI0R2ZXK1drckllMjlsNlFHeTZ2TytLdUlGZUxtcm44d1lWdllya2VVTVhzMEpBbXhTWHFndFdtYVFNbUczQms2QndTWjRDUStwLzFmcVpiZkpLbXZ2T3RvOWc0TEdaNGtua2ZtZnJERnpMUHNFdm5Kdk8vZzVnT3E4L05EQVl6ZWR6cm1SenJrK0c3SHNTOGllQVA2bHhZRFZDNVYrR1hnY0lFYm9OVmhjSHNMdVExazNiZWdUQzVmNFd1QTlYL01NL2Z2bjFkOTkrOWZXUHIyWUlGOUo1NHpuWmNqWHhraUpTUlh2RUIvb1lSTU81NU5uNkE5Y3lWT3ZPVFdlVEI0TGxVbitvTGhndDRQYW9ZdlpvU0daYWh1TVlSUzRvcVV5bjhpOEhRQUN3R094aHkrSDJBTkxsakN6elNZekwvU3BNWitSY0RtUXdSbWErWmZIMERQSGkvNjhIOFArRkhvQ2NkQzJxbWZIR0k5dSt2OHc0c1JhWmsrT2tGWUxrT0ErV3haeXJKc2NHcTF2Q013VklqdTJ1bzE2NG83NW8weGYwaWFPNGRsUFdXTHcwUTJ3cUoxMjdxcUw4K2lPdmZYK0s4Z2xmU0ZLVWg4MTdvQU5KQzVJOEJJNWw4c0V0TEhuTWZpZ3NiNUE4Y0I4T093ZmlPZXpSdXMzUlhlSnA3dVQ5elNzOTdtSGk0TDVHa3dDL3FsbklmSTdiNnc3VjM2UURQRFgyTUgvTGRocEVNMGUxWnJKWGZrOEdDemtVQzdFTXlZRXdiSWRUSVhTQWM2dHUwZUN4b29zTnhPaFVZRUVPMXlaMEFoZFlLQnViQkQxUVlBaUpTdEdRR1VRRGNpZGVqcXhoenNlaXd3b0FEUFZudVBZZC8zcUQxRytoSFRUNndlWXBPMDRqT21MU3g4YUlqK1hRWDk3Y3NlV09EQUhDeEtrNzZiNjM2UzEwWmN2NmJDL3hFUDJtajM0ZFQvN1dOMDVvWVhuUVBPWnIzRzdiaEVpdXdPbG1JazVWeGRHZ3ozVUNrNWpodCt5bTQ0RHRITXVCaUE3WlVuVjZRMjMzd0J3ZHk0b3EyVXNxL1dEV2hQWE1UazB1V0UvSDBzcUl0cVllUzNlYVhKNEE2TzBnNzJBQXlUdzRyckVDaVFpaTE1VUVvTVhMYXpNOHRlU050ZjFac0tWdDdjdy9QMlpnV2JiSGV1L2RDMjRaMk5ReDZXY2kwaS9vbjV4OXJWZDJVNDV2Vi9kMU8rNXFYSk5YU2orbFA5SkQ5T08rQ1k4bzVER2ZlNFBGNVRuTWVvMUtaNGFUZVp5Z2tQR0JrQWpmbURrSG1kT2lRc25DR2p1WEd5Yll2a09DeEJKSHBMUkFkSnYzS05ubU1ldnpzOGpKRDlQMnFWZmR1MkxSMUZtbkxGbzk3RHNNd2QvejF4MmZJeFgwR2gvcG1sRFlXVE52aldZamhMdHgvZVJXd2NWMjNrQWYvV1RRWWVIcEYyY21PRW9CWkJoUlp0bmpEekR5VHBjNjBPeG1vNUVVKzN6RDdBTlo5dXdNRmlyeGh3WUVRUUVCL0traWdGSVA3aDRvU0VDYnRZOTM4S0xVZ3c5TzhXUk5EcWRqT2twRDl1TU8vUnIzdzR5eGRoOWp5K1Y5cnlOdTkrM003bDVoSVBJRnBWcSsyQitxRFVaeitVekxBeWg0a05NVExuQmdIemJnNDZzY1hQQ2d0QUJuNm1yOUhRclYvYzAwODZLOW5ESEk3cU5YUFRIVFBvdHJxbXRUTkZ0bTlsMVRaS2pPajgrc1hPRUJCODJXQWpqcVoydm9SYlhFY2p0dysxZEFnZnAzWEJxcUlub3cvcWpmMVh6WHQ2Z29Xclo5VUcvOXZOeGRaZHRiTTE4M0huOTBaUGFRdjlSNVJqd3dDSDdHMS9KN1JhZG5SdnBhWW5FeHJ5ZWM3NGhqMWN1VldtSitIczdRVmVMbG1oeWhhbFFyMVArT2xjd3d3OHlydUQ5dGVobXZ3ejZ6Z3pYRTNpTjJYVHJaL0dxaGY4Y2N4d1VhV1Vxb05jTkJJa0EwQy8yaDZtRFV6WjBXUVB3RDBucU93bmtPUE1ZdjRhc2Nxa0FpVFJYUE5SQ0N0andJdnJCblQ4c1AwZnJndWZoUldUOGVITWQ0SWNMcm03NmVtd3I2d3ZZdjZmTysxK2RtTm1jenV6NGRRaEh6MjJVS1g1MENCSXZhWkR3elorRVZuRFZWQmFNNWZNNmxuSEE5cFU5SlZTTXE1dXNlS3Vkb09nNFo0OXBFVHU3TXhSeHRLOXRVNnNrVWxOZ1JwNjBneHpvUk43WXpRM0NVRENYRHBqSnBTSVpZRW5GbHlCVm9nTHVCZWxoTWdQOVp3UGJGZUJlek5hV1hPRXVsSUZSNmlmY0NDZURkZDh2cmxBNW1GZnNsVld2SzJYdTNDU0dOSDdvUEl4cHNYZFpnNjdMeUliWUQzWHBaNk51dm5QNFpPNEhnYjBPbnBueHQ3emVBNmNKWWVDLzc5Z0h6VmFQaXJmNTREV2RBRUkrRzBXMVpWaTg1VmZ4bFg3ZXRqMU1ZaUFGZ01VanlYRGdhS0FtRWRRNFU1dFRaY0FIOUZwN3Y2eUREOTFYakxTY0x5enE4cHNGQ09GaW1jclhDMTk4cUVnU1dmUkVqeHQ3L1VQcHRxT3VoWjk5OE84TWgwSm91ZVYxczJ3c3Z2ZmpXald2WFhuT1I5RlBhVXY3U3FZRFRaT1JTbWN6ODJLaDRjaDB3ZDZJOWFwazlWQUYxZGxPVkhDcGV0cTlMYzBHbExKdHFqeVN2aHFhN1lnNE1CZWZXb1JnSWlFSGlYVmdIRE5xbFZYaG5TamFJUXFWYXJoS3BIc0VlT3p0SjZjdDcvL1lTL1lMWWlMRDhadnBqUndhTFRPM1VWTkp4bTIvZGV1K2E3bG5IUy9QU0RQTHJBVkNraG5pbmpxNVd1REJ6aGR2VDJEQVJDR0hNUklxWkI5QnJPQnMwY2xKTU03YUJtNkUxMW15THVoeW9UbVJFMEpFVFFVY1JJMUpRR1pHdVVpR0RkM0YrcDdBUjBpSWJhanpibEpxd0NZbFNCRWZZbWEyd1BpVXhXVXBzNjBQcFJyYnBKN0ZyRmxTMXoxNy9ZVXRiQ3N0bTcvMk8wMGdsL2FMWHplWnFaM1BsZkp1NWtGR25NRzZxYysxTHZKbVlxeTE5cm15R1RqNURKNXVoTTIyR0RxT1pveWM0WHVEL1lKWkozSjJseWl4VE9EeGo0OWtzQytuM2JKYXdwbnE2V25NdjhqQWdrbGl0WENxZDZZQW9SbFpkRDVBWVErOEtWcXFjdG5oenVNWEZFU29DSm1HaW8xdGp0RHRTRzhWOUJpSW5EVEMxYWYyOUo3QmxmYXU2SUluZWRSZjByWDhTWHhJMjFnbzIxbXprY0VnZEsvbC9iYXlwemUzWFBBS3Q3ZVJMZGF6eEh2ZllKOURmL2tuQ3NFVFFzbnZnVXVTTEhweGdEcGQ1MkJabEY0MXNoZ1prM0VKQlpNSGhoNDJCbndLejIxbFlsdFFySGc0MGNIQUFHb1B4YVVtWTdpTTE5Q3F3NGR3SXZaUUUyTzhoYnNjZHQ0aFRZbjlsZCtuUUxiR1p2UEdmc0d4VGtOaEZuRFlXMG1jcyt0ODlsZ295bTM1SGpQUXZpbzJlSkZiNkZUbUYyK25mcThoZXNBOGR2SXJtY2dJQUloeFA5b3QxNHFtQS9JVVRqK1BKaDJUL0xiZncrK2NmL2RzVXNsL2FpSDl6ZytZRGtOdkJGd0NRRmRReC9KTXAwZ2o4Si9oNjNkTGZmcjNPcDd6ZUk5MUwydGhhNmtEREVnbS9kZXlTMXNRcGhhRW1CdVY2cllCTndmRHZteDFJYisvSm1kTjgwYkN5aUxSN0J0RXMrMG5SZ1UxNVA3alNva0xpL2NTZXNFWjVQNDJJaG9mM1kyL24xb282ejZqaXNDVjNUcEM5Z2V0MTExeDZlREhxUWg4V3lEemgzNEplS0VmTkMwbDVOd05vWGlENU5SeWk0RExxNDZPRHR4dWNOOVFNNzlkNFdEaWRWTS9NbVV2cGVldzZZK01UTzNCOFZtQllWTmtEK2FSRGxuaUxneGFQWGNONlpGL2x6UTJLQ2FDaW9JRytOVGprVDVpanZOa1paQjhiTnd1WjBiTDhvc0pXYzl3K09hOFJZVEg5OTZtOHZ5NHhEbHQ4SEZuQnFKNlBRK0JzSTl4ZUlRMXYxRGF6Y1RnU3BnUGhUVDNRU29FbWJzS013ZVkwZTM2ZE85d1VOcnRQYVU0WWRpNnBuZVU2aWRLTGxMRWNKbUlIc3pHTVpZU0FDeDlVREIzSyt2MGpjZi9tU0E1bkdnZ1JPc2kveEFuU2Myd1ByQlBZQWl0RGlDKzVDWlZDdEE3QnlKN2tQMVN1bXFUWW9PTzhNeGVlditTTU14YUxQY3N1WG5IUmhhc3V4MXpsbHNPZnlWY0tYeW5uT2hQaC9jTXVieERuYVdOdlpNMFBCSlRIQk1wVC9KTWNYSEdFeGVWUkIvL05nZWM3MFNMOERiSlM5dkV0L1lRcHlZOXZPYVpsME5CaExZSGhvaGgvSkttUHpoZytjdVR3b2FNR2owbjdDZGV6Y0w1b2xUclpudXNWU0VpSEE1Tng3Z0J5MXF2TnVCcDBnU2JpTmhEZEZITGNoZlRmSlBkQzBwdEhyaDlKSDZRN1I2TjlKN0gzTXFlK0Y3dWZLMitYZUM4Qzc5VmlJQzNFUlNhUkhQcmwrV1FTalR4Q3BwTnBJK215UExxTVg1Y0hOUXZsRHQ3TjdvUGN2Y2lrb05Wc3lCL3V5eklEaDF4WVlEdHZYaUNxMCtJVDJjR3dUbjhBQlJRcThRcDJXdzVFM01obDZNNkRpTUVOOUJTU1c5V3dBZEFvSUxIYzJNcFdnZlJmUG9SYXdwMnVwRFZzMDNHWW1xSkN5MktIeXFZV1gxT3dXZUFzVnlVUzI4NTFMamY3enVHVld1aHFIN3hKRkRkMVZKRDh6L2R1SGQyNWl1NmZTTDZsR2xFa3o5QkpaYzkxYmQ1MDQvYlA2UmNEeVZlcnFtc21yWXFSZ2puWFRxTXJWN1VNR2JEcTRhZUhiUmhLNUYvWWRWTW12aXJQeG12WUk2eFFzaUtES2NqbUxDZlRMMm5aalBRV1p3RHdIcm4ra0pZdElKZnFrYlZ4VGhVdGNsdG9WVG9vNW1HZU9EcytTeTBVaHRkNDQwdTMwZVJBSVV1K25VT3JFSXVKOC9HRXRNVW5zZi9kOWpMUit0ZUx5RFc3L3ZMY3c1ZHE5YStjdmxldmxYMW5uQkY3UUR5QmZUMFIrNmRZRkJ0Tk5sOFQrMHdzV2tYbktGeElGWm9LZHJWVUp2WE9LYjB1a0FqbzRHckVIOHE5cE1IdXRjTS9PZlNlOFA4QXZIRDJuUUFBQUhqYW5aVFBheE5CRk1mZkp1a3YrZ01WRDFJOERKNUVtazAyS0dvTFNraExLWVFLVFNrSVhxYTcwODAweWU0eU95R2tkLzhCL3dZdnZYZ1F6eDVFYi80SlhnUVAvaE9DMzVtZHBMK29pbGxtOXJPejczM2Z5M3N2SWFKVjd4bDVWSHlla25iczBRSjljbHlpT2ZybXVBejdWY2NWdXVtOWREeERTOTVyeDdOMHcvdmdlSTcyU2ozSDgzUzc5TlB4SXQwdFAzYThSSDc1dmVObDhpdlBIYS9RZzhwblJQUXFDM2hTTnJwaGoyN1JPOGNsV0gxMVhLYUg5TU54aGU1NWp4elAwQjJ2NTNpV21QZkc4Unk5OWI0NG5xZjdwWStPRitsSjZaZmpKWHBWM25lOERQN3VlSVgyS3dsdGtxUVlTMk9ka0tDSUdCYkhNd2VGbEZKR1kyUnVyTG80WlhTSzFhQTZCVmhWUndHdDRYUWIxaW5zK3RCaDFBSXJlSnVkVy8yVUV2S0pObVVzdFR3UkVZdTQ1aXhNczdHU2NWZXpVOWFvQi9VcXRtQ05iYWRwM0Jlc2xhb3NWVnpMTklIckMrZ0pxRERxUURPaEhFZVpTRmlISjhBOXZJdHBpUGpjMUhwUHhNTStCd1NJYXJMZHdONkVad3MwVVpyb1ZDOTdCMzVRM3dpYW5kYUdpV0FDVktlQ1Y5TmdsOTJuYWJHcDF3RXNGR3lMUXJCcFduUWdWSTd2eDB4SStudG0vNWFQdEx0cG9yWU5pR0F4c0FJOW5LVjBkS1ZoeHRPMDMxaU5jVCswcDhvR04ycmE1bCtNaUxUUlFudGlScVY0UGthU3l0cEcyTU5wMDNQVDlyT0t5Snh4cGhXUHhJQ3JIa3VQSnMzbVNjUUdmTXdPQlZNaWxya1dDbE1pRXhZS3BUbnV4ME1sODBpR1poeHlhRFloSGRxdkh0bFVycHM2YXVhaFNDS2h6czhUMllIV01GNm5HcTZSdlh5NFhSUU5uYVJ2YVFCTDZtcWRyZGRxbzlISTUwNDVoTEFmcG9QYS84dHFsRDJ6QlJaMlRHTFlGaVBqVzgwQkd2WEgwSHFjaVVqa01rNHdVWDVYRDJEZnRwMFF0Z3RGNzRibnlxVWhiTHJjUkdBT3UrTHBvby81YVYrZTNRWlN3cXkySlRMSTBhT2hMYTd1Q3RiTWVJaWJlN1BHSnNQZDhPdlhWK1lzdUcrckV1TnQvMElTT1U3YXRJUCtidEV1eG56TC92ZllKTTVYeEFiM1V4WFgra1VDZWEyOTA5cmE3V3hWVFFLL0FacDZPamtBQUFCNDJtM1ZaWlJXUlFERzhlY1pZQmVXN2s0RkE1VDM5cjBHZUZOQXdFQVVBWlVWbGwwRWQ2a1Z3ZTV1eGU0T1ZGQkJzUlhzN2dJVjdPN0dPUHMreDAvT09YUCs5ODZIK1ozNU1nT0RwckdwRGpQeFA0T1AvenNObTZFWm1xTUZLbENKbG1pRktyUkdHN1JGTzdSSEIzUkVKM1JHRjNSRk4zUkhEL1JFTC9SR0gvUkZQL1RIQUF6RUlHeUd6VEVZUTdBRnRzUlcyQnBETVF6YllGc01Sd2tXYkRodzRjRkhnQkFSdHNQMjJBRTdZZ1JHWWlmRVNKQWlRNDRDTzJNVVJtTU1kc0ZZak1ONDdJcmRzRHYyd0FUc2lZbllDM3RqRXZiQlpFekJWT3lML2JBL3BxR2F6WEVjanNkU25JRlRjUk5iNEJTY2p2VzRHY3Z3QkE3QVdaaUJaMUNESi9FMG5zUHplQkV2b1JhdjR6WFU0V1FjaU5tWWd5dlJnSG1ZaS9sWWdJT3hDSXR4S0E3RGtUZ0tSMk0xSzFpSlRmaUxMZGtLRzdDUlZXeU5PN0NjYmRnVzk3RWQyN01ETytKTnJNTmI3TVRPN01LdTdNYnU3TUdlN01YZTdNTys3TWYrSE1DQkhNVE51RGtIY3dpMzRKYmNpbHR6S0lkeEcyN0w0U3pSb2sySExqMzZEQmd5NG5iY25qdHdSNDdnU083RW1BbFRac3haY0dlTzRtaU80UzRjeTNFY3oxMjVHM2ZuSHB6QVBUbVJlM0Z2VHVJK25Nd3BuTXA5dVIvMzV6Ulc4d0JPNXd6V2NDWnJXY2RaUEpDek9ZY0hzWjRObk10NW5NOEZYTWhHSHN4RlBJU0x1WVNIOGpBZXppTjRKSS9pMFR5R3gvSTRIczhUZUNKUDRzazhoYWZ5Tko3T00zZ216K0xaUElmbjhqeWV6Nlc4Z0JmeUlsN01TM2dwTCtQbHZJSlg4aXBleld0NExhL2o5YnlCTi9JbTNzeGJlQ3VYOFRiZXpqdTRuQ3Q0SisvaTNWekpWYnlIOTNJMTcrUDlmSUFQOGlFK3pFZjRLQi9qR3E3bDQzeUNUL0lwUHMxbitDeWY0L044Z1MveUpiN01WL2dxWCtQcmZJTnY4aTIrelhmNEx0ZHhQZC9qKy95QUc3aVJIL0lqZnN4UCtDay80K2Y4Z2wveUszN05iL2d0ditQMy9JRS84aWYrekYvNEszL2o3L3lEZjNJVC8rTGZCb2JHbUdhbXVXbGhLa3lsYVdsYW1TclQyclF4YlUwNzA5NTBNQjFOSjlQWmRERmRUVGZUM2ZRd1BVMHYwOXYwTVgxTlA2ekFuVmlKVlZpRHUzQTMxdUpFM0dMNjQwRThaQWFZZ1RqTkRLcW9uYk40YnAxVjJWZy9xMVFxWmVYR0pUV3JqQnRxRytwclpsZFdxN2xhVTI3RitPcnBqUXRyS3VyTG1WRE9nbkltbDdPa0tWV1RaelFzcko0K3ZhWitZZFdTL3o2YkhMZFVVaTNWVmgzVlZUM1ZWd00xVkNNMVZoTTFWVE0xVjR0eUxmbVdmRXUrSmQrU2I4bTM1RnZ5TGZtV2ZFdStKZCtTYjhtMzVGdnliZm0yZkZ1K0xkK1diOHUzNWR2eWJmbTJmRnUrTGQrV2I4dTM1ZHZ5SGZtT2ZFZStJOStSNzhoMzVEdnlIZm1PZkVlK0k5K1I3OGgzNUR2eVhmbXVmRmUrSzkrVjc4cDM1YnZ5WGZtdWZGZStLOStWNzhwMzVidnlQZm1lZkUrK0o5K1Q3OG4zNUh2eVBmbWVmRSsrSjkrVDc4bjM1SHZ5ZmZtK2ZGKytMOStYNzh2MzVmdnlmZm0rZkYrK0w5K1g3OHYzNWZ2eUEvbUIvRUIrSUQrUUg4Z1A1QWZ5QS9tQi9FQitJRCtRSDhnUDVBZnlRL21oL0ZCK0tEK1VIOG9QNVlkeVE3bWgzRkJ1S0RlVUc4b041VVp5STdtUjNFaHVKRGVTRzhtTmRPNUlmaVEva2gvSmorUkg4aVA1a1h6ZHMyNHNQNVlmeTQvbHgvSmorYkg4V0g0c1A1WWZ5NC9seC9KaitiSDhSSDRpUDVHZnlFL2tKL0lUK1luOFJINGlQNUdmeUUva0ovSVQrWW44Vkg0cVA1V2Z5ay9scC9KVCthbjhWSDRxUDVXZnlrL2xwL0pUK2FuOFRING1QNU9meWMva1ovSXorWm44VEg0bVA1T2Z5Yy9rWi9JeitabjhYSDR1UDVlZnk4L2w1L0p6K2JuOFhINHVQNWVmeTgvbDUvSnorYm44UW40aHY1QmZ5Qy9rRi9JTCtZWDhRbjRodjVCZnlDL2tGL0lMK1VXVGI1Zks3LzYvdFZSYmRWUlg5VlJmRGRSUWpkUzRYRXY3V2xiVnpGbTFqZk5yWmxRdnFDc3YyYUs5b25uZU9MK2g2Y2NyMG44QVRmSkFxQUFBQVFBQi8vOEFEd0FCQUFBQURBQUFBQllBQUFBQ0FBRUFBUUhGQUFFQUJBQUFBQUlBQUFBQWVOcGpZR1JnWU9CaThHSHdZMkJ4Y2ZNSllaQktyaXpLWVZCSkwwck5adERMU1N6Slk3QmdZQUdxWWZqL0gwamdad0VCQUdoVUQ1SjQycDJaRFpCVzFYbkhud1BMeWk0dSs0WElSOWo0c1NHc25WaExIVDhvMmlTbHNER09JcXlLZGRGRWhDUUlLeStpQnNFTkV0NUlVUXpCajVDRE1WaHB4dG14ZDNSaUhJeE1NdE16ZFZxYjFBbVQ5RGhHYTZNTmpYb1NHNXZxMmhpMnYrZmNjOStQM1NWTk8zZitjKzQ5NzduM1BPZC9uby8vdmE4WUVXbVdQcmxPR2hZdHZyaFBacTNhdkhHZHpQM014dFUzeVB4MW45NDBJQmRLQTJOa1pFUjA3Tzl6Ym01WXZYRkFKdXRaUklOTWlPMWtNVjNQNmtqVE1xRjdRdmZFV3ladWJSZ0VUMDVxbk5RSEJpZnRvTTBtTlRhZUNENStRdThKQXljTVRPcWIzTnQwNXNSYm1sWTByVzNhQjRZNE93ejBlbTN6aEtaOXpSdWFOelFkYnQ0dzhaYUdKL1hnT1gwZ1B4cjE0RWtjOFo1NFYzRTBQOUM4b2VISnBoVTZ2bWt0TXcvcVhFMW5Oajg2WlczTGdlWkg5V2c1Tm5WVDYvYTJlVzBEVTlhMjdXazUxallBYlB1bWxnTlQxazdkMVA0cVYzdmE5dWpJTnR0bW0xWjBIT3hRQzFkMGRuY2M3T3p1M05XNXEyT29jNWkyVzN1bmRVM3IwcjdjbG80aHZkYXhuY050dG5ONDJ1UFR1bG9PdEc0L2FaYWliZUNrSDNYdW9uL1gxRTJkd3dvOTlEcGh1T1ZBMng2ZXlWM3RtenAzVFZuYk1UUzlhOFpaTXg2YWVjck0rVE1QdFExMEhOUzI1VmhuZHdFZFA3MnJZMmpXOUZtUHpwN1F1VXRYMFRFMCs2dzVFeFR4TGtZbzVzeWI4NTA1NzlNQ3ZiTnJldGZqeFcrSzF1MDU5Q2hzaWpNd2E3V25RTEVDUldGbmJ0dk1RdzJERFlQUkg3WXE4TVh1a1pLY0t6MXlQbGdBRnNvMFdUU1N5ZUtSc2l3QnZlQ2lFU2RMd1dWZ0dkZkxhZnRvTDZlOUFxd0FBenpuUnJBQmJPTzNPM2pHZHZCRnNJUHJNdmdTdUJQc0JIZUJ1OEZ1Y0EvM2Z4bnNBWHU1LzE3dXVaLytyNEw5OUgyZDlodTBCN0R0Q2M0UE1lWXdyUU12akhoNWlldVhPWCtOOWlqdDZ5Q0FZZkFlZUIvOGRzUVpNMUl5VTBFcm1Ea1N6T3lSc2prVm5BNCtCSHJBVXNBYXpUcXdubkczZ3MrUGVMT1o5amJhTGJSYmFRZjVmUnZ0ZG5BUDUzdkFYdVl4OGhFNUpCK1Z1U05XemdEendkbmdYR3c3RDF2UFo4d0NzQkJzcEg4enVBMXNBVHhYYmdlRDRENnVId1FIR0RmRXZZOXgvaTNhWjJuL0FUekgrZmZoNmZtUmZqbkMrUnYwdmNYWXQwZXNtUXhtalBTYldiUWZ3SzR1Y0FybnA0RnVnRzFtSGxqQ1ducHBMd1dYZ2VWYzk5RmV6dmdyd2RWYzkzTzlrbWRkdy9XMXRKK2lYUVZXZzQxYzMwUzdtekZmQmw4QisrbDdFRHRhV0hHRzVSbFdaMWliWVdXR2xSNExQVE5uek95Wk1XTkd6MHdaTTNuMmR4SnJhUVp6dVRvRGZNUTB3NkdIUXg4NVBKK25MQUE1Zng3K1BQeDUrRlBPUEp4NTVjemdJK1laeG5kS0s2UGJRWGQ4Z3VNSmdTY0UrUk91RjlKZUFBWTR2eEZzQUh2akU0SThEQjRCZjRPblBJMTloM2xHYzhXdXdxYmoyYUIrc0lYeHJkalpEazRqdHRTQ1VUUHg1TEpSWHo2WmxmZXo4djR4TTV3THpzT084MmtYUkp2ZG1GbTM4dnZ0WUJCVVdYQ3cwQThML2V4RzY3RjNwQjJ3LzNIbCthb3R0bGhzc2RoaWl4V2JwNCs5WXc0ejltUFIrcmJJWDdHQzBsajc2Ri9FSEl2NURZOGlZNVRJR0NVeWhpVmpXREpHaVl4aHlSZ2xNb1lsWTVUSkdGYXU0dDYvQUZjRDNmdVZ6Rk9iUlVhdmNSdDlkekRQZHZCRnNJUHJNdmdTdUJQc0JIZUJ1OEZ1Y0E5ejRKVmtGWnV5U24vazVuN092d3IyeHdqelpKY1MyYVVzZjhYOEI5bm5iNE9uUUxFelRiRGdZY0N6ZXVVc1lHSEF3c0JUMVRNOG83eWN3eWpMS0p0NHl1QXB3Rk9BcHdCUEFZNDhISGs0OG5EazRTakFVWUNqQUVjZWpnSWNlVGdLY0JUZ1NHZkxtQzFqdGd3K0Fud0UrQWp3RWVERHc0ZUhEdzhmSGo0OGZIajQ4UERoNGNQRGg0Y1BEeDhlUGdKOEJQaFF5elA0VUc4TjhPSGh3OE5IZ0k4QUh4NCtkR1dXbFZrcVE3MFBsOGQ0d0NKR0xRWkxBUG1FbGZtYWVtRlR2YkNwWG1TeFhxeU1zVkJtZFdWV1Z4NW50eTJyczZ6T3Nqckw2aXlyczZ6T3Nqckw2aXlyczZ6T3Nqbzdxb2FVV1oxTnUyMVpuWTExSk45dHkrb3lkdHV6MjlYNGF4NnpYNlA1dmkveDAwQ2tCaUkxRUYyQjZBb3lwZWdaeDZjRE13Vm1xbzdtZm5oc2xoNXpDRHpEdWZab3J0aEN6eFo2dGtoN25hZW9kL1JGVHY3M1hTNTJVM2R4TnM5ZHhuT1hqZXQ3dFUvOXYvalJ2Zld6WVBNeWJGNUduQlN6RlJuM3RMakdaVEY3TWlKbVVHWFB3eFgzZ1djNFA0c2VNbXVzRm1XcVJWbWVvdmM1OXVrZmFaK25QVUtmVm80M3dWdXBnalFDN3FIT2FZM0xxSEdaK1dOQWZUQi9EdEF1cWNMWVdHSElQT1lLMml0cFY4U0tVOWFLUTIyejFEWlBiYlBVTms5TnM5UTBiMWloZVFDd1NyTVBmQTFZUU5hZ3ZubnpNSE1jMG5WaDkrNjZQUGtZRmo2QjFibEtzYWdVUzlYMlZHMVd4VzVyMVg2UnZwK0FseGovTXVQK2hkOWVBZjlLMzAvQnErQTFmdnMzMnArQm80ejVkOXFmZzlkanRjOWdJMFBsbE9RWDNQZkxXUDJ0L0FmNEZYaWIzLzZUOXRmZ3YvajlIZHAzaVlCaHhyOEhmc1AxKzdTL2hRVURKckNxQmpBSk5MS3FFNktLOEtZSnRIQ2VxNmF5SWIrWlRuQVNtQWxtOGZ0c2ZwdEQrMEZ3Q2ppVjY5Tm9UNmVsNHFHc1NpZ09iejRNNW9FZXJsRkY1aHh3SGxnSUxxVC9vK0RqbkpOTjJMbk1YRVI3TWJna0toU1BNaXVoVWp6cXJHU1c0MWw5akNHYnNKdVpJZWJZell5ZDFGMjA1anF3Q2x6UDJOVzBhMmcveDVnYk9GOEgxck1XS3A4cHhkMjI1bWFnU2s5Vm5pcThRVUFjR0dMQTdLU083dUozTWcxS1I5VmVDYlhqVVh3bEZJOUg5WlhNZmRGYk1qd2x3MHN5UE1TYWg4QUJvRm5tbTJCMFhUazVla3JoR2QvUGZUdXlQaXN4cVN3cWczTVRjOHFDTXFEK3FyNjZDcXdHNnE5cW1WcWxGbW1lbXpQbTZjL1h6RERqOTVobFpacnAyc3BzTm5LNWNad1o5NmRaLzZ4U0t4NGp3NHlOZ29BMUFXdWNlTnFYOE5LWHVlczEycU8wcjRPUVlud1l2QWYrVzliZ3FSNVBEWGhxWmliS0dsWVFra2RtckVKMXZLNGs0SG02bW9EbjZZb0NucWVyQ3F3cTRIWGVuTTI5aThHbFhDK05xd3g0VXoyZjE3UGJ5dWthMnR4VHNyamFldS9RMVFjOFFSa0llSUt5RU16ZW5JWEtEdmRVMU94UVZPK0ZhaSt5bW8xWnJjaG96WEZmYXJPWko1dDVzcG5xWlp1eVdTbGxzMEtoMjNHeldIV3Y4bXoyQlhCSFhmYnlGWVhjWG1SazlpcW9sOEJ0aUI2eU11MSs0V2NiSXc4QkhnSThoTGpyUlJhZlhHUjk3QS9ZSDdBeFlHTlZPMCtReCtXblppZXNuRk9wRUVQUlN6emNoSmoxZVpxb212b3UrQjU5TGxZQ0Z5dkJENUlQSDZIL3g5RjdBcDZqWHFIZTRQR0dZS1lueXdzYkx1RDhUMm1YQUZSSXhhYXJZZ1VJbFJWK0Zxd0Q2K25MVjZsdmZQcTI1dzAxMFpUcHZ4ZmNueXJDMTVMUFB3TCtPdTU0dnNiWkZaMmR2NmZhK0o2cXE5RjMxUi9FZDFYTjdCYXJOYXRhckxhbUkxbDZWY1VTZmZmVWpHU3h3bUtGalZaVVprdjYvS3dhSG4zaTBjT2pHOFdqcitIUlJTdU9nQjlIYThiamNEUi82bjgrOGVmZ3p5WCs2bmtieTVtSE02MmtEczRjbkxreGZCbDVGMy9vaXRxNUxhcHNyWW1PcktCMk9iSkNJQ3NFc2tJZ0l3UXlRaUFicUwwT1d4MlJyMUd2RWEvUnJsR3VrYTFSSGJESkVha2FwUnFoR3AyQkhPekp3YjZpYldmRy9ITzgzUE4rckc0KzVwWFRZeVh6TVk4c2pWV29tamV1ai9raXo0cURzVUw0bUJOU1BsQWRsdlNoMXZrM2FOOEV2NGl6QldJL1VITkRySUc5dEgwZ3IyZUJHUUl6aEZpN2JxTGRFZXRNb000RTZremc2YUZTWHdwOTJWVHhpcGRpYnZXd3BUdXJ1MVJsdmh1YlVMMGd0OGxpazBzMlpmRXJRaVA4YWYwdmFydlc3OXhHRzc4U1hNSHZLUGxrcSthZkRGdXpDaHU1elZtMGVXZTAyMkczdzI2SDNWbU4zV1hzTHN1c0doMlllL0p6OGZ0R0ZyMjErSEl3STJZWWgzZTY2SlcxWHhFSzc3dzZXcVQ1S3lPNk15STZJMXFyZXUzTVNsNnUzZjJDZzl3TG5ISlE1d2tGSHpOVHhTbDRxZldPRHljUFVZNEtMK2xMeW5ORmhTY0hUNjdHYTl3WXI2bm55bFZ5ZFFkN1M4WUdUOFFvejRoeVIzUzd1cjJleWpwYlkyUzZ1T2UzY3IwWmJJbnFvOFQrbDJSSFhjd05FWVc1YnMza1c1eXpKNkplNGtDOWRuVnloUFpGMnAvRVdTMGNaalg2MWFGZkhmclZhWlpEdnpyMHE4WnhobjUxNkZjSDE2cGJzNlJiWGRLdER0M3EwS3dPemVxU1psVzltc0YvaGdyb1FiTTY5aUZMWC9Jc210V2hCbnJRclE3ZDZ0Q3NMbXFiRnRxcCtKUm0xbmJPTytrN2lYWW15UFZxbG5ScWxuUnFsblJxVnRGQVBaelBaL3paUFA4YzJ2UEFRbERWcVE2ZDZsQVRQV1lKdUlqemk4RWxJTmVxV2RLcVdkU3FHaU5YMDFiMXFSdWpObko5cXFvamk5bi9SczVMSU5lbmpsMHNzNHRsZHJHTXYyUVZmYnFMMys0R3VUYk5ramJOa2piTm9qYk45YWd6K2syb3FrZnJjeUcxQzRiYjQ2NjZwTXRjWFc2c2pZWnFCajUrZmx3L2ptYy9UWi82N0NuRW9DTUdIZEh1VUFacmlIZ1hhMVFlOGE1T0c5Vkh2VXRSNzFMVTYxdWQxaU5YaWZwY0MyWHBqUzVYY1B1akx0ZDg0NGdsRjk5RW93V1ZubE5qREtCU2FuUnpZVWNXN1ZEL09sa3VpRG5nZVBxNXQwWkQ5NlZNVk9UR1ZTbnVWOU91U2ZteFhybG52QmRvOWF1dGZHK05xbjYvcStvVkZVT3J4ZWpxcDE4dnVpdmZHVldUNXJ5ckx1MkY5M0xTcEZuaVhkK3V5L0JlZ3ZkUzBxRDQ4MGh2ZlBmU04ycDltODQxYUFidjVjUjdPV25RK3JWdXBEL2ZoM0xhaC96YjVQUktOczYvWWZ0WWZVWlhubXJWcWMya1krdnZnelhLZGtwTkpYRmFSU3E2cHFwbmNqMm8zMnMyMWJ5NzVKbHd2Q3lvSHZGQ2ZJT3Z6WUQyZDJRK1c1UDVMUHRwVTliTHhtUTl6WGp2eGppejdMV3R5WHFXckpmOVA3T2VUMW5QcHF4blU5YXpLZXZabXF4bng4MTZ0ZGx1YkthektkTlZGY0IxY2VjejlpUTdUa2JMS2hudDg3RTJsYzF0c1Q2VnpWYmFRY1orZ1YzWnh2a2R0TnRwNjdPY1RWbk9waXhubzZJb01senRsOXRDQ1ZWMWJtdlVocUZPQ1JXWnFQQ1djcDN1ZURQRllQN2RLUnhIZzVRcjM1bnlxUEExMlNpa2JCUlNOZ3AxS2k3UFRLR1NoOXF3eUdLUnJYejFLcjU0OWFhY1VvMkMvQ3ZWdnZSMWlqY09ubUNsa1RWVXZYMTV0Q3Q2dXN5dHJGWmovN25LdHdIOWI4YWw2Rk9kVTZ4U28xQ2ZvcEVZaU1TQURTNCtzUy9HajlvU1l2NWRRZHRQMytqOE96WVBqSitQSjhXdkUwVk1wMWptcmZGai9ESXAvbk0raGZlRlZ0NVhKN0puUGF6eFRQbERPVkhteTlreVZjNlZDL2xsa1N4RzAvZktKK1FEOGttT0xybUU0NE95VkpaVGNTN242SllyT1Q0a1Yway9YRnpEY1lZTXlDM3lCN0paQm5uU050a3VDNlFzTytVQ3VVdDJNL3RYNUQ2ZSs0RHM0N2tQY254U0RzakRjckU4d25FSnl1a3h1VlNla0NkbG1UekZjWVVja3NQTThGMzVIalA4TGNjMThpekh0ZkwzOGsveUtma2grdWt6OGlQNVovbWN2TUN4VGw2VVYyUzl2TXB4a3h6bDJDUS81N2haM3BCZll0ZXY1RzNaSXIrV2QrUjJHWmJmeURaalRJUHNNSTJtVVhhYXllWkUrVXN6MWJUTFBXYTZtUzU3elF3elQrNDFmMlF1azRObXVibEcvczU4MnF5Ukg1clBtdlhpelFhRDVqV2J6TTN5aXJuVjNNYjcrRmF6Vlg1bUJzMmRjdFRzTmlneDgzWHprQnd6RDV0dkdqSGZOdDlocHNNY0ovNFBtWmtzUndBQUFBQUFBUUFBQUFEVUpKaTZBQUFBQU1rMU1Zc0FBQUFBMWZ1dzNnQUJXZFlBWGdBQSkgZm9ybWF0KCd3b2ZmJyk7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc3R5bGU6bm9ybWFsfUBmb250LWZhY2V7Zm9udC1mYW1pbHk6J09wZW4gU2Fucyc7c3JjOnVybChkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQU1KOEFCTUFBQUFCZjRBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBRENXQUFBQUJ3QUFBQWNjMjAwRmtkRVJVWUFBTEo0QUFBQUhnQUFBQjRBSndITVIxQlBVd0FBc3RBQUFBK0dBQUFndnJwcy9wUkhVMVZDQUFDeW1BQUFBRGdBQUFCUWt6eUNTMDlUTHpJQUFBSWtBQUFBWUFBQUFHQ2hzNzJ2WTIxaGNBQUFCdHdBQUFKdUFBQUQ1aFEySEFoamRuUWdBQUFMNUFBQUFFZ0FBQUJJRVVJVmlHWndaMjBBQUFsTUFBQUJzUUFBQW1WVHRDK25aMkZ6Y0FBQXNuQUFBQUFJQUFBQUNBQUFBQkJuYkhsbUFBQVB2QUFBbWpFQUFUWGNHQlNKdTJobFlXUUFBQUdvQUFBQU5nQUFBRFlIbGdCVmFHaGxZUUFBQWVBQUFBQWhBQUFBSkJFckNNdG9iWFI0QUFBQ2hBQUFCRlVBQUFjWWJGZW1CR3h2WTJFQUFBd3NBQUFEamdBQUE0NjBCMmpTYldGNGNBQUFBZ1FBQUFBZ0FBQUFJQUxtQWVCdVlXMWxBQUNwOEFBQUF3MEFBQWFyblJuc0dYQnZjM1FBQUswQUFBQUZid0FBRExXdC9UMGFjSEpsY0FBQUN3QUFBQURoQUFBQmlmTjBVWkIzWldKbUFBRENkQUFBQUFZQUFBQUdBRjlaMWdBQkFBQUFBUm5ia2V6RVZGOFBQUFVBSHdnQUFBQUFBTWxNNm4wQUFBQUExZnV3M3Y5cS9oUUpzQWdPQUFBQUNBQUNBQUFBQUFBQWVOcGpZR1JnNE9EN3U0NkJnWFByLzZ6L0N6azNNQUJGa0FIak1RQ2FGZ2NMQUFBQUFBRUFBQUhHQUc0QUNBQUFBQUFBQWdBQkFBSUFGZ0FBQVFBQmJnQUFBQUFBQXdUREFsZ0FCUUFFQlpvRk13QUFBUjhGbWdVekFBQUQwUUJtQWZZQUFBSUxCd1lEQ0FRQ0FnVGdBQUx2UUFBZ1d3QUFBQ2dBQUFBQU1VRlRRd0JBQUEwbC9BWm0vbVlBQUFnT0FsSWdBQUdmQUFBQUFBUlNCYllBQUFBZ0FBSjQybDFWVVdoY1JSUTliOTdNdkdlNjZWS0NkUTNyV2tOcVdOb0ZLd2kxRFlZU3Qya3BKWmlXZEMxcjFEWGEycFJZZEF1aGdxd2ZFVFZLUDh4SGhXRDdGS0dsMUJiRTRJcTJLa0dyS0loK1NGTUlvZFVTUXRVdnE4R2E5ZHpKZTBGZE9KejNadTZkZCsrWk03UHFPaDRFZi80ODRDMENLb2VhL3pCcStnWUt1b0loK3hZZU1tZFI5bVpRVTgrZ2w5aXM3ME1QNThxcUdaMXFCRVdWNVZ3RGFZN3RKc2FKZm1JWHNaWTRST3dsZXVMNVhTNitEWjJ5QmxFUjlvOGdiWC9Ha0drQnpDclU5UXlxNW0zeWRtSTE2dVlOdmsraHJrckVqc1lCUGNmeFBPb0I1NnhQckVCVjEyT1d1WTE0VEplUU5lL2pqUDRTQ0xxUkltczlCdWdENkZJdlkxeHFKbS9RYTVEMWR6UnU2akd2ckt1cy9TSWkvMXZXZFpFNGlJcjZDbTI2aU5WNkZwRnFaMTU3NHpVOTZKNmpZQThpR2RmblhId2tPWDR2OHovQmdLL1oveXlPNlN4Z3Q2SkZiMEpHNTZqMWFXeFJmMkNkM3VSOW9TNlIyYjlvVHo1T0ZJbFZyT1YyK3dSN0tGSnphdXllV1o5M2tuRkY3SFE2eFFpOHhxTG81YlQ2RjFTcDhTSDE4a1NUQktMSE11NWd2ZEp2RFBzZCtsM2ZCLzhMOW51Q21ITTlKcEMrRXVTVzZuRHJzQTYzaHRRZytRVTBxKzdHb3V5UjZCUnNRelY0bE9QY0g5RW8yUS9SWkpuZnhMUWU5dnJJVjVOZXpCeXllaTE1SmZ0a3J2TUJleE12QlBzUUJyVTQ1bGQ2NEZibS9JU1VPY2t4cWVzYnNuaEs4bCtuRDdpZXZjenhTZXlXV0JmUFBIT1U2NGpYcHBaOEpQbmlLYWN0dlNScjJnSFdUQitaSHhoM0dLTmhLK3JoQTN3ZVJtZy9aZXc4Y1FOZFlUdjViKzY1YUhJR2cvb2RldUlJOWI1QUwxRVhXNER5YjZKbzdrVWswQVBFYWE2UkppL0VmcnJpL09TOHlQT1pkenJQY0p3K01pbk9UV00wYUtPbTkzT05RYlRZalJ5TEdEK05MbnVVei92cG8yUWZaNUdTNy92WHVCWjFqMzA4TDE3bUdRKzU5K0xqbE5UaDZ1RzMyRWNVcnNTSUhZTXk2OUdrLzBSVHNKNjlYbVBNZnM0Zmh3NmVwRmI3K0Q2TkhPdEpCNWY1Zm9MNXA3Q0IvYlhhSVR4dFd6RnVtNmtoZXpJZHpPdG1IekhmOGdHcTRRajEyRXU5NzBJbFZQVHBLQ3JCNzNqS2ZaZjc3VjloL2FKaER5YjFNSzdURzU4VFU4RXhkUEQ4ZGRnUjFqVEdiMDd5em9yWXcyZlVYczdpRnRUOUNmSTZGUHlYMEdTMmNieVBlajNDOHpnQkpmdnY5dUFReDk5bG5Od2JKY2NGWGFaL0RpTTBBWFc5amV2M0k3Sjk1SStweVJCN0pKc0Y5clRBMmhMUDB5UFVOKzg4dllhSTJXem12Zk1LTXZZUzc2T3ZrVGZuTVdydUpPZ2YvYjNqT2owYTBaTTVzNVZ4TVl2SHhhZmlGWHJUMVdoK1Fhai9ZbDBmOFgyT09YZXpwakxIWlMzeHczUE1lWngzVXluMlB2MlhzTndUY3NicC8xUGlDZk1iYzZvb0o1eDhLOUZGdjRndTNsMGRjajdFRTh1OFlta3ZrejFOV0h3djNwTno0dnp6UDA1cTVKMVFGeS9LZVhHZVRmYm5IbmMvWjNpK2xMc3JBNEQrUThMcUxPSHpmMnBQREkrWTRKL1hzeHlYLzZFWS9vL29EZDVEci9jOE1nS1ZScWVmUXNiaFZlVFZWYnhndDZNbXVXcWM5K3M0ZHNxNjFLQ1RQbTdWN2NBL0k4S1c3Z0FBQUhqYXZaTlpTRlZSRklhL2ZiMXBXWmFORHBrZHJjeEdtMHNiTFp0bmJiYXlzb25tT1N1emVTNGJLQXBLRThVSjA0ZXd0Qnk0RFFoaDFFTVJsSUtlaWw2Q2VtaUE2TXBxYzd3MFlOQmJHOWEvMTlxY2M3NXoxdm9QNEVaOUJLQzBvcXAxcGF6YXJoeDZYOGNvR3RFVEw1SklJNE5NY3NtamdFS0tLY0hCZlI1U3lWT2U4NEtYVkZQTGE5N3lubzk4NWl2ZmNDTEtRL21wS0JXallsV2lyY0wyeWxadFAyb1h3OU5vWS9nYmdVYXdFV0tFR1JGR25IRWpLTGlMVTBSVHZUQTBMVjNUY2pRdC93OWFCVTk0WnRHcXFMRm83L2pBSjR2MlhkUHN5bGRGcW1pMVFDVzRhTmlQR3hqZWhxOFI0S0tGLzZMSkYza2o5K1dlT0tSY3lxUlVpcVJRYmtxQjVNc055Wk5jeVpKTXlaQjBTWlBya2lvcGNsV3V5R1c1SkJmbGdpUkxrc3lWU1JJbG9YVTFkWS9yS3AwNXptd3oyMHczcjV1cDVsWHppbm5PUEdiR216NjE2VldQNmp2ODM1YTd6ZE9hS0EyNENwc3JzLzNqR2ZWM3VtSFhIbkRIZzhZMHdaT21OTk1UYWs0THZHbEpLMXJUaHJhMHd3ZGYvUENudlhaUEJ3THBxS2NZUkRDZDZFd1hRdWhLS04zb1RnL3RwMTcwSm93KzlLVWYvUm5BUUFZeG1DR0VFOEZRaGpHY0VZelUzb3RrTkdPSVlpempHTThFSmpLSnlVeGhLdE9Zemd4bUVrME1zNWpOSE9ZeWova3NJSmFGTEdJeGNTeGhxWDcvVFRxMnNFM3JIdTFpMk04QkRscGZkcGlqSE9FWXg2M3FCQ2UxbnRKeG1qUFdTVEpuT1dkbDhTelg3U2pUMlQ3V3NFbzlaQzByZGJYNXQyNnQrRXNIRHpVNFdjMTZWYzR5TmxqVk5WTFVMWFZiM1ZVbHFrZ1ZXMmZudGZkUkQ1UkQzZnM1aUR1cVZHOGIyYTUxQjF1MTdpUkI2eTUydXk3WlM2TFdUTEpkZFpiK2Q2MzFBOXV2MDdnQUFIamFYVkc3VGx0QkVOME5Ed09CeE5nZ09kb1VzNW1ReG51aEJRbkUxWTFpWkR1RjVRaHBOM0tSaTNFQkgwQ0JSQTNhcnhtZ29hUkltd1loRjBoOFFqNGhFak5yaUtJME96dXpjODZaTTB2S2thcDM2V3ZQVStja2tNTGRCczAyL1U1SXRiTUE5NlRyNjQyTXRJTUhXbXhtOU1wMSsvNExCcHZSbER0cUFPVTlieWtQR1UwN2dWcTBwLzdSL0FxRysvd2Y4enNZdERUVDlOUTZDZWtoQk9hYmNVdUQ3eG5OdXNzUCtvTFY0V0l3TUtTWXB1SXVQNlpTL3JjMDUyckxzTFdSMGJ5RE14SDV5VFJBVTJ0dEJKcisxQ0hWODNFVVM1RExwckUybUppeS9pUVR3WVhKZEZWVHRjejQyc0Zkc3JQb1lJTXF6WUVIMk1OV2VRd2VEZzhtRk5LM0pNb3NEUkgyWXF2RUNCR1RIQW81NWR6Si9xUkErVWdTeHJ4SlNqdmpoclVHeHBIWHdLQTJUN1AvUEp0TmJXOGR3dmhaSE1GM3Z4bExPdmpJaHRvWUVXSTdZaW1BQ1VSQ1JsWDVoaHJQdlN3RzVGTDd6MENVZ09YeGozK2RDTFR1MkVROGw3VjFEakZXQ0hwKzI5enl5NHE3VnJuT2kwSjNiNnBxcU5JcHpmdGV6cjdIQTU0ZUM4TkJZOEdiei92K1NvSDZQQ3l1TkdnT0JFTjZOM3Ivb3JYcWlLdThGejZ5SjlPL3NWb0FBQUI0MmtYT1QyckNVQkRIOFR5ak1mNXJvajZOaVJUU2hhdTNFSHFHeEkwaXBTQWtJSGlDTHJycFZoRmM2aFc4d3FRcjhSN2RkKzhoN0U4N25lN204NFZoNXFTdU8xSjdhMHJ1UzFZb2RjaUxpV095Si9MektlbFhESnY4a1J5enpDeXk0NVJzazFBelRqL3Q3NUs1b3dFMHQ0dzYwSmd6YWtBOVliaEFiY3lvQXU2STRRRFZpRkVCbkhkR0dhajRqTmJ0NkJ2akFXaUZ2MURrOFY5OVZPK3JaQXA3OGdIMndQNVJxTUZlSXV5QytsbllBYnV4c0ExMkxrSWZiQWZDSUU3UGxyZStXbElHdHhJby9WOUNyQXhXd2dnTUY4SWhHTTMrbUpNMlAzMkZiL2dBQUFBQUFBUW1CWHdBeFFCK0FKRUFtd0NqQUswQXNnQzRBTHdBd0FEUUFQb0E0Z0N4QUxjQXZnREtBTkVBMndEZEFPSUE1Z0R0QVBJQTlBRFlBTWdBM3dEREFKNEFqZ0JFQlJFQUFBQXNBQ3dBTEFBc0FHWUFuQUYyQWd3Q3FBTkNBMkFEaUFPd0E5b0VIQVJDQkdBRWpnU29CUFlGSWdWNEJlWUdQQWFvQnhZSE9nZTZDQ29JYWdpcUNMNEk0QWowQ1dRS0RBcEVDcXdLOWdzMEMzQUxwZ3dTREVvTWFBeVdETkFNOWcxS0RaWU42ZzR1RHBBTzVnOVFENEFQdkEvcUVKNFEwaEVBRVM0UlhCRjJFYWdSeGhIZUVnZ1NnQkxrRXlnVGtCUDBGRWdWQkJWT0ZZWVYwQllPRmlvV21CYmlGeTRYbUJnRUdFQVlxQmtFR1ZJWmZCbzZHbXdhcUJyV0d6UWJUaHV1Ryt3YjdCeFdITG9kSEIxYUhmUWVHQjRtSHRBZStoODJIMXdmcEIvd0lHWWd1aUU0SVlnaDFDSXFJcUFpMUNNdUk1UWovQ1NDSk5RbExpV2VKakFtdkNkT0tBWW9zaWtxS2FJcUdDcVdLemdyYkN2R0xDZ3NraTBjTFlBdDdDNTJMdTR2VmpBR01HQXd0REVlTWJReDdqSVlNblF5MUROS00rUTBZalRjTlVnMWhqWEVOZ2cyVERaMk5yNDNDamRhTjlBNE9EaHVPTW81TkRsU09hdzUyanBBT3A0NjdEc3VPNGc4QUR3OFBIUTh2ajBtUFV3OW9qM2VQaUkra0Q3WVAxZy9pai9HUUJwQVVrQ21RTkJCRkVGZVFZNUJ6a0pDUW5aQ3NFTDRRekJEZUVQSVJCeEVZRVM4UlRKRmlFWUFSb0pHNWtjTVIySkh4a2dLU0haSXVra3lTV1JKbmtuc1NpUktjRXFhU3dSTFNFdDRTN1JNS0V4YVRKUk0yazBTVFZwTnBrMzRUanBPaWs3MFQwcFB3bEJrVU9CUkdsRnFVZEpTQ2xKa1VxNVREbE5xVTlKVUZGUnNWT0JWSEZXdVZnaFdhbGJNVjBaWHVGZitXRUpZcGxrR1dhUlovbHEwV3pKY0FGekdYUnhkZmwzY1hpaGVabDZvWHdSZllsL29ZR2hnNW1GY1lvcGpybVJrWk5SbExHV0daYnhsN0dab1pwNW0xR2d3YU5KcFlHbmlha1pxb21zQ2EzNXJyR3ZhYkI1c1ltektiVEp0aW0za2JvUnZJRzl1Yjdadi9uQkVjSjV3K25FNmNYaHh2bklLY2t4eWpuTDhjMmgwREhTbWRTWjFvSFhZZGhSMlFuWjJkc1ozR0hkYWQ1eDM3SGc4ZUlwNDJuazZlYUI1NW5vb2VyQjdOSHZTZkdoOGhuMEVmWUo5N241U2ZweCs2bjgrZjVKLzJvQWlnSHFBeW9Fb2dZS0JvSUlVZ3J5RE1vUG1oRHFFNW9WWWhmQ0dVb2EwaDA2SDdvaHdpUEtKcElwUWlxaUsvSXRRaTZLTUlJeWtqU3FOdEk0U2psNk8rSStFa0I2UXFwRDBrVHFSc3BJcWtvYVMzcE5hazlxVUNKUTZsTWlWVkpYSWxrQ1dtSmIwbHp5WGdKZUFsNENYZ0plQWw0Q1hnSmVBbDRDWGdKZUFsNENYanBlY2w2cVh3cGZhbUFLWUtKaE9tSkNZMEprT21UeVptSm1ZbWI2WjVKbmttbWFhenBydUFBQjQydVI5Q1dBVTFiSjJuKzdaOTU0dE05a25rd1VJWkdBbUlVU1JUUkJSTmxGUlJBRVJ4UlZRUVZaQkJGRmtVUkVYUk1BZ2lJcEk5eVNBZ01xaWlIclY2eHFWQ3k2Z1NGQlFyenRrT24vVk9kMHprd1gwdnZmLzc5MzMvdXNOVENaaCtsU2RPbFZmZmFkT0hZN25lbk1jUDBaL01TZHdScTVNSmx5a2E5eW9LemdXbFEzNi9WM2pBZzh2T1ZuQXQvWDRkdHhvQ0RkMGpSTjhQeWFHeEtLUUdPck41eXVGNUZIbFd2M0ZKOWIzMXIzTndVZHlkelIrUlZib1ozQld6c21kd2NWdFBGY3FtU08xZ29OejZFcUo1SXBJWEoxa2k5WWFzamkvcmxUOVM3SkhaWkdVY3JKTkVOMlNvNnBqcDhyeXpyR28zK2MxaEF1S1BTRWhmTWY1ZlhyM08rL3MzdjJ0eE5KcDNaUys1dzNvM1h2d0FQMzVEV1g0VEdFMnZ3K2VpYkwwNE9JY1BsTVh3MmVhNGJNTlVTS1pJcEpRVjh1N2NCQVM3NUtOQkI1TnY1UE5wRlEyOHFKYkpycXFLcTVqSjA5TUNCUDR1dU96a3Z2SlJaKzN1VjgvUTlHVGs0cWVvL0oxNERqZFh2MDBMb3ZMSStkdzhVeU9LNDM3L01GWUxDWnhrUnB2UmlDck1DTW1FMk45RFM5bTV4Um1SQ1ZkcEVadzVlYmgyM3A0MjJDMjJQRnRZeVJ1c3RyZzN4RXBQeUpsMXNsQlY3MFVwRU9UVGE3NnVORmtLYTNwWWRTWlMydjhKcU9wVlBiQm16NC92dW56bUVzbGswdTJ3cS9hWFBWeWlKUktuVE8zZGR2KzB3V2NyOVN5cmR1WFAzdndoWlRwcXVFempaN1NHb0grYWNBLzRSazE1cUFKWHZoZE5SYS9GVjc0WERWMm53MSt3VVgvRk9tZlh2d1RmeWVEL2c3OHF3RDlWL0NaV2RyblpHdWZrNE8vVTVPci9XWWV2aS8wY1BFQ1N1c1NVUzNaT2JsNVpjMytKL1hJUkkxWGhEeGgrSW9KTWZ6eWhZUVFmSVU5WWZpcWpIbkNIWWlyVWlIQkFSc0cvSFBBdWdIL1ZJNlhFMEU1TUdEOWdPTUQxdlY3NDRmT1A1QUhWaE5YTlhsWXVSNi9xcFVmVml2anlRUDRCZStEVmR6UXVGaG8wSC9JNVhNbE1IK1BjbEplUk1xT3lUcHp2ZFFtR3MvVG9VN3pja0duN29qa2pVaEZNZGxwcVFjampUdTkrQ09uM1F5V1d4YVJ6SFVTRjVWRHpub3A1Skp6U1dsY1p5dU1ScU8xT2RTUzRnNXZHL2hPeW5ISjdXQmlnczU2T1lKL3R3UGJjb3RnVzdJdUQ2eWJxNUxjNG1aaTlnVkRoUjBLTTZwa3B4ZmVGZEhtSzNKSmhsaFNSaXJLTzFkV3hIeitER054aVppUlMyQVpHSDNoaW1LUDE1OGhPZ2pwWEZGZVhITERrQU9YREY3NXdOK2xPMTdaMlBmaGgvcHRYdmkzblhjY3Y2RDNzQUdEU2M0ekE0ZFgvNjFOSlNGamM3cytQV1B1ZWsvMUtzTzVVbGVyOG1UMk9ZOVBXTERKOSs2Yk91R1J5bjVoMHM3YXQrRzc0T1F1NXhhZ2ZldTVDeHFQR1FicTcrY3NuSmNMY0dIUTF4b3U3a01yRDhFZmNvbWhQdTZIOVJYbjRRL1piYWl2TlRsQ3ZCMU1GbDVtbGRLWFdZWjZxaTZ1VHJhNjZ5V3JTM2FCSHZSaXZhUjN5VUY0V1FqdkZycmt0dkF5VjJSYWNsbEZkOXpFKzZxcXFpUzlLQVdxNU1JZ3FNVmZKYlVWNDFtaGpDclVuNmxFZE5jRWN3dmJvdHJjV2ZDTjN1cmk0QnV3SVZkSWN4ZVZYbjhzS3JyQ0JRWVBpWmxKYXorNGdFUWZXYjNxc1NWUGJPL1NmZGFzN2wxR0NaYnREYitRbDBoczZab25IbDFTdmIxTGo1a3plM1FSUGlWYnZ2cmd3R2VIUDdodklja2lXUXRQUHFhZmNXSXVlWXBzT2ZqUi9nT0g2dTViVEhKSTVnSU9iT3p5eG1QNjUwQnZPVnd4RitXV2NQRU0xRmtXNml4a3E0K2JVVjBkemFDWUdGVk1ickJleW5WSkpmbDFvbXp3MVV1R2lGeml3N2ZrRHJpbzRhWE5KYnZocFNkUUw1ZkQzeVc1b0E2aFN1b2cxcHF6UW9WT2tGcXl1YVV3V3BQc0NvRGFQRzdabDRGcUNtWEFyd2FxcEk3aUpzNWc4eFcyWXhvQ282S214Znlxa1hTdWpQRkdFaXB4RUUwM2xjUkIwTWE2d2E4Vmc1b3VuLzdFOEY3dlNzL3V2dk5STW1CQWVYM3ZCMG0rOHRsOW96KzdlMy9EOFhrVHBCbktBOWNNR052ampCc3Z2YWhQLzJGazR1M2JyN2ord1VGTG5sbXo4S2FhWWNxT3NYdVY3NTlUNmhjTUd2VGVuaEczWFVPdTcza0xQN3ZyalYzUHVxRlh0L01IY2dUOU5obEIvWFlCODlxcXl5YmdNMVArV3RaRFpHQitHWDB5dW1QNHQ0T1VOL2h5K0xkMnNGSUlWeHo4SXdmVnJORmJMenZadnloM1Y4WU12TS9yemdnWDg0TWVXdmpxWFlzWHozMWwwVkkrU3lIYm45Nms5UGoycU5Jdi9pU3BoYzg3RXo0dlgvczhUdnM4YTUyc1MzMWV6Ty8yZVhsanVMTzdvcHcvODlWRlM1Y3VldVd1Ull2MU01NVd6bTVJS1AycmE4am1vOStSbHpuNHZMNzhCY0pSZlIzbmdEZ29DUkVpT1NPNERQQmpLdlZDVENqSzBIdU1WbExpNlZ0QXJtdnpqeEp5YzVheTd1Q09WZmZ0K1V4UTNydVdqRmNldVBhOUxPV2pzYVNQc24wcy9FUDR6TXU1ZlRxRGJnbkUxaUVjUkJ2SkNJSEdCS3NxR3VjSU9pck9ZaTZORXc1ZkVnRjlsaTBpV2Vva1BpcWJJYmJvb25HekJYOW1Oc0t2V2N6NDBzS1pTMlU3RzFaRlNJVEk3Z3VKWWZGeU1uTURtYVhNM3NDUFdrL3VWcWF1VjZhUmVlZ2ZDTmUxVVNBTHVhODRBMWVFWTZqbDFSa3pSaVFlbEJXc2wwMWdyVG9JcUpJQncya0d6RUdHUWVoNmR2NW56c2kwQkJFKzg4ZVZiOWhuOVNFYitSZy9uczQvZkpaTWJQWDRoZE12Y3hDaGhTejhiRzMrSzBLK1B1UTQyYmh6Si81YmlqT0lHWFJSeHFVQVJoSm4yTkFXbW9JTVZjNTBaSEZIdno3bjlEdXZUNTkrVTg0NWYrRFp2UWNQWXVOeVFxRC9udHFsSDJ3QjF6R2hCZ0hEWW1PSmtSaHg4cllQRTcrZ1A2QzQ0S0xHWXpxSEh1Y21BN0JWM0l3TDMybXRwNllwKzZ3Z1ZJQ2FweTJRWE5vR2lCRG9EdDAyaUJCbUFaZXV6d2t2RFZ3VjlXanVXTlF0dXZod0FlOXh3ZXJzTExwd1VWNzAzWS9mL2hQLysvcTJPMmRQbVRMN3p0djRsOG10NUVybFBtV0Zza1JaUWNhVDBjcVh2NTRBaDVYWjhCdVZaeWtNOEJqSVk0SDRGOWVsNUxGR0pGMmRMTUF3YkRBTVFZY2d5TWhBRUltQkdaUlhPb2h4S1ZueDRrR1R2K2NXWFNYcGMyS3VjTy9xVVlIS2gram5EZ1VzNUFDZmw4VmR5UFFrQjRYNnVBc2xOdU0wWmtja1E1M3NjZGJIUFFhME5rOFdHSjdCZ3k4TmFIZzVDUG1DSEpnS3FaTE1ZdHhnODZEL2Q3a2xPeWdnVmtHNjhjd1JHVXU2RVRwcER1SWt2cEJ2S0xtKyt0cU90MXc5K0pHcnBrMDZjUHVyMy9WZXRQWW4vckgxNU1ZMTg2ZjJHVG11NjhDSHJycnc3UTBqMTI5YS9wMTVMeDNyaFRBL1BJeTFtTHVlaXhmaFdIV1crbmlBUmpGcmZhM05XaFNBMEdXendMQkxZR1hWeVFYZ29aM29uck1DOVhGbkZnVUNWaGgwR3h5MHJvaEZjcXNvazRJcTlNUnlibDRWOWNXK0xQZzdnS0dMUlhTWU9CQ2lsRlRFOGpWaE9yT1FaUFJoYU5lRkNpNGM5dnJsVDFiSGQweWJUZ1pQdW1Yd2cxZVAzMFc0RDQ4L3Z1aVpaNVNEeXUvMVZhKzM3emgxMW9UcnR4d1pQcnFzNThyRlc1NjRLNTVuOUQrOTRNMzkxUFpBSEYwUC9TeVlYemMzaHRrZWpjKzFuTlVNQVJtd3NNeFo2eWtROWxBVVk0dktKZ2d4UWpSdW9tN0FaSUNKTVZQQWFjYUo4U0lHTlVORTVwMHVHbm10NmlUeG91UkUyNndBKzRqNXdtQWprQWlVVjRZTnhpTCt6djB2dmJSZnVZQnNOQnV6emlEUjU0VlZEZU8ySysrUTZIWnk1WXRUdWc5bmEydEM0ekZCQVZ2TTVtWndMRHpxWUpVNGNCNUVvYjdXWjg1eTJOVUZrMFBuSVFBQk1KY0IzTzdiVHhSU1hPc29jMGoyblhwWnpQN0RJYmwzY3JMZFhWWkdhdXdPMGEzQ1NpSUhqR0RPT0h5WXJTdzJXMkJpeEFhaE1uMW1RamdoSGdTY3FvbkJmRXdZK09iUVphdVVIUjNtUnEvdXpIK2FPSjVmTUtydmg3OHAzeWlKYjZ2ZWF0L3hucmtuM2RZeitlZmZVTllZbkYvcy9ySUI1dUF5c0MrdmZqR3Mva0swTUM5S2xnVVdSbkdTMFZKZjZ3aDVFUnc1RUFNVVVWY0Fra21XcUJTZ1dGSVcvZlZ5TVNLaWdPaXVOVnA1aHhkRHZDaktlaDBONmlDRHpBR01sQnlpWkttU2pHNUpyK0tlREIrYWxSQlRCUUNIVWN6VGVONlpHcHlEWE1hdnVyNWZ2MUVIRDFwc0haNGN0NlB1dDQ4ZStYeksxdy9lTW5IbWJiZjFtOTZYSHlwMEVWLzAvVlA1ZGNEUW8yOGNhT1FlSUw2TDc5bjY4SUtwOTNhN2ljWXlzQzgzNUR3R1FOQnh5SU5LcWJNVzZ0SHJvN3ZuSUgrazZJUjVhUkltZllXL0pUNzVtUy9WMWV4ZGViSlFWNE56TDZnK2NqRjQxVERYTWFtbFRKTUtqOHBNOEltZHFHb3lFQkxoNGl1RUZ4a3U5QlN5Q0M5RmwyVER0MHZoZFdrRWNaSWNoUitWRm9ydVRXYkJteGx5Z05JNHVTd1R2Z2ZzSTRiYXRJSjk5SFRaYWFBSGxSU2h3QWZRdDRaOExwcjc4T3liZnRpMXQxNXBlR3BCSTdmdnE0WlBGazJaZnUrczJWbXpKcFMxR3p4cTRzamJSbythUk1aTTJ0NXZ3UG9iSHQzOHdySlA3aGl5WmNMejc3MjZmY3k0VzBZUHZLUFNWam1QdnlrNnNHZUgySVR6aDR3Y1NkY3AraUFieUIrQUZRdlNXMmlNTUtzeElneGV5Sjl0RWNCRy9HZ2p4VlFSUVQ5TkN2TmdBYmlqc2hGY2RRbm1GS0J1MldZSFk4Z1RheTFPajErZ1l2c2hlb0RybExKRnlWMGxoZDJ5a1VXU2NvZ2tBRjFjWEtpZ3BBSkY5b1JUb0Eva0w0TnZEQmYrK3RIRG4wOVY0b3AwUjVlaFE3Lyt3bXJyVW4zRHRvOE9USng4eS9KZWt3ZE11bDE0ZmovUkxWR083bFpHSzJPZEx3VitKY2FoQTQ2OFBlWGUrY012ZnVpU1pWcnVyenNMWXFDZnEweUx5cEJVMVRyVXdKelJsQUNRUk8yVkhHZ1Juc1h5bHBGNjhibDkwd08yTVBVQlpBSUdVZjBpTmxrT3p6ZHdJbmNXQjRpcjFxdysxWTJ1cE5aR0gxU2pzMkU2ellOLzV5TVVzWGhVeEJJM21KMVZWU25VWWlXcEFhZ0E1bXIxK1JxUTBUMlRmRDdpc3c4Qm4yMkQ1M1BnSVgxbTRydGNlRGJSZzkvSjN6eVJmUFNpc2xrNThCS09jelJaSlNqQ201U3Z5R1RJQjJBY29ndGNBYVlJY2hJcTRpSHdOVnA0dkdHTThEaFp0WDQ5bWZYY2MxenpaMVZXbUFrODduSitaNktIOE95SEw4SDZPKzlGcFhRaTFZbXo4U3ZoUEJxamFlU2o3aWdBd2FBd1VwdXJLZ2ZpWFhaZGJZZ3B4eEhLQnVYWTNUVEg5V0hlQm1zTVlwNk16cldXZHdkeUN6SDdBcGpvamxzOFpob2RBcENieFBYMkxBemVFQ0U0dExuT2FydzJPaUJGQ21OR3E2MHRveWVsVmVjcm43OTRvTjNRYXkvcittTC9VYmYydW5ITTVjdlB1MmNSem5UdmZ2cndUVnRYbnp2aG1pSG5YRDZ3dE50MUM4OGZmdFU1Z3k4cEx6cXBQTkMvVCsvQkF4a2ZjMFBqRllhcCtqbGNCZGVkVzh6RnkzQk54U0JKMWZFc1c2MzFkSW5wSUFibXgyU1BIcFA2MnVCWitJWWMxSU91ZTlCRlZncm91TlFsKzBIS3pwQ2xkbmJKWVViQ3lEM2g3M0JuMGQzRGJOTjVnaVZsSFdObk1nY1RnNVhXQ1hJdVVlcFlKWi9WUlhSdk5uRXV2ek5jaWs0N0tFclpiTjBWeHFJNk42b0JaQzFoaTQ1NW9RekI1MDJ1UFIyUGF6TmE2VE9FOHprQzczc3FVVkUzZkV4dS8vRmQwcWQyNklxeDUwL3cyQ0wzRGwxUmMvejFmdkUrdmpIOWg4MzcvWW0zbGZlZklPMkkvNlBEYng0RDhIY3JINU8yaXJheitreWZ6OGRPa0x2L3ZrSFo5Zjc4UTdNdTZIUCsrVyt1ZisyM3pBeWxaOGF5Vng5WisvdmR6eWl2dmFzY1ZUNjhaT1VRTW90TStJSUVEN3VlcFBwRUVzQ3JudzJXNmVUYU0xUW5DVEVLR0dzTkpvNkE1Z3pvK1YwUnh0Z1JrOGpnV2lmQXhHRWhKSGhDUWhrcE1SaDUrd25lL3ZQQ3hEZnozeUxMNWppamxzeW9mdmFKV1dTZU1vM3ZUMllXcnkyWnZCQld3RmFJTGVzQUR6akJLNGE0c1NxT2ROblV5QW01YzIwd3dHSGtEQ0ltS0tBVDVvTElHWXhLTGhkRktyYk1laWtIbzRJZTFqTE9YSTRMQWJXSm1pYThsR3c0SlFCb3dEeERMR3hDb3BPdlMwR3djRkVLcGFrdnRwSnFVa0Q0V1pPWExsQisvMWI1OXVmN2x6eTA3TWlCKytmZTkvaHIraG5QYkpuK3BNK1N0WGJoUzNXN3hrMGVkOTMyNFRkZE5ZeXV5NG5nNDFmQ2VndUFCNHI3cVN5Q2FvMFcxRnVRQ21EUHJKY3pVWDB1UDR6UFd5Vlp4RGhucE9oWGg0bVRaandaUnJRUE1BL3c0SjJaZlV4OGduUjg2K010Ri9aZGVlbWVRL3ZldVd6ZFpXdmZVLzZtYk9aZi9nYzVkK1B3SFFVeDVjaHZpcUw4RnM3ZTA0MU13amtGSGVzam9HTVRhTGtMRnpkeERLQXpEVHR0OVNvdEs1dEJyV1lYVFFiME1FQTZ2MDZBZ1VtVmNTTFlhVWtzWDNTRndsdEpuQXdpazVTWnlrTlBQa2xPS20xQUxjb2p5Z3ZLV3VYK1hieEFmbWQrQ3A0dGZFRDU0TDdxM0pwQkgyaE9zZzdtVnM5TVNvK0RzQ1VIZ2FrcVRXUE5nTGdoZjJVNXE1ckFzU1NWZlcwVk1oTnY4V0xpZStRQ2RpdDM3bFQ2dnBKNjdudndYRE5saExXY2h6N1RwS2ZQTk9GMFdOZ3puZW5QaE5SWmZhQzEyUU8zQ2dIMk9IeFl2MWNTTzdua25EZkFuR2R5VTdoNEFHVjAyTlNvRGcrcGRYc0NHTlhkK0x3c1JvdGxKbWt4SDJSSExoOCsxK1dHSjJaclhKaGdRcUFxK1VUWm9FZERkZ0FzbEh4VnNzZU5PTkFLUHpLSllDaVNvT0ZBY0NBWlJuQWJIRFdXU2pFRStUdzRIREFZTW84TTNmL3E0UFhydjFST2ZudGd3a3psQUsrZlZYK1BzbHQ1Q2xMSEM4bXNpM2NNVWc3L29qUXFQMmVUNi9Za2VyUXJJRk5WSGVwdGRPNjZxNTdBeUR5QnBJL1ZDaGFxUlVGSXpwd1ZabzZQb21DQUNVR2ZzaEdndXpabnVHbUFPU1VvOFRCLzkrSERpYW42R1lsZGZQY1RjL21waWJ1VGMwWlcwYnc3MUN6dnhvOFg0TlB3UzUvOHhLMkgxZlNiSTQzWEsxUElNdmkzTnE0RFlGUWNveVVpOHpnNE84MXljU3dPTkdqZXdqeUNuZ1VxSTBDZ0N2Z3NERWNsRDE5dzVrdUgzMzUxUkkrTjN1UDZDMDVzK2ZpcmdEb3VYVDE4dGdOUUs5T0RSZFdESVliRURvN09RWVduRkE5Rnc3SmdxNnBpdyt4Y1NVS2NrWVNJRVVZODRnb3luZWlWQjU3Z2M1VmZsYjUzZ3hhdW5IZzkyYVVNZnFIaE8zN0crTVJQS2Z2OUVaNnAxN3d3YWxyVmgwSFRSMXlnRml2b3dYS01LVVg3UU1WRDlETk85dHVUL0N3RDhteGVicGo2V1VaSExEbVRSUExSei9ONjZ5VXZuVHZaQ0xrSVJrTXZDdUlTcWJIVjhIb0haUjJOREhveU1lT0N6VlhGQkExQkFFRHlxTnhkR1FZSUVuYjd4SzJrTjVtbkowdEk3d05XblVrWi9qZmxPcE1JQTN0U2R3WE0rK2JyeU9Ed3lYRzZwY3JKcnhJWHEvWjJQb3hUNUlZMDA3TXBSakVjakZMMFloWkFkMGtzWGdiZHhDUWFOb295ajB2REF1clhhVU5NemdRTXNKakh1UTZSY0lZZlI1ZkJTd2JlOW9GeU9ESFFwSGZBd05iNWlXOGcvOFdKdWJvUjNXb2VUQlF6akFIclcvOUljMjVIMExnZEljWHRaS1c0bmN3MGJrY3dKN2tkemxDbHJsYm1UUE81ZEo1bklybUVkQ05WNUdMbFdlVTFXSi9yZjM3dm5iZmUrL3RiZjMrZjMwMkdnN085UzNrRy9wdExwcExMbEFibEYySW1Cc0lUcS9JTHAvcDUzWERLODNpNFh1b0tvajdlQTE3UGJLVlJsQkl6WGpwY0M1aXNOU3BaWE1odjB1RHBRK3YxV01VbVFWSVhDZ2RKS2l3dUpVWmlWTDVRZmwweVRWcjc0QXBZcjUrOHQvOW80aWYrbmVsenBreGgrbExpVkY5T3hnelpVVjhlVFY5QmdURkRHTVpCWHk2R3UxQmZtT1Q1SVY3WENGYWJHUzNOZ0prdURNZ09BekxUR041VWZVaGZvNGRyVllXdmJDT0RJUzcrVm5RS1BUWnl5cE45bFlmSm1hMHBrK215anZvVEh6ZGN0VVpUaktuVEIrcTAycWs2clFoSy9FbG16eDVGQXhCVmRXYWdjYUlCV0l4c1c4TU0wdGhSdlViMDdHbEtkdWxSa25RMUx5Sk9ZbEMrSnd1Vms0cDBjTlVUOXk5ZjhZaCt4bHR2SzMrTVR6eklkMHI4bmY5KzhxVEoxOUwxUGFyeG1IQUk0azhoZHkwWEQzTXN6REVlamxwblVVU3kxOGtCQ0hJQnRuTHluWXhyQ0tCbXJiaHVOdWtzTGw5MkdMV2U3NDY3UFRrVTJPdkNqRGp4aVRYRTdzbkhuN3Jja0Z1bU0xc2xhbUpOZzQvQmgxbDBMay96NjFHalBybmluanNuYjl1NThzVDdiKzd0dC8zQjhiZVdYVC8vc2Z0N0t6OGVQMTc1YVlmeXNaY09ISGYrd0wwTHBUZUhiUjkwNWVET0EvdFU5Wml3Y09UMmowQ21iTkQvbWFCL0krNGlHNUx4bXhPUXRxSWJ1b1k2V1E4dVVFK3BSYjJBMUtJK1NTMm1NaWgwU2RtNlBPV3FyM1ZiOXV3NTJVKzNoZXBzQTZ4cFBmVTFsVnpjaVRvenFQNVZNaWVkRGJoWVNXQXVFWUliZFRZbTNLRjJVbzRVbzRZL2xnK3pKbnBwcE4xd3VQcHAwdnZydXhva21MVFB5RS9DL0laN25sOUxMaEltTjl5NnZING04Y0p6T2JwL2pIWUZNYzZHY25IYU0rMFJGcUU0bTdvQXhSaWhuRVFsUXV2dlNGRkd1Y2xXN2lKRnh4WGZQL1V6R2g3cC9tckhmanZMaEt2VkdBaWZ5Ums3VTI2dGdYRnJraGlqSDE5RFRHYnczVEhLcVlGY0JISmZ3cGE5SzBXdjdmcm9oN2VSWG5OSW5FdkszZ20vSWZFN3Q1MTE1UHRYOFYyOVpDcHpTTWFkY29ibkR5bTRjOXZ1OGNmbnN2Zk44TDVscCt6TCtVUHk3S3p4K2p5ZTBtM2RldjhZZzU5YTJiNXhocWMwRG4vbTM1dC9iOWdBZVdSVkhINHI5UjNYdzhJYkxaNWd0dGVYRVVqdERwTWVOdDVvTXJmOGdjcndPUWtzTFRFTERaWExnbENrcy9scEtQTEVQTGlIVlVuLzdneC9RVjRDS1Fua29rSllzQjE5UGVLenRITi85ZFhSZ2lKSDVldEhsQ1YvSEhlVlFRUjFIam14Q2JUNnpwNUhocnpSWFNodmVQMldyK1ovSkhROE1WZm9VL2xPMjI2dmRtell3ZStnZXRiQkhMNUNjVkZ4VTg5QW82a3RRa0dQekdQczBWbG83REdUa0ptd1AzWGtQV1VBMXdpUnNjL3ZTai95aWZLN1VxMnM1RC9oMXlTTzhaN0VwWW4yZkxmRWJ2b2N0SldGRkxjRDdqQW1iVVdBaDVncE4ycUF5Yk9nOXpTQ3hmQ29CL1lDVFFlZVI4RDBUNUQrcFA4SnBUMUFwY1FzZm5iRG1zUVhmQkErdXp0OGRudUtqOHMwVEtEbEtRSUR4aFQ5eWtiRy9NbzZRV1NKU2F5Q2hKQ1lDUG02ODY4bUJndDdFbWZ3KzFicEFudFduL3hXeFJ0TGxUZjRTK25haGJYRllMZXBIbWtPbGQvQXJSbGpGbWZCV295b3JQZldhOThKVVczaEFvZ0ppekhmVXZMcXI3OHFieGhxbmpueHhMTXQ5MllFVFNkcGV6TTQzYzZQZU91SFNXeklkVkxlSUQvUjhVQXV3RVNFOFJnak1xZU94MWdIajBZZUNnZGhjTW5FQStzRFBJeExHNWhSNDJReUFNTUNzQTUxK3ZWWHNsdnB0a2cvNnBrL0J1QXpzbmxlcDlQUG9keVRDdE5VY3BUdXBwQ3dtV1NUMVpQSWU5c1VXZm1VNTRYWkRiUDR4eExYSUhadFVONFJCamNPQXBreWNLOVFCclNKWDJsQ0djR1A2WVNMR3A2VFozT0VYSzViSjVUcEQ4TGN0ZUhnS2JnSFowY2loeVl6dFhxMmEwWm5qemZTMmV2WWlWU0V3Slg0d21Yd3I0bWhjR2E3UjN1OXFYL0hlL2JHVG9FbzVhU0dRZ3o1aDY2SzhrVFRHVE1iRDZKWjVKbnE0MDZDcVl5cHZsWW9ERG9SOU92Wk5nbTRrbXh3SmRrdXVZQWhmcmVUa1VYWmFQdFd3RjFTZ1JoM0JrMll5cmh4VDRTVDg3endJeCtzVktrUUVUaHpxQkNEbkNLZ2NrclZkaWROZDMzRWNFazZYM2tXY2twRGZ6NnhaZVNZQ3g3dTAyL29POFBmL0h0MW1YSEE0MU5YU045ZWRQRzBoKzVaOVFEcHVPWnBvNkhxNnFzNzVsZDNpTWd2SlNxV1hubk9NNC8ySFRCL3h1VUd3MGlRdHhweXRqSDZPa0JLZWR4VktsYWlZU0REVWg4M283elpGalFDV3AyRDZOaEpreHNBeUpsSU9RUm8xUTBGeUhGWWZTaGZwaWdqZmNqSkdSd3Q2RUFhRnZJTXM3cHNhSTVoakhYV2tFcEoyT2hoL0N0V0pCaXJENXA0eXczdnYvYlpGNisvT2Q3WnJtcjZnaWt6ZnI5bkNxK3ZVMWEwV2U1YkNZaXJBYUxLZ1FkbThyN2R6NzljUzY2dmZoSHRialRNMjJLWU54L3lEUjRVd0k2N2puVENVdGdFb0I2aUVVQWZIaGliQy9GOG5ETWcyWm1XUUxJWW5pL1NVZ0FmYXB3ZlRReS9QejJ2OTMxWEtOL2RPL2VSZVYzdkhmM2pDZDVPYkNTLzIrWXV5cEthbXZQM2hQTklFRGxOMEdjYjBLY2I5SG1ER3RsY09CeS9SUjFPRHVqVG5OU25CMEtyaDJXS3dhaHNjVEo5bW1CNHRZTEQ1YzlCckdFUklib0hLQkx4STR5eU8yQzhPV2cxTUdwWmIwaHVrMmJFaWhIWGc1MFljTGVVcXJXU0dkSG9nM3ZmRzJkMUhaSkxyRGUrLzlyblIyNi9mY0VzZnM2Q3liTjVrZWhKZVBtdHZjaWNFKzBXckNUNWhKTzNydGlZLzhZenV6aFZIZ2ZvMVFzcjRob3U3a1pSckdaVmxDQXNCWi9KalZtOXo1aUVzeVlReVJmRndpeUthUDBxb2pWaGxtUjFvNjROb3V5Z0ptSjFVeFNCT2J3RDRKV2JjYVk0QmY0Y0VxTFFpczBBNXdsUmRuNDBFUTY5LzNPaXEzN0YvU05XWDNIaE16ZitydFIvUnc3eTAyKzRjVFp2aGFEU3J2R0xhY3VmS215N3BVMCtRTWxKYysrK2gvbStBc2dqUS9vdndENUdxYXVhTG1ZM091Um9uTWZnWlkzSUJnc3pGUyt0RnZDQXJUdWljUSt0ZnZLSWdLeThkTlBXaThpS21wSFR6ZllEcllocEpZTmJNdEc5bjhvMEpBaHlVT3hWOEx5OGFmTEVyaGYySDNBT0VaVEVJV0g2ZGVmMGVYRlR5ZnFza1NQN3JHKzRTNWhPOTRiOFNodGRBZWk3bE92Q25jMjlBQnJIWWZiVVFVNGFaVVB1cWErWDJrYmtpS0ZlNmh5UkMyejFVbFpFN29xZXFIZEVzdFhKVlQ0UUNXbkE5dUM5cTF4U0hxMnRjZFBhbWp3M3ZpVjNROHpycTYrSkJycVpTdVZpeUIvN3dEdFY3ZFVjVGU2V0o3bzNaem5EYlNOZGV5TExIWWhTMG9XVE8wZmdWNG81NnMrd0NpZkxMUnR3djdjcmxiK25PKzRMMkNqMnlOQjJtcEw3VFJraG41R1djTUdTQjNqc1A1T291NHlwN2FkU1VtQ2dSc3RNMWo5amZJY3p6dTUxNFRYNzN1aHdWWkJNMkJ3TUhkd2JhOXV2OS9DdDBtYmxZK1diVDc5K2M4N2tyYlZYelZ0LzVTMVhYalBxMVN1dkdqMUdIajB2MDNOeHBPdVF0dUhxR3phOGJEZk1LQWlOcmx6em9yRkQxNkxDaHhmVnZycnNzWDZEcnIra3o1bkRoYUl4Tjd4MzdZVHh6RDZxQVFmMGhYWHI0d2FvV01ZV1kvNVBWUDBmOHlBKzV2OThMZ1Ezc3MzSnNoc2ZSNkdxWkFkTjB5VFhMQ2FUUi9CM1J0eVRCSUFjRnFsZ1BySDZvTTFadHVZbWN1ZkJxMjVjZkJmNHRyc3VIOXYvWW1WNm9qKy9hUHJVWjE5UC9JaHJieWtNN0FIOVM3U0d0RnoxSlhaQ0MwbGx3Y0hvU2h1dHhYTTZjVnViSmx6T1pCVUZEU0twNmxFWXlOSmUzYzdzMWV2TWJyM3NCL1hkeityWjg2d3pldlU2Y1ZKWGZISWY1cXVOQzVVMjlIazJMb0Q1dlo2bzdCRW93QitSWFE1RzIrcnFzRXpWQ0UvMFJHa1FNR0xCaE11UFlqY2psWVIwVW9ta0RXWml6OTczSDN4dTlUVm5FNU0ySk9XZjRwTzYxU2NIclhrbVlHaFV4NmJPeTNCYVAzUkdpZ3N4NHNoSUpNazVPVFhPU1haUXNFbVpRaU45bVdTZmpMRktoSjNJUGxWL1lUUGNRWG9TblhJUjJhdjhwcXlmb2E5TGxMeTFpZ3hWdWlSV2svZXZVWlpxTmtIbXdMTUY4T1hzMmZoTWxZV0RtY2V2RkF0WGZWQmZkNktkK3U4TUw4TWFEbk1UVlV3cFppTFBCS05tUTdmSDVEeFVLaVJ3aGZUVHd2Qkp2S3RlQ3J2a0xKQWlFd1RLWkFTS0NEOHB3dDBYckNUU3dZb1RNV25PaEZ6YVRPc3NKRHZTTzNuSUZ1ak1GcnJMQzRQSm9KdmdHVEVOT0doMmx6SkFPZC9hL3VtcmZ4bnNqS3dmOS9MekI2OFlQV2Zhb2N0SDN6bE5WN3pnL0F2WERicDA1eDZ3eGZ1bVRWbjdUT0p0L1B2WjF4TGZKOWNKeU9iaEJxZHhVNXBrV0RDcTBTb2VWU1lQSzlERjBJYjdhQjVWRUNzS0FrTkhOZ2hKcXRTNG15d1VHR2RIK1FZeUV4YktmWFBwNExSVjhzeGVISkVXb3diQm1KQ2pTUEpTV3JqMVdKTFIzNDdNQktNbERBR1ZsckFuZVNsUGVzMFJSQ0RPNStMQ0JXV2swaFZDb2g5amovbkh3OFN1L0hMOG9hK21IeUV1ZVBuajRqdDRIK0ZKZ2ZMeFNjQWwrK2MxUEtYY1R5YVFHeW1XckFaZlBvYnFLaCt4Z0YyRFZTbDFJUmJnd0taQ21zYkF5OHU4U0pXR1N3dnhTb0dxdExpZUZxRWd2akpTM2pIRHJsWjJJQmF3VkVtRVdUN055UDBaNlFqTDd3dVNWQ0dFd1ZlOXhSaXdYZmZoYTU5OXVmZk44UTdIOUFXVFpzMmNObStHMGthdjVFNm9waEFMaEhuZzdteGxnSEJzOS9NNzQvRVhWbTVRZFEweXRhRjRJSjhicitLQkRNQURKcFNKS2p3WFpMSW1aZkloR0tBV0lHVlNmSU04bXduQ2tDbENKYlA2RU9tNDNCbTVpSFJNNEQ4WmRsU0JRUzVGT1NaMUx3Z3hEa2hXU1l1eU9sY3lsT09pV0ZnRE9XTldkamNGWGp4a0V1eGo5cjM2K1pHR3hUUHVXRHgxRm9BY2dSU2RkOUdDRXp6WjNXNUVjQ1VKY1kzSzBqWHJ3bnMyN05UV3V0QWU1SEp4WFRYT1BUbExOanVZa01pb09tYlVkR202bUNXRERkdGEyTEJHQTRFQjUxb3JuaDNkdTcyL1kvbmRUK3VLdDQ4Y2IzbmZKaTlLZk1UaXpnakFyVGZBaDRUUVFtZ2RDSUFxRmJlYXRJMCs4QlN5eFU5Vmw2V1d5T0QrbmdXalRqNzZoRTJDeWU0TjV0RktHUURpRGowRmkwRXZLeDAyaVRXY1FjekFuMm9vTjRsUElCSlRuZ285ZEFVTnZXV2twSXlNMlAvUzluWDlucHNVditMeHVaUFBPUFRCaDdPM1Y3OVhkdjJJTFhjS21mYzgwdi9adnRkME9xZHI3S0x4QTVZLzFlT1ZvYmUzclRpanFPOWlsS2VvOFJqL3Z0NE5LM0dDYWgwMnNIaTlLZzlpTGIwcFNWUWg3Rkx4Vm5MdnlhdVZaaUwwOHByVDhaWnM5cXI1dmEwSmJ0U3ozTTVUMFozRWZJaTJrc2dkWEVuUjR3TVdrRExsL1NHOWhseFlmRnQzWlljd2ZjeVFMNzlibjNoOXlNRE1aMTErTW9UdkN1TitGSHhJRDEweDJQVlF0bExaNEEzcWNnVXZwKzBQZ05kSE1nelBTMWlkZFAvS0RsN09IcUZvMTR4Wm5CdUJBSkpqc2dHWEtFTGRKRTBHYTVBaGRKckpQWHBvekEyTDd6b1V6N2RHbmgrLzYyVXlnZCtjdUhuYXRHZGY1OFdUK3hhY2Q5SE9KUCtSRFdPeklsZG1wYmsrVVRjRE5KS0ZzMUpiUk1MRGcydWZzajNIUCtsaU5ablArT1FINVlhZmRjV0poNWVQNnJPWnZ4NkRQUUdmeEJrNndXZm1FQ2NYejBFLzdvM1JqNDBUaTV1ZXhzaGxGRm1BVW1TMEJCdHNQNDlSWkx0TlB4QmFnY2E1cEp5ZERvMGlrNDcveElnemcwc3k3WlN6TEl3aEczMDh6aGd5QzYxWGt3UHd2bi9udG00WC9uZ3I1Y1lNcmhxandlUXAzYmE3L2ZlMzBYY3NyaHFyeGU0cHJiSGhuM0g0YVJwbkJqOUpmUWRvZyt0aDVVMVdmeUNZWlREYTdHWHB4Sm1kTjFub1QzS2EvVWlsenR5RWJqdUQvbklRTERpU3RGbU04V2E1Uk5PbFVDeUVlYU1ROW54emQ1bkhZQ2x4clA1dGhhTlVaM0pVekQra2ZKaVlIK3hsNnBLLytBOVE4eSs3RjV5enVRTWZTYndYMmQzNXRvOTQ2OGw5NVB0QkpFOUozS1I0Nkh3R1lENEw2SHltODJiazlMeFpGcUtYc0prRXlDVGxjY0wvK0RQaGxPVmtjcVB5aDNLU3orVk55a0l5TWZGNzRpQlpwTnlLTmdOK09wZmFjeW1ubVF0K3RJamgwRWVObGFPa1BDNGdUcFIxMUVoRlZYYVFtRmVMcExxVFh6L3A1REtaeWc3OHJKd3hRL244L0w2eG5tdDZsWUNnVDgyK3VlSmhmdmJKQWNvbVY0M3RwVEZVdHA3Z1I4ZkNjOVA0TlBCbk9zTElwci9FcC9Ya2c0cUoveVh4RTUremdEKytZV1dpYUFQemxhWEtHL3pmS0s5N0ZSYzMwZkphY0NrWkVTd1VvOVZERmxZdG1WbUhISXpIUzgrdWVESnA5cGFCUjRXaThVeWF3R1dpUThtbDY4YVBwMUl5SVlZU2tjVlNNMlRVZG1vSEZiaFd3VkdDSS9FQmh2Y0JrQUpuNllPRVJpd3Z2WFBtdSsvZWROWCsvYVBIZmJhYnZMYmwwbUdrOUtIRkcvV0RCeW9IZHhUWkNuWXBYdzRhekV2OGcydUlHOVJBeUd0S2xMOVYvejdsdHBJWUVnSUpmakVNU2NBdmtOYzJLRkhqRTcrUFNzcjdQTWliaS9JNlVWNEh5SnNia1RrekV4dmx6Y01qQXBJbEttZUJ2TzVvUEV0QUNiUDg0RjRGV3EwcjVGSmZLdWVqdkJuVXFMQTAxeS9LSnR5T2NRQ1VkTk9VclJ1Qk1OcTVzcUlZNUNzdXFZaFNlV00rakdKZWc3RjArRFhYM0xiL2t1dnJ0aytiY3R1TUhlL2ZUYzY5OU9Ta21WNWIwUTZTTzNDd2Z1T0Q2NVR2Umwyd1pjZ281ZE9IRi9LME5vc3YxQm1FUGhBTFlodzlsUkRER0ZEak1UbE1qSHEwUnRIN3MxVGE0NkNwQTd3dmF1NmNwbzErdGVLam9MaUVuc1VZK1VDUG15K2FlWEYwU3BlckYzU2Jjc0cwU3p2ZXhoZStNRFlZcmppenkrWWJjZ3ZLcTZqdVZrRmNmVnQvUDlqS0ZJNFNlSlR3akZ1cElab3hXNnJORUlQSVhHUllBV3hIdFMwQjNMOTIwT001U0lVR1hOelp1bEk4V1JBSW9pNERQbVk0Y2lDSXhCNDl6U1JtME9RWUFHMmNNM3RWS3NuRVNsZTA0MHQwUjBpVmhCNWg0bGZ0ZXUzUkpiZWZ2WERNd25uM3pqMzN6b3R1dmV2aHZUdjV2VDhUVCs2YXgvVm5iS3JhdkczYitwend6aTc2YlR0emlZMmRFd0MvMFU2L21NdmhibGJYVnBZQTNqbEtUeGZpeXE0MUdEbWJIVjI1YkRDeS9DS1hKbXltS04zMjhvQWM5SlJYSUFkck93Sm9KTG9BdnFIREZaR0hna0V5SjJXaFdFWVdZbTBpUFlnWXEwRHpDRmZFVXRRR1pUYXdlQ2prNnpQaXN0cmFmVHUyYitpM2ZOSWVjcnN5cC9zQXZtNTd6cXdiNUxXLzFyNDFhR1B2OTQrdTNYako5RkpXZ3k2Q0hJUEFydjJZSHpuUytQeGFsK2pnN0xnTEpMdjBhQjYxWGg5OVF4K1R2ZkNHTVVvTEp4MTFXQVJxOTlYamlyWTdjUHgyTEpBeFJPTU9PMzduY01GM2dLUURhcjBlMnhQd3FYc0NIcm9uUUpFQy9CZXVDTkgvWXVKM3BKeVVIMVZtNzFQK1NSektQejlSZmlBdTVZZFA5RE1Tcy9sWmllSUhsajU0OU9pRFN4K2dPSmdFZFg4WGJ0WnZwSHZoRWF6eGxId3hXYkRYUzg0by9xVnRoUnNBdFJsWUtaSGJUN2ZDY2FXblpjSkZhYTlKc0dkWnJPdFowYktlWkZxUHN0aFozVHVWOWRCMzcxcCtaa1hzck1vcS9MdThheVY0a0ZHTnh3dzZzRzBuNUtXZHVibU1HWkM5T25YZklsdFhYMXRlWnNQaXZuSkRmVzI0RFgwWnh0Tm9sWlFaZDdIem55NFgrZ1M1VktSVmY2Q3JXaE03YU5RRjdhQlVkRyt4ZVhYWjRhSk81YXpXcnh6MEY2MlMyb2liVGE1QVBsZmNDUUZsMkMwVk5hbng0M1hoZ2tLKzB1dld4YUtGZUVDb0VBdjdNdEszUmxOTGV0Uk9NbmczZm0xVHBOZjNLdEwyMjFhVFlQV1RKRkM5V2puOFJMVnlkTzN4RDE2YU82ZjdOVmRjZit2WTJ5cW10aDkzNjh2djhpL1RmNlZJdTE5U2F2YnVKZjFmZmxJNVVyMkcrRmRYaytEcUo1UWphOTQrZHZiOGl1WDNMSG8weC90b3B5TTBieG5FalJGK0U3WnlCczVPcTFJenpNU28valdJWEx4YStaRTRWdzhuUTFmanBLL20rU0JaZVpraUtmRXJ5TXJreTJabmRiZ21KM0hBcEp2TVMzdXVnbnV5dFprcDdVQ25vMVJmSHkvdGdNWmFtZy9HMmlaYVcxQkJmMUNBVEY3blZ1YXBQY3hUaDZqVTNpVjNndStLNEx1aUpyTldDZTkyYWcvWmxNMmIzVTZIYzFNa3lpVnQyU21NTmpDQkhXQks0WmNEWEFuK3NFTDhTeE1IVVFuTjA0aW5VRlA3OG44K2IrVHNrK3NlZi9EUW0xdUg5dXJiNzV6K1BmNTAwaExQQ2xmTm1iUDJUR1VPNmEvVWtvL1A3dDZuc3ZrZUR4ZXAxVFhaNHpFazkzZ2djNmVNR3k0dmNGV1ZJWWphUm5KNTU0a0Z4QkRkMjF1M0x0Qjc3Um5lTTdiRkdEWWl5MkRHUk81TXRRclFhS2pIZzJrOGJqYTVJNUsrRGpFOTNlZTI2NUZPczFCQ2lXZGw1U2JNdGdFcnNZUzZwREpHZVUyQVMrVzl5cnV1SDd5a1pNQlE1Ui9kSzVSdGp2elNJWUZWRi9tR2QvL0lnVFk0SU4wR0s4MmtrdmhJRWZ0ckFIRXFQMWFUUzVXbmlaTzlIS2FzMjBVR2tzR1hLYU9EeXVnclVpL1pHUUphbjJvczVnQkhjY0dXRmFydVZJVnFaZ1NUUnNoU01XZktTSzlRVGU2RnRheFZIYVJ0amcxcVhyUnFkS3U3WlNkdjBhcFhtNDdIQ3pHM3hYaDhxZkhrUkJqMEl1aVBNNXVNcDNObERBQld1QmlHMG5KSW9TMW4vWEhXMW1XM2pibHFrcWY1b1BUZkJsNisrcnB0Z1hQR1huVmV3NVdwY2VuWXVBdy93Ymc4WEJaWG9sWFdwa2JtMVVhR0dYNVJUTGFDRDgrRE9OTW1JcGtBRHZncEhNQnl4QUx3MzNoVTE0RWJHUVpDSTMyMktBV3JwQUozWEUrUDdJSlFtS0VHMDRWcWVvQ2Z5cFQrWGtxKzZ6WG5QMXFUYmxreUNLaGlHdWFvd2FDQlYyWGszOVRDQXNjM0twRFRMYUkxeEI2czFiSFJFeXF4Sm9XbUVEaHJIUzRiaXV3UXNPelVsaXc3OVdKMWpDUkdrNVduTkpTYWVmQk9GcTN5MUVmalY1aWtLay9oUzhCeU41NWZvTk1sOXBOR2hmQ0ZEYjhxMlp1SWxTeWVuS3hHWmZYTy9GaFdGOVZHclExdXg5M0Nxb05yUXpvdXFDdE5GZ2lEK3VVc1hJMmxXcDB3TW5lSXZJcGhZYmJIODBGMlBBU2RUMCsyU01YaUpvdkxyeXNJcy9NZldBV1JIeTZHR1pFdFdLRFBHZWxzNmNUVGx4U1RGaXY2VkVYRzVLNm1hLzBVUmNlSlM1dTZBRlpQSlh4Z3hOelB4MTN3WjVYQS9qK3JCS2FraUZiMjE2d21PTFhWblZZZG5EZzd1ZXV0elV4eVFiY1lYOS8vRytOck1Tck5PYWVQNmtQTlR5ZEhCU3RhYzlqTnhoVkFodWIwNHdyK3liZ1FQbWFxcW92YjdJR3FWcFNYNW92U1I4cWx2RkQ2V0pQZWgyTzEvTUlINEhNUUc0YnhmTi9wUm91c1VpZ21POEh0WkNYM0EwNHpkTE5MY3VPT25nMDhFK1R6Z0NxeFZoMlJicTZmYlJXWWtZNTArbHJLZEFyWW1TN2VlYTBnVUUzTXBQZXBTdk01TDhBZnkyRmViSnlMSzFLWk13Y3QreEJwdFIzV1ZWR3lGRXZzTERna29ZbWJoNlQzM0pSS3J6dWNyc3NUUHExMlJjQ296UStqT3NWcXltSGFiaGhycXlJRkdmYjJST2tldEsxT2RnYnFhd3hPRytTWm5KOXlBd0RFYTF6MERiKzZJVzNqdE8xT1BDOG1lNEt0YnBrSjZmaGNVODRMaHdzMTdTU1Y4c2RtSEN6N2x1cEdZUFd5MUdZenVCQ3VwbFlxWmd0YXE1Z05xeFd6TllJNWtFTmQybDhvbWsydHJGT1h6eEtudHREK3JKQ1diNXUrL3ByS1VuZ0tXWXBhazZVNFRaYmN2eXBMRXlod2FuR0tVcGJ6RitSSlc2TTZKazl5alVid1RGZ0xpWEFMbzBOTXpnTExLZ0hMNnBndW5ycmdzRk5GSWJ4c0J5L2JwWVJHaEY2WUMwS2JuVDdoTHd0OWl2VjVhdmtudGx5dGY2cUhYYzBYTWM5cVFHRnVSVmhadlZ1ckFzMXVyUW9VMTVDQWE4anRZWVh4VG05R0VHVnRyU1EwaFRXYkZvZCtwWVdqVnFwRURXSmFYVlpxakxtNFE5OXlqSG10alRHLzJSaHJuVDUvSnQxcHNycmxnTHJpV3hsc212VTFIVzg4WlhHdGpGaDNOTTNJQkRabXNER1J5K0hhY3BlM0hEVWVneW1KeVQ0d3NCQVlXTHQwRWRDVUF2NTY3Vmgwb1ovMml0RUVLMVZQU0xQdHNsYUZPSVUxTlpWSGFXbEJyY2lsdjdPRjU2ZDdabzNIZEgvWGY4SEZ1QWZWUFRONjZDZlhWQzlGSXRoV2lFamxWS1NZczE2S3VhZ3JzUHNwa3NPSjhZR1BOdnJ5d1NXM0I1SGJSK2pabEFxRWVERVFMQXRKV2J0WXE4c050NHZnakxXbnpWenl4YmpWUXZkQmpiUzR6SWRuZkRrNWw2UEpoQlFSNDBic1BFQzM0cEk5WGh5QTV2eDVKTG5QaFlWRnlaTHQ1SUZNbjFqOTI5ZWZuRGl2K3lXeDBzNlhYM3BoNlR1dmJyNnV5K005WHVnMThaWXhQWHVmMjIzMkRWTm42MFp2ZTdWNllkODdPdlhxa3BYZHFlaXNyc052N0wxeWJiY2Q0Y2dEWjF6Yzk1ekpnOCs2T2xZK3BGT2ZnZGRlZlhJMTJBQ3RKNFQ4TlF1aVkwZHVkbnBGWWRzbUZZVmxxWXBDZHZhN09GZ3ZGYnNRNjJvVmhYakVHMWFBdThacXk2YUZZZTNGVGM1Z3Jpa2N3bS9VdXNLMnlickNzbisxcmpBdElmelRDc01udFlXYmVkcFNRMzBYTFZ0TUZSM1NlSkxTU3h1d24zbnBlbW5mUkMrZFVucGh4dFFXOU5MV2hkMlNOTDJnemJSTjEwdEUzT3dNNXVXYjJoUXp4Y1Q5QllVMFBXdWZWRTZuZjEwNWFVNUIrRlA5M0pSeUZLZlhrRTVNUzEzdlRsT1NUdFhSUnBxM1JybHVXQTJXMGxKcEV5MTExTFNFUWJoclRNNERsOUlaWEVwM3FySTJ3ZnFhN0RhY2lTYXhVaHVYWEpaVVhrMlZ1d3plajhIN3NZaGNCZGlvUjNyZHFselFCdlNhRnl5aUIzcGpvdXcwb1dXNTVjNWQ0ZThxVWZiU3VwL1NwRjQ3L3N0NlRRZGNLYldtZzlWVHFQZ0Z6WGZGTkFYM1RmcXcxbFg5akpZK3Q5SDBMR3hNdzJ1Z2I4T3R1aXF1R0ZacUpWZkR4WE14Z3k2TXlRRXptRnlVMVY2Sk1kelJraXFpdFozOHVYWlFlaWNqSHNXUU9vRlcwVWk3VUkyWGdKR1dKQmV2SC94YnA2amtkOUVsN0FVbFYyRXJLMDZsbG1BZHgrMkZSblJxZmtEdUlmZzdLc2JGUUM2KzQzWExtVm5hNlhJcEN6ZHVhcmpNRUhKNHNyRVRPeEZrRjJVTDIyUm1pZzRYTURWbllBMUlEZ201UTJvaGE3SFc1VXBUYzFHSXpzclFvOS9YN3JwNzFia1h2ekh5bTVHM2Z2cmEwY1RGWmhLUTFnNVpjLzI4OTNwY3RuWGh5dHB2VjAyK2QvWkQ5L0lMeWQ2Yng5d3drM1JjdTg1bzZMZHQwQk1kSWc4OXBDai9tS2E4TkdCTG0veHJyNTl5MllhbFN4ZE1BKzFlOGVQdGkrOWlOU05xYlc0SjV2dFluVnVieS9KOXJVQVh6RllPWUw3Zkpua2tTeTEyQ0xzWTdaSmxBVVAwNStRV1VkWlozR1N5ZTRTOGZJcXRQQkFJNHpuNVljejNUWGdHbnpQUUNDR0lweW5wOWJSSTlsc3I4djI1V1o3ZnN1WTNVZHNzeHhkWXpTejROaTlnbFNMY3EybGFOUnVHQlp2SHFtYnpqTWtPRjFnMW0wZXJadlBWcWxuc2NHSGl0SVdWTDI0U3JPNk16R3g2SXN6ZGFnRnQzdWtLYU5QWXZsT1cwajZuZVhYM0tXdHFkVHRWajk1d2pCWFhwc3VMVWU3R1A2c1NMajVGbFhDSldpV01jbWJuRjdHVGJ6VU9aNmlBenZLL1hDdnNTU1pFcDZzYXZpS1pFYlZlUGt5cTB4S2hkRmxERUxrbU5aZTFHR1F0WUxJV29LeHRrN0lXVUZuRHFxenRtc3h0V053TU1nZUNPU0UydVNCMFZuWXJRaGVjZG43VDQ5T3BwM2hLS2pBVm5uS1NoV1dwb0pUWXorWlpwOHEra2RaK2xVRFVybTR1ZlJGSUgyTFNoNHk0VXkxMUF1Y0pvYWcwcWtWdlZFVW9XdU16WVRUS2dxaGpvb2NtYUg1ZVppaUFOOXY0S2Z0WDVtZUJQUXNzUWtaWEtMVVJhNnh1Z2RwRmdWc3U3UVNyM1ZBbXRyNFNRcWZUVkJOS2xpb3FQZHEwcHJSWHRWRFRSbFVaNlpOTXVGcXVrRTVxbUVuY0RwcmowekV6My9nRS9ERUg3S2NKWDBMUytCTG5uL0lsbzlMNGtvTzZkYW1aT2psTUxlWGxoTVlqOEp3ZWRIK3lDVjlDVHNXWE9QK0RmSWx3R3I0a29HbHQ2OEZRaS8zTUV5ZHdzT3hiTmY3U09rNnFHeCtYaC9XbHJWUnk1cmRXeVJsU0t6bHJCYk0vTTQ4NURqa3IreTlWZGFaN2lkYnFPMjlQK29mV0N6M0pvUmIrZ2NrUTVBcFE3MVNHYkUyR2ZKUWhUR1hJRE5BaTMxeFZCbVFSTWpudGRFY3VlSHVYNkF1YVZXL3Y4YUl3K2RtdEM5TjA3YmRhcnpvM1pUVGxweWhkRmJxa0xmcHh5VHBXblNyVFJsb1hIdUk2Y0xOVXFiSTBxV2d4YzBRcWpZSFpRaWlQYW0xUGc1RGgyWU80MGoyc2YxTU9FN2FtalNGSEJhTUZFVnp3dFBlcEo2aldrVXNGWW8xZ3pxSVRtZU9XaTBwUjlyeXNVOGllYm9DYTZFM1hjNW9hWHRkTU1sOVRBcmtzdVpLYnFlTmRiUms3VlYzdzAxT2NDYTBYVkdQOFZhZXNHTXc3ZmNWZ2twNmdVY0FzMW1qeDNlNytTK1dEcVpqZXJKQndacEpXYVZGUnFBK2w2UDRtY29Rd2NwOUNqb0xUeXhGdUprZHRNcFpSUWJBOUlGdU5meTVRbWlFM2sybDBHdlhTUWlyaFJEcTlCK3VReWNWaVZYdnUvbE5JaGlHcUhRdFJoV0MxSFRReGEzeUNGcDlTQXRlVVdNM3dac2lQeEtCYzRrL1hRQmxHS2toNjRtNkcya08wS1luWkxSZTJxL3JMMWFDbm9teWFLZUtwVmppYkZnclJMV2xaTjBKckFwTTZHZDI4THJDbE1ueDFWQVZaTHVwaFFXSW1wdzhiWkhxcGxMUXJuMVNDQlU5L3RaeFFPSVdVclpZWjdta3BheXVWaHkyTFpOaWV0Tkl0MmNNcG54dWg3dng2WWsxMmdMR2VMcWl2YjlMVUtSU1JYSFZ5aG9zVjMyZTQ4RkMxM3NOcXFqRUx5Nll5dWlBdE8zWGZKeXlsaXlIeEZJdXlXcGRXR2tHUlh2MHV1NjlYMzR2Ym50SHI3SnZHdDJnTGRYSkE5OG05dTEvWDVXTFh2WjRiTVQ5VnVna24xTE9wbGR4Mkx0NE9iYnIxSTZwU1JVVHVxRzk2VXJWTDZ5ZFZhOHJjaUx0S3dKSkx3SkpkTER0TkhWMHRFV3VjSmxwY0xwY1ZnQ3E4L25iMEhLc1lMKzFZUVpYU3NRS1VFTVBPRlBHU3NpaW1ZWG50L20rY2JtMmh3ejg3N25wcHVqNy81UEJyNHJaMDdhcjlUWFFyamNVUTVRcE8wYlVxbk94YVZmZ2Y2MXFWdGtsenFxM2xyNU9Bby9WTlpkMzhGT0RnMmJsWDhOK0ltRm8vK1pxZlBQa2ErZytjZkNWcDhLaGxla3dHSmdmYk1qTVdVcGtUejIwRjIyWDlyN0s1cVl3SmI3a3RpclVxUGozdWpqcVRlN2s1ZjdZaG1oSFZtblY1WExTSGcreXhzZDRVc2krVGRRQjNpckl0UTIxK2s5d08xVGMzcnJSOVVHVldrNFdwN1lDZWFMb2VSeXREazJkajIzT3JXc2w3cFhZUnVVamZOUDN0MEN6OXpXWWtCNTc5MGpKaDlMTFptUGNJUVpvZHh0M1dQTVlPU2UwUTIyNXlPUE9MU3RyUURMRUlWcHJVaGk3SDdIQUovcGJWSFhmbTVWZFYvU3VwY25OZG5DNWovaVZkTjZmSW1oc0NUUllYd1lvbjJzZkpqdWRyOEF3RHRnU2p6U0xVQnVNU2lWS2xZRE5lSzIzR2F6R1gwbzdqTW05U0t4eXdhVGpFeThvTVBaMURvLzI1dys5ZnF0VHhReHBldjVqdlBaWi9ML0hDekVkbDVmSTk1SXRPSE1GNkdMNi92bzZkbTBERUt2RVIycVRMeko2R2NDYXFkdVlTMkFjYnhiQm81RGNlSEQzOHBZUEQrRkVUQkVQaTdwNFBUa3VNNTNWZHREb0UvZm5xWHRuRnJYUm55bTZ0TzFOT3MrNU1OYnpWVFkvai9MVUdUYWtVcFhtcnB2cFUzVVNMbmszcEZSUzhlcjcxSU9maGNyZ3JUbmx5TC9kVUovZnltcHpjcXpGNkF6bnErSU9aVlg5K2pDOGxRZE1EZldPUzlYbk5UL2FsRmV4cHZ0bnd2bjRKckxVODduYU9IYW0zZ3dYUkpSZUFGM3JhWms3ck41Y2oxTmVhYlhUUjBVNVB6QW42TXVsaE5Dejl3QXdTcTRjenRlcGhDbkV5QWRyRVhXNkJSaldibmUwcG1VV1o4MVhSVTJoWnlSWnphUlZRQnEzMVVxVllURHN2blVkaTR5NFRnb21QZVVQaUJOKzI0ZGpvNjVTM2xab2YzdG83NDRJQk0vZSt3Kzhtdzhoa3YrcFVQSFNUTnFIOEhCSStMbFIrWVRta2tZQmZ3VjNEanR3eWRvZUNsQVhabFJuSkUrcGR3TmprRXNCc1pkSGFkdllNbExPZE1ibDFsQnRJYmt6YndjamJSVEZaTG1Vb2xsTFF1RGN0QzFsVjdNUXlPcGxTZDl6a3lxRHVRMVN6VFZjR2kyN3dLNWpzUyszY2NTNFg5MUVBRWFqbjhkQ2phQ1J6eXEza2x4aEM0RnJTVGh6cUdjMDhtaGkvbmZocWo5dVBmL1JMb3F2bHZxV2puN3ppZ3FmSEt6L05tNmtvQjVXZmpzeGNlTS90TXhmT244R2ZJQWVtanIvdVRzakk5Q1J2eE9YYkdyblBwNjFZQXc2bUpMUnRHMm5MTlc3ZXRtWFRDeTlzNlR2NzNydVlmZERlVDdBdUM3a3libHlyM1o4aXJYVi82dGlrKzFNUE0ydi9WTlMyakhXQXFuVjdjdHFWVWovN24rc0JsVm9BcCswR3RWRmJENmR0QzZWWG1xNE5lb1lRMW5hSUswVzJ1WlZUaE8xUGNZcXdRNU5UaEQzTTdCaGhRWEVwTzBsWWEzRG8xVER6bnpoTG1KTDkxS2NLLzlBRVA4M3hRcElTVzJBOWdRdy9jU2FhemR6WXRDOFExdkRteHZEY3BoU0lVampQbWdUVk9BM1k4dGlNTlZNUjJlbUhQSSsrQVVrT1JmcEdNL3BvTitCWExOZVErQ281eTZDeWo2MzFGRHBWSnBQc05iUzF0V3FxVlBzaDNmVXRhekZvUHlJam5wL3luS0lqa1RmQyt0T2Q1Z1JWQ3JTbDlTWktUTkowckhVcGFsNWpSODl1MFZwcnp5bE9iLzFMejA0N3g1WDRXWHUyZHFLcnVYOW5jaE40dGs4N2dkdEVic2tUa2UwT1ZuTm9vUzN6MkxHaDA0MGtiVXJTOVRCZmF6bWc2Y0V3UitzM29PbmdwYWJqU05QQmYzSWM2VHI1UVJ1SHBwTmtUd2JBUy90MDY0U1hLSThZVXU4NHdTYml0UFJkNjQrR2pBdXRSRy9DbXV4TDBTVHAzRENlV1JtaVd5dGtHaTZsZmNuUHdUTXJzZ1A3aWtRZ2NOZXJIY2xyYmV6TUFldmVwOTBORnRBYStMSGJPYnlPSkJXWExsdWxOK252eVpCcDE0NjVjK2ExWTZmUHVLWkRWVldIRGxYNldWZE9tVHhxOUxRcG82OHU3OVN4c2hJeDRTRVl6MGY2cmJRU0Z2VXFHUEVpZ0JxVDRJRTE2VERpYVdHMXhyVFd4NFlGd2RzQ3c3S3lZU1U3YnhCTXdXVEJRY0V2bmdnRm5XQldtY3REVUk0aDBDM2p3d1hHUTlhWm85c09PditjL1A2WlU2eTNqMmt6OFB5K29RRlp1clh6RmhhMERZMmIvVUJCMjRMeC93NDF1aFducmRIOUgxMWZPdmhmcXk4bFhIYmpNZjIxa0RmazRGbXhiTHFIZ2NLNmJmWHBqUkJyOVpsMktxL0FRR3gySFY1WGdpSm1aZFBqa0hqYVBKc2VoOHptUU1nczF0TWRrMkpFdGo3a2x1MTBHOG1kemJhUk1rVklrclhPaVNITW01SmhqWFVib1AwVWhjK1ZZZVNxOXovZnVlbXFjeTQ0OThMK1kyNVJuajZNL1JXVjJwM1B6MzM1blp6ZE9TT3VtREgyc3NRdzJtNVJ0YTJUWUZ2NlZGOXhkZGFFWlA5cDJzNlIwMDdKMC83VG1xYlRVZ0doVjJKTm14VCszM095WDFOL3p2b3gvNTMyWXg2aDltUDJwTEVadFhaWEFBOGMyVlA5bUxFUnFUMEs0SnIyWVhheVBzeHNmeDFqdjB2RWM0NTJDb01zdEE5SkszUUhIZ2VrV0ZCdDAvMFVPZU9Uei9aY011WCsvanUvOGZBTEVyZGFQdnR3K1Q4MkhGQmV4cmJML3lCOXBlRzdLZ28rZXZXVnVpUGQ5M1FqRS82WDl2SDhqL2QwL3A5WSsvei9zZzgxejVrYWp4cjk4Tm1aNFAwdVpya2dublBKc3VGaFdDbUkza3NBZ3pIeXpPSnJ6V0dYVVVzRXdmK0p6RG1Zb3VnR2NQbmJnOVN4Y1hJNFN5VnpLK2s2ZDN0Q1lveTIvbTFMeEpEUlFqQ1NKRnZrbXpxWDl4azgrZ3oreTF1SW1XUW8zeXQvS0U4b3IyVjNQSHZvL092TzBaMTE0NHFWeTdjTjRYY0VudU5Ia0RjU2U5NS80OTA2M1pZNjVSRmw0WTdoSDk4NGRlSll6UjhZTzRJc2JwalpLOWxwV0pURm8vbzMybUZjZElCdmt6SmpGQWNab3hySjRHWjl4dDIwZ1NrOThSN0FjODJZdG1QTXNRYnIyYzFTb2dlWjNBeXRFUkwySDA5SkpTYmwyWHFZRDlSUElGYmlVMzRFV1ZZa2pnamt4dVdySHRzMmhIVW9UK3o1Y08rN2RkaWxmTmVOVTIrNWp2V21wYjdaZ3ljeTNHbE1TTklydTl4SnIreU5TTzQ2V1dSZVdYU2poeEhSSzd0RmZPbEdyeXlxZkVPZ1hqMW9sUFMrYXVjaTVuTVY1UXd5NWJXNnc4TnZWSmFwem5iSFJrVWdSOFlNYitKbmRjZkJ6K0w5alIyYmRXM1hKWHQ1V0ZpM2NuK3FXN2xaVXhOdFUwclNIZTVodmt0RDRnMStpUEpUNHVVN1U0NDNjU24vZE9LeVJEdCtiNktxS2VlQ1hORklHSU1MTExVMXJvZzVYY0ZMTjVtc0tsZVVyZTJsR1l3MEdhOHh1VVMveXJXd1NnYzZVSU9qS3EyYkltczRYaGttUWdwUWZHQVR6UHpieFBhQjI1VG82RXBCaWtUeExVZmI2a2FlbU10LytOU3hrOHZTb1FXTTJRWXg0MnRqTzBDSVJkcnBiQm8xT0Rab0tSeVJzL1gxOGV3d2phWDVsSCtsSlQwWjRKRTkxQ1Bqa3NyM3NucWVRSWJvcmlHZUlyeVBTTW9UYS9RNnYrcVVaVk9JN3M4N0dCMk5lMFlpYTc5QmFBTVRTTEVjdkJaeDRUdkVjcDBabUN1Mi9VWXVLYk9hRFJtazZ3OUtud3ZtMTl3eGZ1U0lzWmZjMWxINTVDMUQyNEdEUmw1cGZkZngxbXR2dlFUUzloaFRFS3prZjIwSWJsa3pJT2Vkb292SDYydjZEQWhkT0dydFl3L1NudkRLN2JvZktDOTlMdU1sOFRaQmJERnZwWDBVclBRcXdWUkwyN1FDYld3NGkwMXJBQjNwTUhkczBlUWY1d1NNNW9iRHlvV0hzQXU5YnN1SnVjcnRaTTUvdy8waWJEMk1WM3VpWDZEZXVXVFZRSlFPandKNkxPbEhBZFY3REdDdFdpa2FzTUpheGYxTzdKVnNhdElpM1pUazFlbUZHQ1ZKZnlJTVN5eGF4N2ROSEl5dlhmdlk4cDN6QWFNbzl5cFhLNWVCLzVoMHpmL0NPMDhvdGt1L3F5QU4yUmxhUTNiR05HUkg4UnlGY1d3ZEtyZnJ4MUMrM01PTlZCbHpoMUF2YzRZb1RBbnRlV0MxczU0bU92WFNPUFVJcDNacnFsT3R0VEFibkJENVRUN1dmbzJTbWdTM1JPSUM5cnZCdUY4Wlk2R09Ya3NSQmw4U012QzJHeGU4bU1WL3RHbC93Nmo5WkFRL1Nublh0MkdQd2s4ajNVLzJTN3hBNWlpMzgrY0tQK3hMN1BwdnZOc0UvbWZZUjN1WHE3MEJaU3ZlNTBDTlIyK0tzZmJsVHRvTXh1R2pEUkk5V21PZEdwM1I3cUxkOGpwUk1vZjUrekN5T29RUEpocC9KVC90SXovOW1tamtNNVJFNDc2RXd0ZnhUMUZQbitidDhRdkhnZmU1WFFKNGxkNW1Sczk0K0xRYjd3cXM5YlhaV1U2MDRXeEx2ZVlvYmNGNjFwWVQ3U0dQZG12UHl3TGhTM0I0bEhvU2tZK2pWSlNVN1dibVd3Qy9Yb1EzUzZuYk9aMUQwVFF6RHVYVFl3MzV6ZTVZdk9nVFV2UTVFVFpWYjkybHZLMzhwSHp6OUlodlJwR2JEK3g3WmlWWmM5L3NhMTY0U25maTRaZFh6ZDhZTVBnM0xIcmxRUC9YMjNmODUvamJYdmhpMk5pS250cmRKeU5CeDY1Vzc2SVFXNHRnN21ZUlREYTVxdjVpK0dvYXRGckVxbVJNYlFmanllTWViakVpUEZ6dWgvRGt6MEdkK2pNUlZFUTE5aCtHV1NQU3VnNjNKMzNBTlprV0s3d1pCQ21DRVRuVHE5YVQ0VEN4dDY0a2lMSXhqelZ1ZHRGTHJYSW96V0RDSkRIdWNHWlYvV2xRYmhLOG1zcDRUb3VBMVN3OHQwdEZLKzBPbHVQVWo3ZUdhcXpwcU1aMmFsVFRCTXMwaFREd0RGUGpOL1RPQjVHcllKRUNFR21OeStKeWxDS3VSdjZZYVBEYUpyQ09DUmE2cU9uNlNrZlA0RkFzeEZCU2dGaDU0QlU5aGRqWHlzMzloejkxenptQWk1L2l1NUJmVHN6VmJVa3NVL284TC93UHU1L2x2KzQrb1A4cDk2NHcyL3lCOXBlUE5FVTBETXFZMkwzVW9BMGpnMHlZOFpvMWY4OTBvS3M4bkhnSWswbmRGZ3lFL3k1M3VmdzczbWYyLy81dUVKb0wwRDVOSFZwbUFrZ1kwN3NxL3lxRVB5Vm9idzJrVTk1akJOaDlBblNPbGJTbGlBOXBxWk1CKzNqbDR4Wm91eGhlbWdzUXFOYWY0OFhMRGNNeDdJbEdYWDU3Vm1QTEd1a2lVdFRuUmlIK0F3b3locU0wUnk1aHU2TzRCOGJKK2RqL3o2NWVFOXFObkFraDFCZUwwbjdWdWxMaUMxZUVDd3F4TXVsTVFBZ0ZocVRwakpqWDhFelZwMmM4ZTNMT1VrVjVQdmZUL09lVWhxVmY3dDdvamp4UnkxL3UyYkI3MDhvSS84blNIKzdlc09IdVk0K3MrT1AyVHo2WmVmTHhOZHY1RFpzVjg5YW5sbTM2TDcxSEEzSWQvZm9tT0kwUkNuRk9TRjJiM21xdW95WTROUmFqanUyZk5mTmZNUzNWMmY0WnkzUk9ucDE0R1RJZHd0MEZzcjFFT1lMejFCcE0rZ1JMckZZMFVNb1dnS3RrUml6a1NMVU9WcDhLejVETVVYckpBRUpYdTBDQkVaZFdQVmxKbjB6RDZsM2YzRGhqK0licGh3L2YrZWJZdlo4SVBma3pFeWR2dXJHZ0xmOGd1TkpPWlcyM0orT244Y3AwMzYzcGdDNGR2VGwyQ3RIUloybUhiNXVuZWNqV2tUK093UDlWNFdtcXgyazZOOWxvampNMDlUelphSTBtdGU1UXRhNCszSFg2aDljNHJDWVRQVWFiNUlWVHcyRFRRSDQ4UW40K3ZPMnoxR0RVMmFEY0djUXVsM3FmazVZSDJ0UEk5RnJCUi9OQVFkM2JzTEppZXg2U0R0b1B4b3BFalZwNmJ3eXFtMTgrTzczTGlUcVRGTGZrU1RKbGZKZU5FQ29DeWcvS0g4cVZoOWMvdG1yNWxpWGdhVFJTck1GQ0NTVnRiOE5nVXYxOUJ0NmFaV0c5U1pQSnF1U0RHT3RKalRIUUxNWTZVeXJEWlo4UllGM1hXQWd3cWpDSWpUR1ZxeEk2aDA5Q0dQQUFTRDY1ZnNWakt4NnBuUy9jK1EzNHBqMGZ2UDV1M1k1eFUyKzlKakZiNDJSWlhGcVlpa3ROOHVrbTQvTzJOcjRtY2VsVWc5cDYrRFZpSmRuS1VlV1BkM2M5OXRTcTdldHdOQi91ZmVlVFhacStDTmNkZlBRZDFFZU9VSHRaT2RTNktqa0RadFBqTm1HRTlMQkdVSkpZaDIzeDlGbjFjWkhHQVJIdldxVGRvYkNyRVRhUmRvdElvSHRvTi9zTTJ0MG9tVy9FR0dSUXowOTNyZ3hWME9JeFkvZGR4d0F6WEthc1ZqYi80N2xSOFpFSHZqWWxKdk4zMnordmZlSUZmY1Z3Wlo1U282eFM3dXEySnp0ODZNQXJPeisra09xdjhaanhlY0EwYmk0WHp3Unl5WjBkdjVvNk1ueVpqUllwMm8wYW9zcHJ4bnk2Vk9ZelNLdVZFUEZZTXRteGY0K0xiZVJBOW04M0l2NFJSSHBWYjdBcVNZUzZVeWhJQ0lra0RRakJJcXJJQWlqa0ptM0pPY3AycFU0NXBMenNVdjdPNSs1K2VkZk8zZHQzdm9vb0RaQjB1VEpIV2E4OHJkeEZMaWFWaWJ2NW5SUVcyWWdBZnRsTVlSSEk2Z0ZiNmRQeURqV0RCbU9zTHM2UWRvZWFVSWVNTkM0eWlORFlrTW1rTml1bkR0QkdDNUtJbFZib1dGa3k3eEhwcGVNeFVpaVdGN2JGSkRhTVI3aFpzUEtRaGNwUFlFZ0NXWHY0cUxKbXpNTXJObTUrWURrLzlncFN1dXN0OEkyeHhOdkNsN2ZNSkg4YisvL2ovVGRqWVAyY3IvOEtmRTBCdDVDTCs5UnpMV0Jvc3ROVUwra2pXdEZ2Z0NITEFEdkU0ZzVTUHFHUXRrT1dpak1KcElwbGIzQ3lRVi8yQmpaSXRuMitheEJyaGF4M1NjSk8xaEFaYk5CVVZrYm9uN1Q5Y0U1QTIwbGx4MXM0elBlZHVBSnBzL09pemtVWk9oRFNxUGJ4eHdNdnJLeEtkT0Y5OW1OK0pNYTlSTWhUWGx2eXlEeUxvMUllOCtvL2xGKy9yVmQrTzNMLy9JYXZ1azI2aXIrZGpDRXpPN2N0M3RzeE0zdm5ya0dYL3Y1Rkk2Y2NJY05JNmFGNmNoN3AzdmxTOExsWUczaTVycGl6ZzMzbUpuazRoNUVkazhCK0RyVisxc0ROYjB5dVFieDB3Ui9GNW1naTQreWxUSXppT2lkYmZtSW15QU9xeDhURHdWeUxYMlNNUUM3clZJMVFITnZxc2t0QmlrTDAxbytRU3NLRlE5WGtEMUs5Zi9xZFgvOUQrWVpZamt5ZXJEVDhjUE9rcTBZcjMrdUtsUjllTERFNVoxNzl5T3AxcXdiMGZQcU1BZDJydEI3dWczWEY2ZndianA4Mm9sRDVOK2NwK2JkcWZxTVMweFhMRFF2b21pMVE1dXNlcHpwSjQ5OU1UZmszTTRSQ1c1U1Zob2ltRlAvbVRmRnYvaVQvNXYwWCtMZXdnUzhZZXZNOEczL1g0KzhuMnJ4TGVwRWRYN3NuYmx4TjNpTG1odm1KZldTeU1wOHY1dDk4VGJuamY5TWRQVHpFL2xKZGNRcytqN1RDNTNsUHhlZkZXdko1NURWbDVISHl5QWRrMlhGbEJObjd1OUwvQTJVZ1g4anppUVplUjcrVXhINCtLL0UxZm1HUFQvQ0J6MnIzZHhSd3JHTnczSzlPYzYzVlV1QkhkMjFpMjRtUVkrWDU2eVVuV24vUUMwNlNkZ3AyWWtrcFZrc1lNTzFtcDUrRUFsSGRPNWRKSHExVm9UK1FSTFhBMG84cG8wYWZwRkhTZUp5ZjdjUnFuSFZCSCtuRnV4OWMrdGlkTnorMjVQQmpUL1RiK3NXZWY3eDF4N2hHN3ZDSnlDc1g5aDg0K1B4bit2U2QzZWZwL2cvY1hkUEZHTDVqMUFQUHEzZDNMQUg5T3JpQnFTaEVUMEtsN3U4VmZNa2pUMGdadTFRdUQrRUFoQjBrdUxBTzFxNHhYcXhWTnJ2a2hyRXFrUFpWZitMa2ZjVHpxVldYT0tZclRudys4Z1doeThsOWZFYjcxem8wdktuV0lpL1JINFp4NUhDTFdvd0VyelB5NnV2alhscXU0UTNBSW5OR3RkSmtOanpKaGNwMmVtalRUcGNuZmNSU0J2NG80R1dGSFFJcVg1OVRSV3NYd0hvemFBY0ZNejJjRllDRUwxaDFXa0dhRW5mcFltMXFTdHUxa0ZKL09FbmJNYjFmb0N0dXh0bVJwcHlkODg4NHUrcURSTVlNYjcrU1VDcmdnV0MzQ3BmWXA5cXNxZkY3blVXSGU0M2xhcTA3RjJOY3RHQ2hlMVFFVE5oQW1HZWd4SzI1RGl2Z2tTM1NLTHNVWXhjdU1JVUxSMC9JNTkvNFN0bWZOZnpCU2VmcEpEdlpTbDQ3dVUrWXBEeXIzQ0dwL2xZL0RwNkoxV1RxZWhYVmUyNW9TeVphVVNiN1lhbjYyUUVOSzB3TFZoTFpzT3M2YjA2U2MzcTdUeVBuUFA2TXlzNlZkQ0JHQTE1VVdWd2lWcFBTdzNsUlc1dWM0NlQ5dSs3U25QcjFSenEyQVEyOFBmRHRzdnNHOEwxaFVNT3FsdmRMdk1yM3VQM3hoblhKKzV5RzBSNzczWnZwUEkyak02YzRPbWR6anM3WkdrY0hjL0R6d1lPS0RVTFFVUExzeVgza1RhWHp2L01kTkV3UHZYVEZ6VGc1SEpUQm5PTGtuQ2xPenRtY2s2c1dxZzhwaFhoWVc3aTFZZEgvem50dC9sM3VEeVJjVzhBd08raDhKVGs5SEFOMi9FL2o5SngvamROckt6eXNQSFZRbUNRRHFoRW1zVDJ6LzVaN0lmQ3NWQnY5REgwZHhQWUFsNGMzQnpuWkhXdXl6NHo3dWV4TWd5RkdyM0xJaStLUklGM3lqa1FFMjI1V3NTYzRvbEdNc3JMZUZvM2lpWElzbHpBSDFiTnRsT0sydXRqdEJtYU96UXB0K1Y3T0ZjRVMxbkUrTDZjSHhSUnprRU5raUE1Q2FQT3ZrdEVrbHhnL0pCd0pLWjgzY25VTnlxZEhWNjVZdVlKM3JuanM4ZVc4NXljU2RKTzF5dkFNNVdEOTk4cFhYcVdjdk9VbG9hTXJkN3I0L1o2WEU3KzRkNnhZL3BMN3YrcHVqMnBsZ2U0Nytvd2tqMmR1d2VPUnBqeWVNOFVuT1pNOG5yYzFIZzk4M1BHRHl6N1VGVGNzZ2dVL1A3R2ZURko1dkNwNHBwdnJwOWFmcVc2KzFxV25QWVJkQ0ljODZROERqNDhYRCtDWkU3cFZMOUFsdzhsNmwxcktRR204Wml6ZW9XZUdMQjkyOE9BVnoxL3oxSGIrVWJKWW1mRmtoeWg1SFZ6dDdxcks1NUozOVJudVRQZnRtdngwcVRUaDhKcUluYVRSbksxeGVDRDN5aS9KaWtPcTRQREZlbWxRZlJzejRYbHBISjY1RlE2UE5PZndUdlZ3amNQem5vckQwNGJ5NkllcHdhZ3pvZklKZWdoQkVHdTh5T0hSM01TdVpXdmdLV29GcjVYR054TmQwNVREYzdiQzRibll5TmlhOXpiaDhGalpYd2c1UEFwRVBYeEY0cHN2RG42aFpCOU1mRDNwdHQvQXB5aVhMSHRzOWRQQ3BFUjB4ZUFlZEkwakhuaUU0cHptM0owNnVIVHV6cFRpN3B4TnVERm5pcnR6dHNyZHNiRTE0ZTZxRDM3OCtVZWYxWDM4N0QxVGJ4dTNWNGdlaEFBTncxdnoxTG9CZ3dmM1VOcHJmVkVZOXV4SDc2ZHhhL3RKc2tVZFhxM0EycVlMS1ZObXNBejNreHdVeTFOVDVtUzNSVXhkWjR0cExFMWcyWGhnOGl6a3hZUDdsRjhKTjJIaTFQRU5PQmJsN2RWUHI3dWdQeXFLY25iQ1pJZzFBVnhMR1ZwK0lhcmdyTlpveUJCaEZFWWozVlppKzBsQ0Jrc2REQ0ltajBhNnQyVEZ5LzhrNnFrWmdNdjNhSlFjWlV3Z1NnSjQ2TDdzZnVKeEsrM0poN2E1TTBjODFxM0gwME5PbkZCK2JveTMzZGFiZEZoNzM3ek82M0tLbEcrVlg1U2ZsUzlVSFRVZWd6eXNxaFZ1cmttUXo3YWt1RGx6aXB0ek51Zm1BaWx1THZCWHVUbktlQUQ2NGJGbkdlUndhVkcrK3VCM2dUL2VQa0NJOHRWN3YzbVBrdmNtenBremFkS2NPUk1SbEgxd0ZGSFFTZVhBYjRlVnpyeHY4N1p0bTJ1MmJnV1pSRERRMTJrKzcwOXljR1oyazZUc2hhVE9KbklvaU0zSVRrTG82bWpKaUlPV2VXRzdhTE9UUVZlSGpsMENnRG1jclVwcmVnQno0aFVacTBGWS9YQ29LUWtua2pZM1R2dDRHL25xVUozU21EL2p1dmQvdmZ4cVVwTzNjdElqaUNLWEtXUDVReGNNSVdjTytoL2VQK3g1cmN6UTlkZjdoLzMvM0ZkcXUxWlYzVW5ySzlYMVA5UlhpbkEyd0hWNGYyMHhkdzhYTDBMcjlrZmtMR3M5UUNqWlJkRTRGallTUTcya2owcENoTksyUmZTVzQwS3diSjBKWWxsaEVRYUhRaVBFc3FKQ2ZGbUVjYUtRRVo0ZWxkRXRMR0ljZEk1WVkzZjVBL1JzWUphZkhiTXZ3djBDMlpWUGZ3TURTYXlDM2JLRDFURHNSSERxYktCWXJ0NUlhbnZvSUY1Mm9UTTV5NSsrbXR5eDhxRkxlblRwTXVYdmkrODZxRnV5WXQyNkZkZGtEeHgyNFVCbGVzTS9WMjhJMUlwUDhsOSt1MkdQa3E5Ym92bHpZVENzRlR4UDBia0Y2K2RxamZYRDNFdXYxU2NsK1Q4aGRVUVptY0JRNm1ReWdPZjAwMm9zVjNoSzg5KzBGa0RVTE5VRS90dnE4S09sV3RQOXQ2aldBemhFeVVPcmh6aHFVWWIwdkNHa25qbElQMEJSd0kwR005QkxDODVlZXYwZDgxM2tJNlhVT20vT2tzZG5QWlZRZm9VTXdrMHl1NjN2Zk0raXRjdVg5SDZoRy9IL0w3eFQ4ci82SG1TaDhTZzh0TmQvYys4MHYrWVp0aHpNKy9QZWFmK09kemZqT1kwZkRlZEF6TTBBdjM2cHVsS1FqUXBFV2ZiSGdSTTMwZ3ZNS0RIbGhyVmp5dmZqVmhnMTB4QTlxbUVLNGovUUdtWGdoZHNGdEdCRFVMMU1rcmxLWXRZd0piQlM1elFZay9YNDFnTWZmUEdwTXZwWTF2QWxrd1lMSytWeHQweWNzRUdsdFJoWUZDWXBUeWx6bjkvTWNCcjFMWVpKTk9mSmJISTJRME96cWJNWmFCTm1kallqNnhSbk01emEyUXkvbW9Ga3A4NW0rSnVjemREa29HY3pHS1Q4bWl3L3RPUHpEL2J2VTBZcTEvSXphcjZZT0dFajQ2Qnc1RSt1UXg1cUhZUGhHQXZVdTh4enVWdlZ1ejA5TWNEYXJjY0JRRzA1TkE1a2EzRWdteFpQWm1NY3lLR241M0l3RG1RelRPNVI5M2V5YzVpMWVBSEN1ZWhlWk9BMGJqL3RBbXAwOStPVUpacTdweGVnTi9QMGllbjhDT3hseFp3OHcrd1hnSTl2ZnBhRE5EM0w0ZnpyWnptYWNLbDlVcTQrblZSTjkva2FaMzJRYzZUdUgybkNuZ2RiWTg4elZmWmNvN2pNWXEzQklYcnBjWTQvWmRGVFJ6blNpZWN4R3NKcVNUbS9rMzZQQyt2MWRSZzBGcVlZdm1tbnJ4Q0VKWDE5UERORWI4UEVDeUo5N0d5b3IwNzJleWhmaTI0cjE4dE9mUHA5b3J2R0JuaVdkdVREVXh4ZTJ0MHQxeTJiOHFyK2N1ZXZwb2M0V3FXUGxIZGFFT3N0bW4wZFRqKy9nVnpJeFpRTFNEKy9ZVzU2ZnFOVkxvU2UzL0Ntem04NFd6dS9BWWJ5dzBGbHlmc3NEeis1VDFsQUdJODJwZkdZOFdIOVlpNkszUkE3Y3F3YXpTWFVTeGxSV3BlSmJhTXR0bm9wQi9RYVk4d3YyOU4zczg3M1doK1NFa2lKeW5GRDJZNWJiNGFPYUNZK1VlcUFkN3pIUTlnOUR0ZFdSMUJ2QjB3NmFqbWpKNytFUlYzWkVLcEtkZUZJcXloRVBnV2RvbGpPSjdmUFdla0c3ZitjejAwaGxtTURINjRhMm10STI3a1B2dlRjdUVzT1gzTGI4eTh1bmR2Mm9sNFhuYkYwd0hGaVZTQjlIYi91dkF2WFhnMko0VDcrYzNJdUdSdHJzNkUwVzJuOFh2bE4rZUpjOHFoeTdia2tuNWlQRVNHbjNZWTJNV1daOG9LeVhMbTF5NW5keThtQzVINWVCT1ltRTN0NVpuSTAvNmVXS0p2RkdEdi9aSVoxbTBWQkNNWnNOM09Mc3NVTXlqQmxZRHFJbTJNK0dwKzRUR3pEWnMrb1NyK2sxeU93KzQ3ZFlzekZHOE9DVVFqejMzMVltR0d5NUQxeGY4UFdjMXltZVJPLzJ2SFd2cFVkN29VOFBESHoya1dGRjVJSjVQN0VpL3ZPZnBMY1J5TEtLc1g4RG5uZ2V1VlRsdnRhWUoyL0RiNFR6K05kci9hWndjTjRkQUdoNXpTajU2dzFaN2tJcXp5bFRqU2JsdGJ3Tk5sbFR0UkRqN1Y1MEltSzlNNVpFWjJvZWpUUHJoM055L0pvVkJqZVFFbWRac3Z5S1F2eEhTWXpsVHVYRTVGa0s4ZVZuNVNiRHk5Yi9lU1RMODNVVlc0NmVuVFRyKysvOGQ1SHVzcUdlOFpOblRSR2syR2w3cC8wWnJoYlZCbmNxYUJGeVdSa3l5Z2tKZ0NKYTRObUYwTFdvSW1WQ2YyZjlyNDdQcW9xL2Z1ZU8zT245NTVlSnBuMFRES1RaQko2RVFIcEtLZ29Jb2dOUlVXUW9qUUZHNkJyNzZ4aXc3ck1uUVFVVjEwVUVRc3FOblRkRlJRVmpXQloyeTVsanU5NW5uUHZsQlJrZisvdjgvNzE2aWZKWkRMTW5QT2M1NXp6MU8vWGdYTnhxUmVDeTRFdGVqQVhCemJ1T1dBdVNrUVdibVNzSU1weGRic0FlR1FrSFVVeWZiK1hqS2R4SXBCWDl1NmhlWHYvcy8veXkzN1JYQ2J2Mk1GTzQ3Y3lna2tFNm9OMFAwZzNNY3RoaFdMVjV3bTgyam1qT3NnQzFVRkZlY3h4QjFoMktPU3pSOVNrUXpHL2dZc1JZUlZyVW5MaHp3bFhJVTdHeVJ3QjhBOWRnT2RYQUZVS0FqSzN4WXVjekpYaHdVcklQVGpqeG5TNVVIa1hDMTBwM2RWQThUWnhscE96U09tSFcwNzgyK3JuOStTSUM1TFhtcjdZUG5YREdZL3ZvdS9TcDIzMEZ5d1p5aVV4Y2RxTHA3ejEwaXNmLzRpVnZCTklYMTdualh3YTBscG10eGVsNXB5TGN6Wm1SbDBzRU44cnpGWG5iT1J6NW9IeUloNTdLY0xURytjYzRITXVTTTBaV2h0Y0JZaGhxTXc1QUdpemNYK1BjODZnc3MveVNzb3E0R2o4SlhCd3o3cmJCMTB6YS9sVkZyS0RSb3czTGw5OTF3TDVTM3JFOFF0WUo1OThNZWp4bHBYWEpOYmVlTnh6L1g3K2xyWW9mVy9uU1V2WWVlMFNCcW5SVkwxUzVkOWhNVUlBRG5UVVl1WXhPTU11V2UvbUFXUzlRUWtnRXdzK2dGNjRFaExVQkNIVW9pRWxGWEM2aVZGQ3hLWnZ2bC80MXFMdlNaUTBqeHRvMFpWTFN3NnRFQzlMcm9ZdlRjT09oOE81czJDZlFOM3RQWGgzT0xxTUJZS0JSZ3NHQTQxNjJQQ1lNVlhHNGxMSFlsZkhZc2ZBVDNvczdoS3hRcWNsTHpQMzdPVTlUMDk1YmVxVDN4THRoZjQ4c05ySlJqb0t2c1RUaGQrSGpVbjFBSi9OWk9KbUorWFp5c3JyemZZb0d3bDJUaFArRThLVEVveklHdVhLN2ttWm0yNnU3RzRsemVybXg2Z0ZqRXZKZzAwNGJKa0ZXZExnZWl2NjdFNFBPTWpzWjFMQ3ZEUWJZWnI4NUZkRUZKc083Si8vMXNJRDMxTDZzTGlJaEdkVW0vUlYySm93aU1seVVmSmE5VXZUbEZ3WUtyeFV0WmRuTUhtNjJibHpadlk4VXZZeWo3RHlLUmo1RkhMNUZEeGRwNURYMHhUSVVhY1FaVlBRcjN1SG5MY0pSWjg0K2RWSkhYdGVvbCtJOVQ4Tkw3V2ZsRXJidmtaYjhZdVp6ZUxGVDB5dC9qdXVReUhUelJjUWE2SlllSVdQdjkzdThCV1UrYU9jYnJ4UUFRZGx3eTFndDNrQlA4MkIzY0hIbytuMkhIUlBvQUtzMytFRHQvSUtNTUVSRjdld0Y4Znp0enozOHU4SEh1WFBPaHh4NTVhNDNSRzNiUkhhUlpzekh4bnJVNDk0ZlJnWWgzcGczUEE3WlYwaEx4RXBnbUlHMlZ3TXBXSXVkbFcyS2ZRM0hUcXpKNER1dXNFcDYzbHVxY1U5UUl3UmdLRmhwcVE3cUtrbk5WZ2R5TGF6eG0wa2hZVVgxSjF4N1puMEd1MERkUEZ0ai9kZDllM2l5ck9IbDM1VmZNS015c1VKRWliaHM4bllOVGVPdDVLM1Y2NmtFZS9ETDlJeDVOYmxzNUlyeENYbnJxQ3p0UnNoMDR5eVl3NmQ5azIyOXZuczlEcE9yU0R6c3BWSDE2NUF6ekhZZkx0a3I1djNWM2toSWxMSXhnNlQ3TkFhM2Y1Q0JiaGJNdURZM2N4WTUwTVh1dzQ5VDdUUGI3cHlGdDJsK1phK04yTG15TXFGNzF4VWNrSlQzdXRGYmNOTEw0cC8vaFU1L3BZbEhuTEsyV2ZUUjYwRHpydUlQa2ZxcHc2bjllUzlZZFBvZTVvcjZXRWlLZnZ1VmJiZXBVSzU4RFVmYzRmTjdzM0hCZGZ4blNjSDJSMmpEV0NCcHJ1WWFTM0FWSlpGMUtocktkOTRwZHhlVm9vZ2ZXa1REeklhdGdER1lrRXArdGQ4VjgrWG42bEQ0UmIyNG5oZXBsSXdkWEJzaWRzY2NTdFRDcXNqcjVBcmhmb0lsUUk4TDFrbllaSXpvVVhXQzZqS0trT1lTMk01cDNRM1lGaGRHMEIrRUZrWGhGMWtTSG1adllnMTZHNkpsVGlONHVaOTRseDZwL1krdW16bXFtazFxL1l0clRuN2RNcyt5K2t6YXhkL3U2b2hRbThRcTBnOXFjZjc3SzlNTVJvc0UvOTBIV2pHcW1uSmxlTGlNMWJUMldUREhVM0phNWwrM0VndVZlTjB1cHVaZm9Dc0Z5bG5nODJiSDFVMEJDV3RWeVVkTDJaeU5tVEoyYVBLR1lYclZ0Z2lTcUh5UzlKaFN6bXptc3VnNnhmMmpOdVBkSjh5OExIL2Q3TW5lWVNkSDkvUkx6VDc2YnVvV205ZlhEeEtWYTIzRmxZVzBrL0ozcysvd3FOa1dNOEtSbzQvdDRDMk1EVTdRclJ3cnpmU2Nkcmh1cnVGTWNLclFxSkZqWUtNQ3NlSFIrWCs3TkhnQ0lScXpPeFJLQ3lYQUJiVFdKeDBuMEJub2c4YWFYMk9Zd1pYTUJMdjQ1QjFiTjVScG1jMnFIT3FaYSt3MVNMbE9hQmxqbU4vNndQVmNHNVBUaTdJeE9ZY1pOVnFuTDY4Z3Fwd1E4dmc0YU1BeExjV01NMUtRcUFnL1VjeEJSbmFGbStCbUE5UGxnT3lTeFJyMDhMTUdZbUhuQWxmUVMxQ1dyc1NPVURLeGNUb1YxbXowcTJtK29xV0dEdDhtNk0rL3dEbTVQbTlhRE5nYmFkU3RDYlpSS1QramtHWTBJdHBLZ2duTmY1OS85OGUvL3pqeCs0bkQvNXAyV3ZQem5yOHVkekJTeDRZY2QySUNhYzBEYXpKaVZSTmIzem8yZmdEN1Z1WVMvTE4xUFBxeHA5dzJxenorNjZKZXFlUEduck91WFArOHV6Q0cxYVpkSE1XWFRMMzJjOU9uem4vdmt0eWlrKzRLamQ2M2FuSDE5cVdtVWVPeXUyNGFtVWlWKzk3ZXRYV2p5WFJXMVhWV0NOSm9iKzU4aVhwWnJZMnVmUnN6Uk1Tc0RPeUV6OENheU95YTJsWU9ENGtLcmV4UjRhd2JHU2FHQXpMaGJBd0kzQmhXdHlkYkIxQjdDMEQyY0swY0E4eUROUm1zQ3BWVEZtTEl3bHJGV0pMR3RuQ2pHUi9ib0dGY2JwOEdETzFPZ2NaUmJzbmtCdUs5QjBHVDJoZDdUVzEvWWJBd3lxblhCaUUxV2tieGxabkFKQUJZWUUwd0crR3NReXZwaFpnWVYwSlQyNVZHNUlGSkh3QjdoZjVIZVZsWFNzSFk2R2Vsa1ZaRmIyeUtnT0pzaWl3SnJua0ZsSjB4ejNMbGVyQzVaY2VkOGs5bzVZTk8rbTBhUC9hL0xyYVU4c1dYUFhha3RrMGVXREN0SnBocDB5Y2NmUFNJdGVFNWlFdlhIcnZ1b1hFb3hIdkdUK1MxeDgyMlNZdXlHMWVPZW1FS3V0eXkzRXRCZGVkMlJIVGx5MDU4KzVIQ1BHRVFuVzFrbFRSN3ZJYlY2TDllejQ3STdUc1BNNFR4dkc4S085S01UQUxvaU5INXdmTDBCU1ZjeXpjYkZCSUNUbEVPN3VIbVVzais3ek1uMGVpSlVqWE91M2N6VkliaHZvU0RLOGg1cnBIS0VHN29WZzQvOVA0czNrZkZXeDQ1bk82aHg0SWZ4U20vNks3TlUrUm5iVHA4UWMxL2lPZGp6eklIa2VTekJHZVFoNGxPbTZyMzBZcnBjZVpuNWdMT09vQjd0dENTUlg3ZUc3czJLT1FSOVNIVXpBZjN0UkFkUkVzaWpORTFMbzRsNEw3QVhWeGtHdHlPYm1keXpZcW9oUHg0ZnZaZDE2dUVuVjVIVmpIVWliYzlza2RqK3g2ZW4xQjFkK0gwbS9vOTd2b2YralBvbHQwSjc5T2JEQkx6WWZlc3IrdytjSnZucUNIZjZPSDZOL3R0STFzTnhCUEJxY245cFc2bU1VMnFXdG5LZmFQV0l5YWpQNFJwY25VSFZINlRLR3NDMXBOODdKYlRRR0FPVjNHbG00MTVUNVRPYytOZFc4MnRYMzQvRi9mZFI1NVZkUGllWHZqcHZlNzlaeEtuM3oyNmFkYjMzcHZwOHF6Z2ZWMllEVkhsYkU3MUlxN2dLbXp3MlBGc1hzTWlHL0Y0NjFRNWRCamdWM1cwTEtxN0w2MVhMVjg2VEpMY3Ivb3RWOTV4ZUt1eFhhbjNuTHp6YmM4ZnUzMXExS1lCTkpBNlRyQkN6MlQwRTJRTUlzOGJPemdIVlc4ZnN3QkdQbzJiWnVTeFllQUdmSDVXMkx1akYxS1NnNlF1bGlldjkvOWZVNjZlTUx4WTZNTlRjTnE2U2I2dTdUNHlQV0pGVmY5amZ6cm1UOE55dC9zbTdMNlNMN3kyZHBUdFdIQkQ3VisvbFRPZ24yMnk0alZGcnlhd3VXSGlLUVdJNUxJVEpBTzEzWDkvSGRHR1hYNmhzQzUxY09uang5WVYxeFYyK2lsdjlIRDJsRHlMN3VIUitQSGt6N0xaamU2LzJJZE5qQnBUUFBTRDlTSEVJKzhxbWNaVkljQmkvWllaY0JPTWlVTVdwNTYxSXRjNkF2ZjVrMExMeDY4bVl4Ukh2UWtLYjNMMDJmOWtFRFR5NDNLVDNYYzJsT2x2Y2pVVzlPei9HckR2RmYwMk9YWDQ5aDdrU2w5dHV2Z2U1U3k5SGJYMFd1QVQ5MFlWL3JEYTdPWWJHdGhFbXFiZUNJQXN5bU94c3ZDY3BVcGhVUU9FQ29aWGVQMTJWdTVxb3lkUVNHc21hNW9rd04yWnFzTEZwMHJIMnZ0ZStzakwrZEJ1VmhXOUhjZTZVdnFTQVhwUTdleXEvd0QrdXFQZi8zckM1czZYbmp4T1czRHI1K0VYUVpiN0syZmFOOHI2TzRUaGtjSFB6U2trdTMvNmVSaXVvbytUQitpcThpbFpEbzdnbzhRRGJFUUE1SG80VE9TRDErK2NQekQ0cFIwcFNIV0dSb1dLSFc0MWV4R1NWZmlJbGtDRlBISEM2T3BzbHpnbjZrd3BYbm1zNnR6YTdPcmN5dWdmcjhNWlZIZWhyVzY3VG9oTjA4VlJRL2x1cVFuUWZSY3c2dHgvdnB4azAxeVJkLzlpZlpiVFBlTUdOMDgrT0Vob2Q1WWgyWWtINzE5NnFuM2lxZGtsbGtpVnNBcWFaLzBJODUraGhCM2hqdnliWUpaVzhOTXl3NGRQbExuNnN0RnQ3V0VvK2pnWEV0OHlOTnNkMk5hUDkvSmZyTzdjOUF2Q3puYkJaOUY1U2ZUR01zcTFXbVhZM09TWHd0NklFR3lzRXh3ZTF4K3pqL29hbTRTSytCSm5UaVBCSW5OTXJ5bGFiaU5tRWc1L1FjOWxEOW5iZzc5aGU3K2NkMkQ3cUdOWndVZmZPQ0JkY1hubmwyMjdnRzI5bUZ5U1htLyt2cCs1VXdEUG1UL1gxOTU0WVhsWkQ0SnYwdC9DOVdVamdrUjA3dHZFV1BGMkRHVjlLQlNnMzI3OWdYdFNqYjNLbVh1ZVRiQnd1WmVqbk8zd053NXg2N2lza01peTZLdzZSWm56VDJQengwWnErUGx6bmFMVHloT3piMVVtWHVUSzhibjduTjVQU0pZc3hVaE1lYnc4eWRibkE3T3RsaWhtL0hsTzRaQlRRMER6VHYyN2RucHZQQVN4NXRmZnZPbXJiVWwydXA0ZmJ1MWIzTmJIK3QyMGZzRjhSWTNoa0tSSU4zM3lWNjZ2K3pzYzRNazUxTzZzelZVWGxIV3h1UlIwYmVtcXFxbXIzcDM2OWNZYkVLOU1FUTRrY3dVY0t2SFExRm8vMlMzTXM5Qk1EZktBS3dLekhFSXkrRyt6SHVONllBWHRIMWdySStoSmo0Z0trZlk3MUZtVEozRUsvRnlrTk1tVEdvNmhqaUVHSlBjRUljOG5QMDJBUUZYRThNbk1JdFdHRDZVMmJ5akkvRUpQUHdSWkFLY3hOM2JIeTk0NlR0d1pPTUQ2dU10OWZFQkRqbGFmQkRNNDc3RkI1ODdNSGxyZ1AzUkhJODYycHVpTGU2YTltYjR6bDdWM205QVgvWnJmL2llWUg4cVhsVzhLcWl6T1YxdDhlYTJCSHNhSHZWckU5cWJtdnYxUjQvNG1XaFRjMHZmZnYwSDFDdi9vV2NjTnJORk0yaHN0YkJTUTdDNllyaExqb0NyUE1HWmNGWWhNNC9mMWVFcEtBNjE0akxiYXRtT3JrSm1hRUhuTEFncWlSVUpRaTE5bkltaG95ZkFQeG5vaW8vTkxPMU9BVGNVa293c1MwdVhKQXV6MUFDQnRpL3hjdmhablI3eWo4MU45U0w4QVhLODg0anBoMXVYalRscnlzcGJOejl5eWxPRGhqNXh5cVBQM2JhaXo3VFFxQ1czL1VBTWJJdjhQUHVSRVNNZXVaRCtURDhSUi93VW0zM3BzbEZXK3hsckxqbWxNbG90dGJiMUtha29tVGR3eEo5NGdtYnEweU41ZW1iUDVERmpKcE5TWXZpT2FPcnpucDZLdVptMWRFNWJuejV0WkkxMFhlanJZRTN3cnBMS2tsaU1Ka1k3V25MWXVaMlRlOHFvQVpNWEtmVm51aExkWHJhTEJnamp5WFFoVVFHNkZZektWblpndXBSYTdZSW9GTHNBKzBaTFdLNk9NZDJLU3AzeFNLUzliN1NGNlZhZnFGelBkQ3ZNZEdzQ1Q4L21ZSnFubW1uVEFBN215OVJqS1B0dExHcGFZdWhZMEsyaDRFK05pTVRIOHVSQ2NVNm5QRkhSTGVGbEErcFduL3A0cEI0ODRURFRyWWhEam9GdTZiWkdVYmZDanZhR2NJUXBVeU44WjY5cWIrMFRZNysyd2ZjRSsxT0dialcySmRqVDhLaVY2VlpEWTJzYjE2MXdRMk1reG1TYnBWc0RxdUY0TUZneDl6YlVtZERWUXoxTWZLd3JZUy9QNDBtN0RsZHVRYkFKOWNwYXdmU3FIUFJxbzZDemUzT0xWY1VDeVAwV1oyTGdpTEh3Yi9xNjRxTjRxNmVpV0x4bmdFT1JPbFN0VXJvZGRNakdBb1VZdlNpVlVxSXg0OE9kVjU4NzdLVGgyNWN0dS9hU3hrVmpseTUvcFhGMHliQUxyM3JuZzErL3VmZThjKy82K2lDNWJ0NVNSWmVtM1hqUnlWV05WWWEydGxoUlpkR0Fsb0VqYm1aWGpwWDRZK3ZyNko4MnZUaWpxditXWjhtY2ZPZjZHTzFrYXZnei9lcWtrMGllOXUzeU9mUExhc3J1S0trcWFXNmppVkd1WnFaRTlweThtdnBSQTA5ZXlPK2ljK0NNMG4waU5EQTlla3hJMUlNV1ZVYkJNSW43bEJPcU5JbzV0UHhJdkY4NEhtUG5rYllUMW5TQXRWTnVib3VrQ0l3Qk1JdERVc3VlQU1ML1FEbHBlWUN6RlVQMmVhTkdxbStNOUFNNWU1eUptdGErSU44Y1YwZHhhV1UwaG10aXIyZHJVb05KZUVIbktpcFhsNlM0clUyTzlHT1hmR05UVzNxWDk1NU43YjdQUzd6NllFV1FmNTFEREQvZWZOV1lJUk9xcjdyOXhmaDVaM3g5NnR6NGk3ZXRxRDVwOEtqbE44T2Uvb1QrY3RGakl5YzlmamE3K0Q0Uk5acUNNVFVORDRXcndvL1cxYkJkZkR3NS96UWx5M3FRN2g1SjdxU3p4ekE3MHNDenJLZmhScjZIenV2WGQxQ01ySllxKy9SNTZDejJINU0xNWxxbFdVSSt1L2NuY0tUa3VDOGoyd3JFdW13SEYycVJHYUtheWJla0hPUmJnMFUya09xckJkdFd5TWNrSzJSZTVjSktKcFNDNHN4MGF5eWRidldZaUQ2b3FkQnJTdHhaQWhBUGZGRGxNWGlubkg3SDkxdkhtZ3pYTHZoeVF2eW16eThvcmJtS0h2Rm84c2RWaFI5aHMzMDRYTVhNMitVTGw0ejhZQnU1TmZuOHYyb2ZJS3RJN0dkNlA5MTZPNms1YnhiOVNJckdZby9pN0JCL2gxWWlsckVQY0E0OHFuMXI5MkN2cGROWXc2RjRqQWdVcjNhZUtaYXRHeXphQUMvZlJjL1VhRWY2cWpnekU5bGo2THZXWTdnd0M2QW5sRjcvb0xOWW1QYzQ2Yi9yaStkUGZQNk9EMzc4Y3ZmbEYrMmpmNkgzaVM5K1RFYktwLzF0RXYzNk41cWtod3FTcDVCdFpBN1dDTkpLellQc0Evd1FIOEN1Y2h1elFiM1lPT3gxR3lINGlXRTdHSHE2eXlnTlptRld4bTFYY0p6Y2tCRzNjV0lTZzAxQmNzcGdPQzVKQVJaelhKU2dNeGdTc1hid2lSdUczakh6bHV0dnUzYkVqTHE5MXUrVHZHcHdVRWRyNHZsbjQzNUhjZ3JacmlmWXV6THo5eVBha2RvUG1FZnRGQkpPQWVDSkZjQi9JTjZSM09Yc3k2K1I5T1g0VmVHZU9aajRYcUlIaGhCUGZINmNlSWZSSDE0bXJpSDB3Rk1MbnhMdGw5NVB4dDgvNzM1U2Z4eDlaKzNjUDlQNEE1ZittYjQvbERSeVAzbVQ5bVROTGRJMWdwM2RNbENWb3RGMkppeFlzbUdCWmdxTkJXNERqYzVZazRMQTVHVjhKV3o3WVhrVU93NDMxVGVUamVhVFo5UzMwRkdXeWRPMTIxb2FUanUvT1RZRjN2K0E5a25ORG1tejRCR2VFYUMxMVJHVjlUb293V29uZXJzQnV1Q1lCRHRsc3hzMmdSZnErQUNHZ1YxRUVHQ0crOGJWOStYMWVOOW82dU9PZWdqZHVIVUhBWFpTcHp2NG5QdkExbnE4YnpTT2RxMUd4eTRZQ2I3SDNZNTJwOXZCZm5YQjl3VDdVOFo5STdVbFhGRDUzZ1lnTnUxYXllbmk5NDFHSytuWTArN00rd2FidUtJUjhDWjlCU1FJa1R5YkdEeGdHYlYwN2dWdGl4ZmVOclB5MU5rM1ROVnV1Q3RZVXpaM2JtWHVwTktLVXBBcmVWbDduL2k2VHNkV3NCN21EYVFCYVBlNkVFYWZUWEVvdTJzUjBsTXcyNDAxYWhOMUdzbGZEelJRUG9nRmtwZFBHTlF5b0NrM3Q3VnR3VTNTNGdHajYyc3JYU2EzTGFmWk1jYTFrSDNXSzVtZkpZUTdMT25QMHU3cXNQTjdYV3VIejlKQ3hZQXg5VmxkN3l6eUNsNC8vV01EUjl5b3ZXK01nMTBtRG1kT1RtMzk2Q0VuTG1Eek1nZ1Y5RzM5cGRJcGdsWElZeG9URTQ0VEpncG5DclBKUlVLOEtkeFJweFhhbUVYQnRzKzRhSWVUL3pJQ291cnhXZEVPRGYvOXJFakNoQXBtbXM0VVROQ2RFNGxFSUxzd05kcFJ4Rjh4T1JJZkhPN29nNzhrQnZlQjF3NXVaZVB1ejFUa0lwU2ZsVnN1Vm93dnNsdXJJNDgvVVlWWTB2b1VZMEpjaC9aTFBCanA4UEFuU2lOd2F6SHJKOTRhNllqeDU0Nkx4R01PdVpFOU55RFMwY0NmNngrSk56amtZZXk1RXlNZEUvbHpaMGJpRXgzeWRQYnVzL2tUc3gzeWFQYUtLWkdPVWZ5SlV5UHhVUTc1WFBhS2N6ZzF3c1ZRNFE3SGhFa0RHUkE5aEo0RFJTRUkvemN5azBldTY4T2VuajJkUFQxdTh0UVI4UFNvMGV6cHMyWWhjR29kZTk1akc0YlpncENHL1pKZmV1S3AzT2ZodmsyUUk3MW4vNmJKK28xay82Mmw5ejlsdjJYbUN5dWs2V2VkY3JFMFd1b3plRlNETkNQcnQ1Rlp2NUhkMHBudzZ5aXB6eEQyNndqekM2Zk8xaW0va0MvaHBSZnB4bWpUL3pEMTIwWG1GMCs1V0RjRzNxVlJJcHNuejV4eFNrMVZlWmdXVHo1N3hxbndTTk4rOGt6MnFEb1VQanhrMHRrelRxbXVycWlUZGo0My9WUjRjTGh2OTVmUnV1ZG1UcTZ1RHRVcmVudWp2a0c2VTlBTE5uWjNGUW9ob1U1b0Z2b0xzd1N3bTFzbGhDeVhpbmM1NC8yaUhFOWxRRGhldEl2WjFSM2xmRzBCejF6VnMyQkVIc2hXTnFlSUIyWEtuWEpoS2JzRzhvQ25TcEJiSkU3UXBYSEtBck4vNHEydWVBenJjZGgyWmdhTnV5WG0xek1KeDN4K2ZRWGIzaTJ4cU45R1FQNnhxRTRmbEdMczcydzVZdjVDd3U0U2QzTU1JbGFoaWcrdnNBNTg5cEtQajV1cVhmcU1aOUJkRmFlN0NpZVRINktPYTB5T29jR3BydUVGVXlQT3E4a1Qya1V2RHZxc2YyeXFxK1NrL01HcjF0aU8yekxnQTdId2pLanphck56YVBLdE5aSFRuYU9HYTQ4TTdtdzZROXV3K2RESitMYWpwZTNzZGU4dldlZ2FOWHpJTGJWSFBqdEQyOXB4d3BCZDVQT3J6ZTdqQzZkR2VYMEVYYUticks4UmNvUUs0VjZsOXRLV3h2d3NEOHVGVW1laUVOc1hDa3ZaaHMxbEc3WlN4ZnlVSlZkbmV5N25jK1ZBcFhZRjk3UFVCTWdjSlI2c2h5eGxyNnlDZWswSklzUVZJRldFUHlwQlE5N3VCTHpQVXBmc0Q3Umg4dyt3TlBQcXpYYkpaUFp6NkFrSTAydWlMbExpakRLektPaHNHcURsOEo4a0UvN1RidnliYUNPbWcvZlNJNCsrSzJva3JZWVlrdlVUMzlhZmRNbU02Y2FkemplMnZRbVluR1dUNmJza3JJa2NIcFBzSUN2RUQvSW5URGxsZUMwNWZMZStac2JFVTA1Ly9JNmJlUy8yYW1tK3RFOXdDY1VwUEZTclVtK2hCMzViMmM5azQ4ZWlKMzhlbEtEeENpbVN3bEx3UU1ySzdVWm1Hdy9IVW9Ea2lkR3JJTG93b1dHbGxBWktNWFJRZHVCeHhsMVFueGd2eElZR1BTaWdiSEZpZ1d1cXFMVmRaelE1MDJLQmNDaVRTaENrRXVzaWtuVWZFeHNVdUg2NWN2ZlN2OXVUKzlmdjBFK2FNMjJHNFQzSG05dmZoQkxRSDV5VjMydGFlUWVrbUhQVzgwZGVrL2JObUhEeTZZL2VmU3ZJb0U3QnRvYWF2WXN5YXZiQXc0QktQWVVGcm9NSThCQ3IrQ3k4cU9kL29XNHYybXZkWHQyYWZTUkszN3FUK0VrcC9acitTT2Z1dTNmZFl3OXN1bEViMlBMd3cxcytldmVOZHovVUJvNnN2MmpSblBNNDVqUDBKbUx0WWE0d2sxdGdVR3dPckppUWcreFd1cDJYR3IzOWowYnZVOEFPTVFtUzIyMzBpTEdmVmFvSFpkcEQ2SXRFK0diM3ZuL1MzTDBIOTE4Ky94ZnR5V3YzN2wxTFExQXNyejM1eVBpMXZFNGVzTkJtSU1aZGZxcnVCeEhJOHBuUWJRN0U2TFNsdVR6dHpMeDFST0oyemlvREdKMUEyZ21oWmNCL2txRG5YNUJ0a01ZM21oQzVnOW5HaUlPY0RkL05EakZkRFFFWXoxaEZ6SzlDZWE1bEpxL2huRE5uTGx3MmRmNmQxemMzakZzNmE4S2RmMzRJRUQyWHZOaDYzYlFuL1FEcnFUdi9qQnNHTGx1MFFPbDNWUEFNZk94OFdhVG9UNjdhNm9qMUsyVUtuZ0UvVkh4MmpIc293VlBBdllXRHc0Y3dzeTQzcDM5T2FHMDZMUG5tWmQ2T0ZQdGpyak5oNWk4cWc5cU1PSEVxdklsdTRFM2s3ajdPRFFBT2lnZ0hPRkJuQ0pmaXVtZEtyT2UvKytydSsyWXVudHM2OG8yTGJYcjlGYXZMZmJOV3pPeTNjUG5LeTdXQWRuQWpCenQ0NDZacnB0L2x2bm5JV1hRYzRCMFlycHR4MWVTbk5uWGNJNmV4aEgyNkI5amRGTXZFSzlkQmphVk9yUTN0Z3RzcXdwSjVNakVpNEd1emVPTTd5ZXVseGFTTStnRzNsV014blMxTnpIeHZCSjB3OVBqZTlxTzg5enJ5NHdlMFVCc2l0YlRxeU5YdzNyRGZCY1JHUDBucHpkRW80KzRRaUVYWjRvSUZjckZJTG1yQlRXSkdkb3lFMmFKaU43SHZFdHNvRm1RYnRRZ0syeWp1aWhUOGVOQlp0MFl6UEhrL1dVMHYyeWRPM2lLZXM0MU8yNUo4UXB6TXhtRmljendOZTBwVDR5Q2NYenh6SElhdTQ3RC9qOFpodWxIY1NndkpjTHI1Y3lKdklLOCtSMy9aUU1jUkdURW1QZHBmbUR3SzRmVEx3cDBIZkJ5dnRiTWpUNDlsZDNuV1ZKdHVJWWRnTDhRcWhrSUE5eS9rKzlHczlPZ0dDcGs2NisydU5oVTdHTTU4QWR2WDJHbHZEcVRwZEpuT2FpRUFEcFVERmMycFJsMjljN05tVFBMdXM2L1lRZ3J1V3ZiOWZUT1dESm0vY3UyVFAzemQ5M1JnQWhoaHVaUHUzdjR5L2ZKdWI4Nk84RDkzdnZ1Wk9mbU8ybTlmcVBVeHVlWUo4N002K3N4SXRlNWl5eHpnOHdsb1VvQldlWFpPOXlTb2RFOHBqaWRlQkNEbkNTcXFpTmVaMEZ2NXZLRHFIaEx1QWlUY0FSSEk1TTJhbDhCRGI1bVRXaWUrUm5NbjlqbEliTis5ZTkyczgrY3NXSGJ2RXkydDJ0QmY2UTltdW9mK2gxTDZaY3NyTWZucHB6Wlo2QVVLNXNZU2ZTdGJIMjhLMTlydXlzYXA5NFhqYnNTMWNpRk9QZFJXd3gwTUtKOXc3OWhjNFAyYnpFckcwZGpHRVNRMmF2Vm1pOVBURGNZK2lyM0gzYURzeWRVLzdsN2FFNWo5ejJoZ3FJRDJSQkRwYXV4NzZqcGUwc040UFZuajlSenplS005anpjYnFxdjVuenN2NVdCZElWRlF3YnFvUUxraG9BSjI0UmwrRWgyZ1lQQzNDdmR3ZEpHT3NGYkkwZGFrZ1BqQjRLNlVzdkg0MjhMeG1sMXkxSUZrc0RWUlVKNGFzSktpL01MUEJPcVgrMERsVlEyYm1WZ2FSdTJwYkdIYTA0cFlicUdhS0lUTThzSk15WnlBZDVpdmtFNHdrNUdqOWp2L0M5Uit0Nkp2RlZHMWpmS1BjZnpmYktvTjFnMGZjdk93ZnNYelpnNGRjQlJZLzBOWDJHcXFtMllQYkRsK2ZPM1UyVTR1djJGMGdJSjUxZ0pNMW9CNkJsNDF5RThGUG1PT3RoeVNzdkhQWXVGNDFTNjVrY212a1plbTlRYUYxc3IrMWxqRnBPT3JBNGMwRFlvV2FtSkNiRUdBeUxLcVJoQ2lxUTdDVzBXY080QURwTGtVZ0RUbk1RT2tkUmRoNzVCcE03TkYxeHVDR2ozUVRXNGNVM2tzMnA3anUzZ20wQlhtN3RJTWFNVWlIMTdPYm9WTm9nTVRweTF1QVN0YXNaczFKck1qWlRlM3hFaUpvRmQyQ0R0Ujk1MHhsVnhCSkhyekErVFdIeis5aFE2L2xua0swK2ZOSWkvUjhjOG1OK0pHWG54eDhtZmxITDFlZXgzaXZhbGpNMmQwemRsVE1JNWlSQUU2UUVRWXFHTTJRZWhBcTBPTFh0WkxLVmRIb3pkWVUyUEwyTHBxUDkzeGI3MTdmaHFjakNKVW9icEh1YjNSaWJJNkxtTThLcHk0dThmR1NiQWZNYUFTNGNnYnZMUFBvUlp6eHB4Ukw0RG5sQkJ2MEFueVdiaVlEQ0ZTOGw5aUlmMk5kaXhlQ09MNUV6bDVHMW1hdk92SUFmTFpiK1RxR1NpZURGeTI3UEdRN1BIWWoyVTh6c3p4eEtEYlVNUEdVOEhrTW0zRk8wcWpZZWVLYVNDWU9hVFAydCtneDVBNG5pVVQ1Nml5cVZOa2cvRnRpQmZISFZHZUlyRkVtZVBpVlIwWERYZGMvTkNxQjlhRVIzVmNQQmhQOW9EcDc4V291QmNzQ1FSb0Y0RFYyb2hYdVdyelI5bndGTjBxSVhvMGMvWTkvWFJLdVZCNnc2L2RweTNkZXVlZFcrbGZGUVU3Y2dDVlMxdWE3ak05bGZrclBqWEdEV1BtSlROZFhaWDBlTzEvTkY3WkEzVkJKZ1M0dGVKRFYxdVdyNktQeHZpUzY3R2Q5RE15anNvbTNXSXltT2pvU1dRYlBVaWZYUHdaN3lobHR0cjlaREp0VFQ1SWRzNmt0eUZtQUVFTTdQbG9QdzdtZGxzR2h3WmdZQ3ZHbWdMYTNOVXdZNVlsdHVvWkZYRkM1NFE2R29OWUxqWVRIVk8vQXZwdkpzQ3Z0UnUzSjg4VUh3RGQ0NkxieUQ0ZjhIdTBpTjh6T05XenFPNUxhTTVDamp6ekxtYU1jTkFla3dyYXd4bnpCSFBYejFlaEx0MWlEWkYvb0NQSTdrTzA2V1BOWlhKbVA2dm1Ndlc4K2haOXRaTzY3RUVKR1daVDNCV09sSzhtb3E5bVNYRlhnS2x1TW5NWWVPU21zcWx0Q3RsQVVpbFNpOTI3VTdRV1NqQURxQzJ3ZDFNcVIxeWxNN3JzdjR5eEdEc1RObzFhNFp3YWxyM3JzQkRVeXFLQVd2M1JxQkRHYjhjSG42aEFmanl5b0lENWNSNlNFMUEveHFhUllwUk9ITmtBUFdjV2JNVFJLS29pcUJqcEVCZzI4d0VaQXAwSkF5cU9RWit5NlBrNHVEM1BaU09XMFpkVHd0bCtlSlJDK3NHeEZaOUUzeUp6REVxbFBLQk1xR013cHNkZzd6b0creCtPQVNRaE50Ry9wREFONVNPcjAzS2dIZ1BVNHhZTEM1UXg1Q3Q4SGtVYU5NWGR6TFhJa1hDZGNxeWRtWjEzeFVwREJCZUwwaE5oVkZEL2ZQbUkrZWhBSThwdFZka2pnUFFvaHpuOWdGWWpLWWpXenFPNEY1d3d4SFRteW1lSSs5WXJEOXd6K2NvVEZpKzljOE0vZDgwWXRpLzVNaFBwbGJZNzZXZHZ2a3ozM3U3SmY2UHU4OWZmM1cxUGZxamRlSGdVOXpGMGk1aDhpOVJ1aEhpZWdvdFlhRXk3R1ZMYXpVaDMyQlZ4S0lJOExtN0Z6UUI4SUlnRzVPVm51QmxTYjI2R1VYVXpZSFpnc1VBY3JOdmsxbW1XUlZyditHelJ1VnRYWG5udTlJc3ZYbkRidW9xQ0wrbHd0bEl0eGlzUC9lWEpYNWExdk5yVy91UlRtMHowZkFSbmhQcXZEWklzM1NKVU16dHVIYS9jd0pLZ0lOaGtoVXBRRFBLa0hiNm1DZ2lNK1l6Y2pFdVgvMERlc1lZZFBUV1ltNUJ6dkoxb3ZkVzRtUVd2TjJwc0RxeUJhSFMyNjN6NW1FVm5pOFlMMWl1QVg3VUUrd25Mc1EwbEg4S0ZUYzRPcytET3FZZHNndEdIU0Y2UXVOU3BpVXVmQXBjSXVkWlFLaWNrNm4xS3N5R0VRc3JFY28vUFAwQkJCSjlIK3BHNmxtVTFmU1pNb2xkL3ZMMHNkK2lKTDI2SXZ6ei9ncjdEUi9Wdm0vbllEVFBXYktPZjNhV3hqMndkZGNibzRjUEhpMCtSMldTUno3RTVQL24xditsUGhuRkVXUE41NTArZi81bis2MVMvNzRYQUdjVlBrUDd0Szk0WTBQekIwaHZ1dVFkcnlWN1N0ak43dUVxSWdCeERTZ1kzWGdweUxFakJxWmdBYUNpdVF4ZUJiVXB2WXdpQmxzRTBqbWJtY3FHNnN0cU4xMkUxRmxnQldTSTJmbGU3b0hqQllOTTVJRHNURHp0bGIxa2JLRWtpcjZBVXRTZFV5aUZaQ3FEQkJhU2FCN1p4bzdORE1Mc0N0VW9abml1YW1RQ09oVktwdFN3eDFwTnlEMG94V0RyajBMNFpKMGFHRFZxK2NNVTFFY2M1ajl4NjA3cXBKMVkwOTI5cW5yaG04Ymx6YnRtelNMeDVabXpvaFplS1ptSWdvWUs0ZDlPcjZ6Y2JWajd6c056eDBQem5XeDIyOWE2eHBWY2ZYSERmR2FYTHAyekEya1BtZzNHT25CcnczQUh2bzZPVSt4QXFVVTY4S2l6blNaMHFQNHMxRitzdElmNFhjaUFWaTF3SWpmQTVKZGpZRUhKMm1CdytiU2t2eWF2aTlScytaeUtuTUlTT0FoTk1RdEI3MnJwbjc3dlI2NUJ1L2tCdmhEdmtwV3gzb0JjQ251U0NMdDRBMHhubVEzRU0wVXFZUDZDSVFtb1I1cSttK0tIREp3RHpyMHJSRlNrQVBFRTIvMm80UUV6UXYrTXJSRzBJT3RzTlZrMFJ6ajhRWXZPdkJMRC9oQzhQdXI1a1F4SE1YNGVGeU9sS2dCN2dSN3RQdmlkQVV0SzN5OFM3QTVRbTM4K2VOQkh5NlJMa0lESkRCMjBXL1pBRldjR0Fmc2lFK0tRbUNFVkxEaVlGSk81SzZBM3dyRjZUSXYzanFLWDhqa1kyb2oxN3ZtTDIwL1lqSHJBWnRKd3JwNHF1Um54VU0vREpaRUNqSmdTQ1NJd0dNQktVajdabmZuUzdRVEl4ODBEditZTlBSc3pVTjkvN0I2Q21KdnVBWGFDNVRLbXRCNzRQQXlDUTZDRW1oVHhJR3VZb0dKbXh1d3ZyaGNHRmdseHJYQVM4QXY0QWlzTXgxaEYwSGlLanllaER0SFlmdTV1V2lWY2VlVGo1bVppallMSVc0MTNma0luVWtUSkQyZFVDS1NzejFLNUlXc1JDc0RnNWlMNHpYV0RNUHVDWGJlVjFwcHFLN1QvUjZYdVpyOUY1MXZNZEY0ait3eC9UYXJJcll3NE9ZU3EzTzlVNWRGaHRac0dLK0t0V0RZUkNzTjNadkN0dWo2Q0tTcEdFQ2UwSUV4T3ZhbzlhbWZqZ1dET1oxUW5ic2lic1ZXeU01cEptZGVLa2luNjBqMzVFcWxRQmhMZlJEMGp0dGtvaGhVMWJqUDNEcDZYNGhESHdZSW1reEdJUEk4eStmUmNnR0lIemFvb2tiSGEwRHkxc2JIYWJXaENFdDdMTm5oYVpxN3ZJVWlQODViMVFrYW1vZXVkUDlDeGlwei9zcGQ4VEJ4UGdLK2Zkc3V3eWNjamhUNTZrNzVPNko1R3JpZG5QQWJTZkZZeDY1cCtsdVpvYzNHN25oakZLUmpZZ0J3TEhxRGNZYldyd2kvTTNvY3AxNDNDYStJOVBsM2NoY2ZvVnpXWWtjaUpDZ1BuMXM5RnV6aHdEeVI2RDV4akdnTGl6eWhpeXNHZUYzN2UrdHpBYmZaYmVETTQ4SXRBS2ZOL3JaSlREMlFvM21LVEI1aWVibEZvTWRDdjAwZFNKd0VabVV3akpiQ253WXVYMXl1R2c0MllpZ0xKWTJEbGhUdEVjS1ZUUWloRmZ3ZzRJRXoxWnZQQ3JML1ljM29hSGhFUDdESGN1NEtEQWN3THRaenRrMHZqNGpOM0dwMkI2cU9ES3l2anNmelErNW10WWpEb0R4elB2ZVhoVm1namRSdjd4K1RzZkhqa2ZUNUlCS29LcmdzTjhOZE9qZTVuOC9ORHJwbEJpQWY2eWpzbEs1K0NNV0M1VHFpUk00WU55cGhpeGtHR0NTY2ptNHdWaVR1aUw5M1lqeCtKbldoWkJGdlBHdWxGa0tXNFowbVRCMks1SC85UUhQV0VLekM5VWdrbk03UEdnT0R3Mk9HYjltWEE2amhUYWI3dk43RkRnYmNHZGQyZ1ErazZRSlEveWQyWGovbVlPa0dQL3Z2bitKMTNSZnpubmhZSUFuT1lVOHdNMnBqM0ZLV2FKZG5oMWR1Z1NORWFoM3dWS2xiMllhL0o2QUNVYkF3NDZQWXc4UzZnZWJNbnJjUFBBamdFeENDRFlZNDVnNnpiMlRPbThDdVNFSWwwTXplSGdkV0NyZzNUblhyRjQ5bTM3OXQwMmUvRzMrN2xzNTV4SGh0RlhMRTNpN1lkV2l1RVdOenRFU21SbC9JMU12Z0ZoQ2RkTkxtUnp0TU1uSVp5WUlTcjdtS3g5S0dzZlZBdEtQbFJJSGRkQ3B6N0ZPS2hJbjluc0FFdmo0blBRcXhGNWRqcGkyaGVRaHR5S2hzaVNVNEdzNE91UU9SVnZzRm5QVjJMKzFBcy8vM3plcFBtK25BZlZsU0NXM3dYUFFJN0ZmTHpud01maUV4bWNqOGp2bHNuRzJxR3pxeXpXY1Jkb3N5Yk43NWFHcThqZ2U1Zk5iZ1RWVlh4VWxmT0hJNGRCYUcvTmp0TzJmN1R2d2lzbXJsL043byszR3lwZmZDcjVtaWhkZUdGaGZmSmlOWjQzQ2ZsRFJxWjlac1R5a0t5Y2d0alFxVlRDUVc4b0RNR1o0dkZHdDhma1JLb0xKaVB3MkRScUVGWWRDUTVrM2Q3NGxzYzNmL25FMkJ2T1o0NVl2MHVldW9mT0k5ZmRWeDZqcllBaDhmdDN1cE9ZLzFVZ2xBazNDWnc2Q1ZnVHpaaUVZRzZYUGovSGJJWDJVRm5QSkZQSWpwMXlEbElKM2dGNmxyQ05ITG53TnlnM0JCb0xXMjZuSEZKUUs2RkZPeCs4NDdnRHlTeUtuQWt6QXVlQ1orRHpvMHVkdzE3bXg1ZjUybVRtVExwa1FlVFVockVvY3hENkVzNTh4UUZkeXBpQkRBeFl4ZVVsS09yQzhtZjhaNFZLeUVqaUlSSFNla1JyK2ZTamVjUnd5UzY2bSs2a0R3Zm9KckdmeHZqY1N4dmUwMHc5OWZqbXR0TkpHZWxIYjZTM0ROMzFUYittblRQSkdOSzg5ZjNYUHVSNWhjRHYzMm4zTTVzNFV4NHVnT2NDMDYzVWtDVVBmWlk4SEZueUNHVEp3MzUwZWJoVWVYRGtLRmNPeDZ4a0wvUDJMQStFU3k0Z0phNlNGSnByUlpraWowRFJldStacnFyZlh2NzQzOGtHSTZrK2E5MVpKLzVsMWcvMGF5djlRdFNSQTRzdnZXaUYrT3k0MXNyK0ozKzBoLzYrKzNMNnQ5SWFBR3pWL2lDdVc3Ym1haTZIUW5aZmdsNlVNTitnbmNzaG5oL0ZNcFVjck5USXlUUHlQa2s1QkZwU2xKZWhKYVVSMVdGUXRLUW9yU1dsS0JYd0lISjlTSFlaVkJTbU9rTkFSYXFBQ3BGWDJsblpodmhpYmpQNlVUWUFTTWhXblNKVW5kQXhxSTRlNGZRMXBhRXM5U2trWTRrclMzMDJmclBuVi9xTmU5M2pYYldubUF4S2E4OUpGbVp0TENvbHc0bGp3V2l1UkV5SDZHclVvU0loSk1SNXQ3WHNZdWRqQU1Hb0FybEdEZzdGZGFvTWRLb3dOME9uaWlNcVNabWlVNFZwblNwRzZjSHhDUG1xbkZ4Y0NSODdaWE40Y1lkTmdiMVZCVm1vQ3JLZ1RjNEJRREtYdVl5SGVBSmN4d3BSeDhyK1VNZFFidlhrYUZxMjVJbjNObTAzSFUzSit1dnBQZVRpNEtIWFZVWEQ4NWpjejg1akRkTzBkQzBBaVd2Vkd3Ky9wRlFvY1BPK05LY2g4cW5ycTluNW1VTGQ2c0tvM2tNOW1ZdlhrN2wyOFJxeUZPQWxaMXlIeEJKSVZ5MGljek1yWEM0bW9IUmdtdnNMSVdrS1ZHR20vTFNKMmpzMXV6c0xRYkJIb3ZiM3NnRUVlK050eitiVjV2MFROZEsrSHVaTy9nZHo5L3hmenozNlIzUHZrZFRxcWk2VDc0WGpLaE5Da2NkNXBScW1NOGpMa2RJWjVreEE2YjNQMnRtUno4c3RNR091eEVFREt0SllqdEpEV2FMVXBiWkxlZ2YwVUVKT2sxM21zZyt3M3QwWSsvUWdtYjBGTXJsNlorcDJqWkVTMG1zRnliNm55UTFFbjN6T3ZwMFVybDM1NDlwSlM4Y3V2bWJ0MDc5K1BYVTJzd0dtZkVEZVM4Nitudjd3eWxhNjl3NTNBUVI1ZC93elA5bVpyaU01SGZFSEw4Nm9JNGxyb3hqZnRYUjIrSFU0TDcrcFUwVnB5T1ZtUWE0UzFQVnlYQVp2TGl5TnpvcTg0a1luV2dqWk1WMC9qK2tDUHI4bWxSNGwwQmVhRWRsMWxFRDl5R2RrYzVJTzZUeDA4WnZYclRqbmduTVhYRXMzbmpTZFdSSzVaQit0RXVuK0k0Ly90cXpsbGJhTmo1R3ArWFFGNXF1WXI3QVQ2MGVHQ2h6NERvQW1tVUd1a3JUYU9QczZWQ3dZYlU2VjkxempnZkFRRktwQ0VWMkNZS281azUyZEY2bDJZV2cvZEM4OThraFhtbmJGczFLcDJuRk1uSVBFQTdsbHQ0cHBZNGdrM0ppc2NRUHVKcFpFWWYyYzNjaVpLS3ljY3dxU0FRYXJRZzBwWUdVcDRNL1lnZHdnRTlFWHkwVlRmRlJUNTVTS3IzKzVZcy9TdmNCSmRjdjhjZHFFbGR4TnZsVDhxcm4wQ1hybDA2bytXekNYZWxvWGZUYUZaWWNWT0c3VGVTNS9xaUZZeEpJK2Q1cWpIUnVHZ0tyS2hQSjBtRGowditCRXhnVTFxUVF0MzZyV3Foa3Z1ditYYVV1UFczejkyZ2RUZk82LzBhL29DOTZjTityZWY1c2NoQ1FQMTg5VDBjODZMVk0vbFhGcTB1TTBwc2RwN3pwTys3R08weU9teGhuam1aK2Z2dnpzN1pFWE5wMS8vcVd6UldwVHdOSG9yL1NIM1B4WDJ4NVpUOWFtOGtCTGREcjA5VS84bitZTU9WK3dKWlhZN1NrNXg3V1JDL0RRZlRUNVNFOVpRd1h6VmVxUHZ2MkpSOHNiSGkxWmVFempRZTNqeVVLdWRqMmxDN2t2ci9pak00N215eWRjUm9SaHRIWHpRTk51ZmJ2TjRtUytzOTJIcFh1cWMyL1hRT20xdDYwSDd1c2crNTdsM3UvWXM2MEhCbXk2UkJ4TnprTVdiUFR2a2N2SEIvTEw5dTk3ZCtxdDZOVER6V1lMcDN4N20wYUI1K3ZGdTg4Y0gvZnVYL253bWU3Y1BzQm1TZHdwZmgrbWIvckpUSjRCdFpwWU5ydWkwVFExT2ZkOGdlUFA2K29FUmxiQTBOSDd1SnNiOEhLa2ZZdXpYWlJjZUJQcFhlMG1zOE9KVVhTbzEralE2QTBPcFF6TnlTNmZkTDErU3l6SWJ0dWd5K3ZjVEk0ajErakpUZVM0Lzl4REQ2Ly9WR014ME5QZXBPY2JuTkxpd3c5cHAzS1YxRGdhNXUwK2ZKSDJOdnJxcENPSEZkM1VuWWkxaTByTmplendxZmlIcG1pcVdwR0pNWS8zczFvOHZEN1JDUVN3b2dtTGdUQ0JxSXhWWjdHNmN0V3h1Z3VKUW8vSHRUT1RJdTliWDVtYmMrUjlkZlh1cFprOGVWdGFGMHhEb2p6bHBNd215L3Uvc1JrNTNvdUgyWXg2N0c2NVBJTmpEbU1BL2xRTWdPbVhsVmxQVnF6MXNEcU5OUmhtTGtKVVRhTWJDNnFOWE9FQ0VkbnA0VVdvUmlBazFmdDAvQXByRjRrblgrRWowRW84dFVyOGlHVUtXS0JSRXRTVW1MTkJwdDBsR21aazYvU2k5WkJvL1dWTjh1dnJOZGttMGpaeTl3cDd4SlFia2E0OHRJeGNReTlQRzRhSDN5WkxRNDlVTEZnRDgwUmVaR1lmNWduVlFyTWdaeklqMTJjeEkwZFZabVFnR3lsaE15NnBoQm1YbEFPR09wdHhDd3ExSmdmeXEvRUNPQnJ5MmV6enczS0JPNVZ5MVpaRkVINDNYaDZSWTVCNmhZUzV1ZG9DemxwamdkTzEwWjVqS0ttRWhHcmM1WlI5Q09WV24rSlRqdjYzZk1yWmxxWDdEOW1WeDJhTDhOYWpraTFMNDFQeS9DWEZ1NnpsZXFQN21lbU5tOG0wUW1VZFRtdU9KNlU1em5DOFBDcWJyY0J2Z3lYNFRHUFl5UWptTlJobnBUNWVmdzhNNXN6YXdHeGdQcmJ1bExvU2t1amxhdUpCZE4rVW1taXl5VnE0a21RK2wxYVlpMVFtaGpOVVZWbWJJbVJRZEVhM1FpRm1PQ0lxS2lPK2tlSm0wQ3E2c3dIbkdSRUdnQStiMXA2YUxPMXBTR2xQZVJnNndvcXNnTmVodHNGWDVuUzI1MWRDSjFNcGtOazRBS3hIb2R1T1IwR1Yybnk4SXo3RnV5MlhWakxUdFNpbnZBYVVKY3BPRmtBVHJYZkpMZjNZenphbjdNRUlTVTFLZVJyK2ErWEpGR1JhZFRJWkkzcFJvK2RTNURlcUFvMVVCZHV6S21rZlY4VmNxV3FTWmtNR0J3WmxQdHdOYUtkZ0JzbWk4RFVZRmN4b2hPNTBRUVVmRXRiWm1JRWxHZkNoWkZISm00RnUzY2hMNDQzSWxXWVVqUkJGWlEvMFBLZkV6c0FnVWN2eThVc0RrUDJpdUZxclphZnI3NVNJWlVkK28va2JpWm5jdUVCYS9ESzlhZ3NkdmhYVVJCd3RucXVjSmJxNTJqWWhKRFFJTVlnR0ZRb2NNRDVnN0l4WFJYZ0puVFBLN0pIT2VIT2tvOUZYYUdXRGJOUkRsZ0xxYk9zaGdkeUtHbEhCenBFS0IvVHVneDZBRmR1STFtRUU2dWlZTXJRQnhIeXFsYWJXbWJDVzZkc1FSMWEybDdRQnRHRENHVUJjRkk5THpzM0Q3azlBeE02RFBIdTdrRnNDdFI2eXZoRnhST05XcDJ5eXQ2VVZRbVVhODdla1FoczhlaGFxVUlqYVZYVlFvaHlUdi8yaDQ2VnI3eDh4NmZWcFgwK2IrL2RYdjAxT01wSkEvSkdKRDgrNjV0MUJVemF2K1hQSC92c1hyTHJ5OWxYaUdySjl6c3dMbHBLR1I5YnJkU09mRy9kQVhmajIyeW45eCtYMGhUSFBWQmFmTjJ2aGxLZHZ1MjMxNVV3THB2NXJ5WTFYTXcvK2NTYmNmN0s3eU1ZOHZ0VThNd0MxT3dtSHlCdkNPangrdXdNUTRaZ2VXSmk1d3c1bkNic3dKR0R5RmppYXNwMVR2YnNqaVlCZERTOHhyV0FQSUN4a2Q4UUYyR2pFallhSFFhbVpoWFBJTGlBSGdtd0FVbmZKd3J2aFRHaXlaWit2YWMzeFBwNTlrdW8wdWNrZG9qUDVnOWlVdm9ZT1hwVlNvaFEzR09kMXFCWWU2Y3FVVmNrT2tUTE9sRldtNzQzbm9TYkZtRlVHeENweEg4ekl5MllFL0o5dXBNNHE1OVJaL0lJQ0dvaGFwTFJnTXd5MnlRWE0xK2d3dXpRbGdJTWtGNWF6YzlkdUsycnJ6cFpWZGpTMnJDNzNkSytjWW1PeVpYUjc3OHhpSDZzaVM0NVVPTVZGNGVyZnY1TXVsMjVCaE1OemxaNDZueHFQbHdEaGtEak4yUWlIN2x5VnNBNEtWbTE1SE43UW5jSml6bkcyYXlTellrNjZPZkdGaEcyUVpsZmN3R3N5WVRaU001Q2ZjSGcwZmpMR3J0WnE3RisrL1IybFMvYXZaZ2JtQmN4bGZTdDUyMCtiWDRwL2JCVmZIN2JuczB0MzlHMmd5K2lUOUdtNlVwejZ3YlpkVzlrY1RtZHI3a0srM1Z6Z2Q4YzUrQTFLREIzS2pqeDhEaDU5S283aHNTTktpa2lnR1JiVFdLQ2ludFFjUkdlQ1RTRjlOZll5QlgyenloMFJMQlZqZkE2bml6dWwrMjdabUpqNDJKeURKSjhlK3Z6amYzOSt4ZHdMcnpXUkhaYy84TURZemVWQnV2ZDNnUjZpSHhOaDAvTFYxMXlOSEcrNER1eStoM1VvRnhxaFYvVm9heEVQaHVQaHFGeGdoUU9SeENPWkM1T0xhRjFZWXdoSmdGcjJzRFpydWFLWnl5V0hpaUVvWmZiQmdzazV0Y0Q2cG1uNzc1Y3U4MElyejNoOHRDVk5qbGF2T0hKNWl0ZXQ1MlhXdGlsM1c0cldUY3ZYbmRrTmJveDhSNFNIRkprRk05ZSttTXVzbU8zMmduQzhJU3I3bWN5cVU2d2p4Y3gxOHhTRHlaRExSUVlxRVVLVmFLK3ppZXo1Q3ZaOFJWaXU4L0Y2dEpTT3lMbkZFS1VFOHZRS0p4T2dFOUd4UkZlaXZMcUJLMDd4TVNwT2R4TWhsa2wxMVlOQ0pWUzVoVkd6SGtqWkJkMVZURHRSTlFyV2dySnA3bFBscCtIeGJLWnpUcUZBcUZKN3licEd0TmwrcVloQ2sxeThKSUx3Y1BaZDZmQjFlOEFHTGVJdUppSlhXQTc0T3RzTDhZa3lId2VOczBOSTE4dXVUYmtNNG00bEZjY1F4RGIycGtrOWhyUEo0QjVVcUplWWRzb01iVXZMZ01lMU4vUW9BL0pITXZEOEw4bWdoMkIyYnpMb01hejlRdzh5NkMyMFBiQzdERTVpKytoa3BnZHc3dlFIZXdzdEE2K3BNOVVhbHRFVEZnK0g0MzJqY3BVVmJDOUVZd2p0VXM4WXBTV3N2ZFhpWndLSXNDY2pZYm1WL2ZBN1VtMWlpU0xNMmhmbE1YTVJzQnBxUTVoMkIwdkxYaXFDcFZYa2FqY2FtdnZpL1lHTmxVNU15bGxjMk9Tc3RJMDVsYll4MTMvVE50YUxVUCs0ZWV6ODdnSStTZ09aV041ZHhzT1lqL01FMDdPZ0VCYjZNaTNERGpLczNsZmJ4ekw2eGdCNXRDMHFWMWc1K0dDL2NMeHNsMXpONUZoOTFDYXllSTRqM2dKUE43Qy9ONFRsRnFhQi9kbkxHeENielZtS3ZGcDJwd3l0ZUVCeHlodk1OS1U4dWd5TXJkaFU1bEtheXB4S1U1bnIySnZLZWhGdzc2MWxtdTZDN2EyOVRKcllWYW9LVjdDMkRHT0xweXNNZWxxbXQxYVYvY1poOEZsVjh1MEFjc083YzNqTTBLMUxVWmhxZlU2RmNKSmRlbTJZdm5SaWZzYkVUSHBlQ2hKVDlLa2syRXhLQUIvZkIyZ0dKYVVEcC8zOUxISW1uYjZVM0ozY3FMbUM5a3NTaWU2a0J3NjNNWVg0ejk0bnlRM2JIcWJqamU4OSs5cG5QSFpYUVNzMUgycEQ3SllmTDZBakE0UTFjWCtZbDMvazhpSGFPeE02VEhyckFCdzlMM3UwU0hXY0ErTkxDQTVzbEZmRzZGZHc4VkpqVEJYT1Y1eTJZOHJhcCtpaWVXUnRjcFBtTkhyaVZ3ZXZPZnpJdDM5K3ZicDI3WFdrNUg3eWRQczk5RGpQVDYvZCtQRzhrWUxLdVNKTjA5MGlPSmdsZlhwMjVRcVVHVHJEd0ppa1VzdHBPRzZJbWVPR1lQcENveEtJeHMzT2RvUERpWUZHa3pvSDdBclQyZHJTNkJkUnp1c1dDeElvRmR2OHZrVmpGTjhpbHZkZGhtU0RRenhIV3B3TVhmcHRsWGJhb1pYaUI0OStkL2h1YWYvNjlXbmV1YkhNcDNGQjFXWVgzamtJRWp2MGFlTDFiUG81VHpmNk9SeFQzT0JLV0oxSytPeG85SFBlVE9LNWNlSTUzU2pudE92WklEV0tMSDltc3N3WEtvVXJ1a3VUTFhzb0tudXNQQmRmbFNsVENJSDY4UVRGS0dpUVBReW1KVjJkSldrbnBOcGtNelFaR0hBL0g0T3dlOW14MlFzUTZMNUx1eTFJOTh0VjVUeG42N01CZmM2UXNLYjdDckZkeVR4N2w1WFh0bFNvNjlSdVIwUWFyeTl6eGRwTERFYUZ2amd2TEpmNGVPMEJPcFpTbSt6VnNLVzB1UUlRQlRUbVFiQ3JzSXlEVFFBUjR4L3pDZllpaXN4Rkh0SERQZENOWjNCZ2QwRm9PWlk4MHdIQW9JWTdZRlpYTkhrb3lDc0p4K3VpZ0VJUXIyQ3lhRWpoeVZzNDlFQ2hEOEVKeTZBcmdsOEdLaWcxQkVYTEN1R1V0M3VOcVlzVE1mQjZSNkh1YmUyN0E4Ky8rL2FPZDkvWjhjNTdsL1pnWjNRRm9aOUNqOUJmaVpIb2lFak05RmZ4cGU1Mk8yTFRNNTBBTHRZU29RNFlBbEVXZVNvNmZSR3lzc1pyb3BDTmpKY3pXZFNqTEhLWVVXN05BYjF3cy9ubjhDMmhZMDlXNmdxVW9GOXBHSWlzc1lNRWFuV1F1NVZaQyswYVl4NXkveFM0NVBJYTJCVkZlVDBqM1djWjR5bWM2aXllNmd4NDZqZFVpUlNxT05YazlKUm9zcUdwTlR0VmVtcTdBbEl0WHBHMkQvNC8xOEQvTnRlQWxMSG5WSzk2OWRIbDJxTlhuUlp5ejQ1MWh1akJzYzYxWUhhWnU5Vkd1MThEYnJXckZzM1lZMXlOWTkrWVhWYnA5R1BZbjZtRkU2L3BmazVKV1h1VGU5VnpGWm5scSt0Wnh0YXpPQWRsVm16QWpkckFONnJpVlZ0MzRmWjBPNUNEU1BXYjNkaTNsRnZjeHYxbGpURy9EUFpqblN0UldNSmpZOFU1eDdBanN3VFY2N1o4VFJWRWFSZUZJU1ArYUhjZWVWbFZJbkZFU2pBYXRET1hNMTNpZW5TWGtEQW9uWVBjUjBJOWNobkUzdlFvZDFjUG11UGttaVBsZFNhYzZCUTVYY3pjQXlVcWhvSWEwZUNIVmdUWkNURVpoeGZUOEFaT1FlaHlRdmJCRGRkZTNJKzVuSlFqcElSbFN0RURZcUlxVVFJT3ZTblZ3SmUrWXlvMWhUNUlOLzNqcVRNVDB6Nzl5cEJjSUY1cjNkUHh3TE0zOUhEdk41OUdyNkh0OUg1NjlZQnQrY0V2UHQyNjVhTVRSWE9QZHorVG1XWUIwNldBVUNZMFFOV1lYL1Y1bklRSFpUdjBPcitUeVF6S0VFdkQ4ZnFvbk05a1ZzbGsxaGlPNSt4Q1I2ZUlSMXRybUI1QjFMNG9CL29COVdhblh3ZkNxWUhvcXNISXlkZlJOQmF3eW9oQVdodnkzTWlkRWNkSURIZGlpdDJxU0RBMjc4SVlURytYLzhDN2J5SnVGNjBsSDFoV0xqM2puZ0dESHB0NDZCRDk1ZmVFdWJ0b3FwNDdqdFE5OHFkcld0WVhsTlA5OUZmNkMvMnNCNmRGRkN4TWw3NWl0cldQblpaTlN2Y0YxRUFMaWpuSXZJR0FQdU9nZE52VUZtQlo2K1J3d3dSYmRFaVUyRkw0T3pHd1NDMy9KaWZYbTQwNlArbjNJeDAyNGZyMjVSZFBPK1BjaytjM3ZJVTI5S0NacFRreDhiY2pPYzg4UEtiZzdmSkpGMnZuZ1JtZDRrTWV5Nno5QU52elhmbVFJZkROYStyaEVEeFdQbU1ZVUk4c3htK2lyZHlWdUJpdFpkQWJMcCtmbVh4S2hYcndQcnBKcURnY3I0M0t1VXhYUWt4WHd1RzRmNWRjNEVQR1FTanZyV0s2MHNCK0Z2aDUwV25RcVRRNUhhc2tlOUdHWHFXN3JVY0R1WnUwSlV1UCs0VExmZ09UZmJGUUN6VXlYYVJmR0FieTVJQ1ZFNzdWSVFzMTJzQzhCcmZDeDFsSjhnQU1Bdks3ek9MRitjWXJ3QkU0NXRYcVpkSTlydUMySGczaGJsVFVBM3VjTDY2dkh1cHJGQTZjcnV1YjVzQTVadFZ2aVVXQnVEd0tGT2I0cU5lMWVuN211Ry96bnh2MVhmV0ZoWjNzWjgrN0lyRDZMay80eFQ2QjJGOEd3TS9NZGRyTDFxbEFxQkJxdXE0VDVONGgwMzdzMjZQYm9IdVU5V3ZaQSs1eDUvUTRYdXdEWXZzSTR1TTFjSTliVTdWK3BtaUhVMmVGM0s0VDJ0SWdhQVRkMndYaGVCV1BrQWNqYWc5eXVndElyYUNIeXBNUWV4aEN3QjZsTWd1YmszTjVrVk84Mk1rYlZib1VZM1ZMaUdjbENwUUNMZDU5OVdOM0JjdXUyTUptTE0zMzNSV016N3VON1NlWFVDaFVDOHNWN0RtbGtLdkRJV0ZPMjJHQXFoTEEyL2RaZVFkQmpWcloxZTVHM3pPSCs1NldkSTFYdVJrUU5QQlNDc3ZsUHA3MXl3RUFZTW5oZzhvYjJWTEU5bUJwSlJaOE9WUVV5YXlDcjZQTGdCZUI3Y1VTc0hnUDFseG1WUmoyZTJrR2Q1VUExb2RwUldteFlJU1RYSVc2STREMkxHQjdZUzlkeG1ZVlZsRHA5ZDJzR1psYysrbW4wdUp0UjF4UXpLWFdGbXJHYTBQc3Zmc3AvY1ZhZHA5cnNibFlpODNGeXNjd2NSa2tvWHRIY2RkUFdTZHVvTkUzM3RPR2xHNWlab01Ddm9pQjZhMUowZHl3Y0oyUU1FSGNnQjM2Wmd1dlZtQ2Vjb2ZHYmNKYVJrdFh6VzFJWVF1SUVZQVh5RkJlNkJUbUlDM3hFS2c5bW1WaDFHYzlGZ3JJNFFCM3FQV1Ezd2xXNGIxaFJsZ0doZlFaa1V4TEt0UndhRytMU2JBVTdDR2lKMjc2TXozODVOcDcxdDdaY2YzdDNWZVZ6UDJhblVMYjNuOXQ1NjYvWGJSbzdqbGFiWmMxUGJoSktTaVRFUGZrVHFiYlBjdEdKVEhQa0kyaEY5blllNU9OL2FpeXNmK0JiUGprajBrMjYvWit0T2ZEM2JzK2V1SzZSZk12Mm41aEQzSVp2VmNib2ljRG11cjZNZVBIRDlKYzBFVXVodzRCWXpUYUwzVjBzb0o1bVN2YzJBWDFFcGpkSEthZXdDL3pzS1pGNUYzY3VrakNpcTNiVm1obU5UblVia0ZYT0dIQ1Rob1RnbEdhSlB6dVpib01PV01UZUxHMkFCWVdRNDlMTGthTzRmQjN5VzZQZ3N5VWdWTUp3R3RJc0Fnd0F4bmdtWTdtbHZNK3ZPbTZzVU95VURTUDdIQmRSVWJRSjI2N3g4L2pzaVk2V2NIVXpBVXZKQXRWczRkNUdyck8wOTUxbmxaSGh6ZFBNR24vSDgwNEE2YlRxczQ0QzY4ek9ZZk51SkcraERNV0JTMmRMQmtSUHlFZ2pFbEhENVdPY3VBTHRKbDRzNmNET2JKNUs2Y2oxZFJ0ODNFS2R3R0RnS0tyWFd0eXVyS2J6TmwzS1hPSVhick5QNmIvd1diemMxTUxsRzQ3cjRXVzg5M3BKWUplck1uYU9ZaS9FSUFvVG1xOEpITzhDWnRQSmJmNEw0WXVhemxwdGRxWUh1d3k3cXdPZGJMZ2QraFBKNG5VcUZPZDZzbTkwS1crTzBQTWdHbko3c3l0VE01T29YOGFwMC9pNWxnSDIwaVNGUnFJa1ZiZEZJRW1VYVFxd0R3bUJKMlJPVjNQYWQ2YlMxQ3dVQVFHRDBSeU8vMEhDZEliVkpHdUllWDBmYkpXRWV1aXJlSWdjTStUVzdZbXIrVWQvTmpEejhaVGlyMnFtZU1oM2NaaitNUHhCSnVqS0RBUzlRWUpOdkwzNmR4UFAxUUU5ZjZQMzVQK1hGU3ZQVTFra0JBZDl6UnQ1WTM4UkJoR05vaFI4V0t3L2lBeE1ZeDhUelpzMmNMSCtELzkyeml5VVhPZGVBSDdteDk0SVdSaTZvUXZLQ2hXcW9qaG40elR0SkdObXpieDErdW4vZkhyOVE3bDlRSE52V1FtVzBzOXMxSTV5TGZlSmhpMUtUaGhYUTVpQ01zNkFadDQ0ZCszdUJEalB1Q2UwZlJRLzdJOW12ZzRZci9vdC8zS1dpanZwNFAzZzUzWElTanZwdy9IeFYyeWxyMGZWSHBwUmJWQjJjM2V6cS9UQklZVTdyWkY1N04vN3QzaGU0MG0yWHYxKzExRDFnaGZzdmNxUjA0TThRL2V5Yy9mcWQvUTR0MzI4T1ZKb3RudFM5Q3ZsZDVaemIzaUx6aFBHeUFVYWhURGxrODJibzJvR0k1c3ZrQTRZVkFReWgzcHFVTWRsaFlUYUtaTU1aUzN1S05pV2hya3F1akNoNFlVcHFUaTNVcU05SXRYc3NhZ1l5ZXlPZ1pqYWd3Q0J6Ym1NNHRyZVNMRG5NUHhTcFJKUWhrY3J3K3hab2d1bWlYQi9XejYxa2hha0VUN0tjcFRGS3ArMTJpTUtFK3JNRVRnd0lLS1VGVlk1Zi9tMC8xQWVxRFRSL0dIcG1wUTZSNXIwMlhmRFN6ZFk2dS9Jbm53Rzk5YmxIM2pDMENFcGVSRjhXek5wK3lzcXhmaVJ1UlNNV2hybEIrSU1pUHM2dERsd1ZpVUh5cWVUSVlsc0hUcC9IbkxscytkdDF4OCsrcFZxMWRlZGVNYXRPR1gvLzZsOUFZeEt2bVNNZkQrc3Jja2l2MHJRT0JoejR0RWxNY2tYcVora285VGl6Q1R2Y1BGZjNOaDZxU2pFSCtEUUJMNytGZ3ZSa25tNCtVamh4MC84b1JodzBhS3ZwSERobzg4NFhqMnlLOCt0L0Q0VVdPSEhqZCszTEF1UDJHdkNqUEY0eldiMlhxVUNLalZiR0FTemoydWlhQUtZcXVzRnBlNm1maU5SRCtPVEhxUS9vdllIeFRGSFBMbktUUk9FMU5Sdm1PNnZ4ZTd3NVczUzc4WGdmZUtHVW1NZU1rWVlxZi9Xa2RPb1krOVJNYVM4VlBvakJ3NlE4Qjk5NTMyWkdrVno4RUZ3ZDhHc0RPc0xITll3R1FJUWtkd0RqTVpwTTU0WHFSRHI4TW52RkZaTDNVaUtVSkZPSzdaSlFmc25Za0F0ckFGOHNBcUNIaUJqU2dBVDJnRXpwY0RPYmtBTkw0WXNQQytVQUU5WTlkWWNadnMwSFBYV0tHMFpaWkNSWE9NSGRFdEtuZWdUcy91RGIzWHo3NWp1U3lBbTFYMFd5R0tLMjRxSjZGdnR0dzE0YmE1MXo1VlFEYlJmcUpJcnFYWDl5ZkZxMjVhdXY1cnVxZU9mSEpyV1hEZ3JmOGk3a250STljOWZHdHRVK2hXK21IZnJYMlNQOEplelJXM1MxUHd2QWdJQ3hYUHlHaUpzamxyTXlHU2RHeEdCcHM3QXN4SE9aQ1E3NUE0dmFPa1M2R2U2REJlcTFNaG01aUdCYmpwRkVBcldrRkJ4UnZkem15a2RwUEY1WVc4SEQrcW9lMkhXY0I1aUMwVEMyclkvMzVucnVqZXRvWmNzL1BKOWpkdTBPbzJ6NWQxV2tsWXZEaTVYV3hqWHh1VHY0c2tPWXJjdURqNW0yaWFTODlYOElyS3RlVnN0MVJrOU1jcGZTa2RtanhCRDdzUmZ5ajNSS096eEFuLzVQQS9oUDhEc3B4bjBRQUFBSGphblpOUGF4TkJHTWFmelI5YmFTdHQ4U0FvTWhRUEl1Mm1LVVdrUGNXMFNDRzAwSWduTDlQZGNUTnRzaHRtSjVRVUJNRVA0ZEZMTC8wZ29uY3Y2aWZ3Nk1tYjRMT1RTZjlZS3FWWmR2ZTNzKzg4NzV2M2ZSYkF3eUJGZ05GdkZmdWVBOHpqaytjU0p2RFRjeG4zZzhlZUs1Z1B4dkZWVEFjZlBOL0NYUERGOHdSMlMrODhUK0p1NlkvbktUd290enhQSXl4LzlqeURzUExTOHgwOHFYejNQSXZiMVh1ZTV6QlpYV1VsUWVVMm56cXVxb0lEUE1KSHp5WHUvdWE1aktmNDVibUNSOEdHNXlydUJXODkzOEpDY094NUFzZkJEOCtUZUZ6NjZua0t6OHJ6bnFmeHVxdzl6NUIvZTc2RGw1WDNubWN4WDYxNG5zTnNkUUViMEVoNFdwNUhVSWdoZUVvK1MxS0VESDBNWVZ4VWg2c0NKenhYc0l3NmowWHlDOFprZk52bGJvRW0yWEJQY1pWT05VT0tFTmpRaWJiNlNNVWlsbGFLS09zUGpVNDZWcHlJbGVWNmZWRzh5TEtrcTBRek0vM01TS3V6bEx0MktLVW9JTkNtWElyY2tVS1B3czhwM1dXeDJPbXJWTFJsbW91MjZ1bm5XWmRydXd4S01HQ0FaQ1hZVmNtZ0t3bDExbEpuOWV1OE5palZKSTJUakZNc1hVNVJEK3ZMNi9WR3U3bGVKQ3R5TFozbHVuR1JyeGhrR0Q1cWtqZ3REcStVeWRrQVVhVEZkZXE3WmxYYVhZdkpXamVmMk9rVUhUcmdXb1kzbCtaWjdDdzhVVVFOZWQ5enE4WjF0MUN6N2krTWZLTmR0c2l0RlA0WlBlOXpDc2JGeHJ4R3A1N0lDMWVjZFVYblFncHJaS3g2MGh5STdNM1lFREtOUlU4T3haNFNSaVU2dDhyUVJEb1ZrVEpXOHI0L01EcVBkVlJZSnFkbWc5S1IrK3V4SytVcVU2S1JSeXFObFRudk9UaVhXd2F2b2NiajBCMGh0MTBVamJ4azZLakhTSFNzN2EvVmFvZUhoNkgweWhHRnd5anIxVzR1YTluMnZtdXdjazVKR0R0eVRlZzBleHpVZjFQYllWL0ZLdGRKU2xPRkhkdGpmTXROUXJrcGpHWTNPTmN1UytGaXlnMG1sb3diUFYzY1UzejUvOXAzaFNYUnJpM05DbkxPYU9DYWF6dEtOUG95NHMyL1dSUmpmNitFeTFkMzVpeDU2THFTOEczM1FoRTVWMXJZNG53M3NVMmJiL0xUOEVXYzc0aExIbVltcVhWSEJlUzExbFp6Yzd1OXVlUUt1UHlsblBrU2w3KzEwMC9zTHhHdVRyd0FBQUI0Mm0zVlpaUldSUURHOGVjWllCZVc3azRGQTVUMzlyMEdlRk5Bd0VBVUFaVVZsbDBFZDZrVndlNXV4ZTRPVkZCQnNSWHM3Z0lWN083R09Qcyt4MC9PT1hQKzk4NkgrWjM1TWdPRHByR3BEalB4UDRPUC96c05tNkVabXFNRktsQ0psbWlGS3JSR0c3UkZPN1JIQjNSRUozUkdGM1JGTjNSSEQvUkVML1JHSC9SRlAvVEhBQXpFSUd5R3pURVlRN0FGdHNSVzJCcERNUXpiWUZzTVJ3a1diRGh3NGNGSGdCQVJ0c1AyMkFFN1lnUkdZaWZFU0pBaVE0NENPMk1VUm1NTWRzRllqTU40N0lyZHNEdjJ3QVRzaVluWUMzdGpFdmJCWkV6QlZPeUwvYkEvcHFHYXpYRWNqc2RTbklGVGNSTmI0QlNjanZXNEdjdndCQTdBV1ppQloxQ0RKL0UwbnNQemVCRXZvUmF2NHpYVTRXUWNpTm1ZZ3l2UmdIbVlpL2xZZ0lPeENJdHhLQTdEa1RnS1IyTTFLMWlKVGZpTExka0tHN0NSVld5Tk83Q2NiZGdXOTdFZDI3TURPK0pOck1OYjdNVE83TUt1N01idTdNR2U3TVhlN01PKzdNZitITUNCSE1UTnVEa0hjd2kzNEpiY2lsdHpLSWR4RzI3TDRTelJvazJITGozNkRCZ3k0bmJjbmp0d1I0N2dTTzdFbUFsVFpzeFpjR2VPNG1pTzRTNGN5M0VjejEyNUczZm5IcHpBUFRtUmUzRnZUdUkrbk13cG5NcDl1Ui8zNXpSVzh3Qk81d3pXY0NacldjZFpQSkN6T1ljSHNaNE5uTXQ1bk04RlhNaEdIc3hGUElTTHVZU0g4akFlemlONEpJL2kwVHlHeC9JNEhzOFRlQ0pQNHNrOGhhZnlOSjdPTTNnbXorTFpQSWZuOGp5ZXo2VzhnQmZ5SWw3TVMzZ3BMK1BsdklKWDhpcGV6V3Q0TGEvajlieUJOL0ltM3N4YmVDdVg4VGJlemp1NG5DdDRKKy9pM1Z6SlZieUg5M0kxNytQOWZJQVA4aUUrekVmNEtCL2pHcTdsNDN5Q1QvSXBQczFuK0N5ZjQvTjhnUy95SmI3TVYvZ3FYK1ByZklOdjhpMit6WGY0THRkeFBkL2orL3lBRzdpUkgvSWpmc3hQK0NrLzQrZjhnbC95SzM3TmIvZ3R2K1AzL0lFLzhpZit6Ri80SzMvajcveURmM0lULytMZkJvYkdtR2FtdVdsaEtreWxhV2xhbVNyVDJyUXhiVTA3MDk1ME1CMU5KOVBaZERGZFRUZlQzZlF3UFUwdjA5djBNWDFOUDZ6QW5WaUpWVmlEdTNBMzF1SkUzR0w2NDBFOFpBYVlnVGpOREtxb25iTjRicDFWMlZnL3ExUXFaZVhHSlRXcmpCdHFHK3ByWmxkV3E3bGFVMjdGK09ycGpRdHJLdXJMbVZET2duSW1sN09rS1ZXVFp6UXNySjQrdmFaK1lkV1MvejZiSExkVVVpM1ZWaDNWVlQzVlZ3TTFWQ00xVmhNMVZUTTFWNHR5TGZtV2ZFdStKZCtTYjhtMzVGdnlMZm1XZkV1K0pkK1NiOG0zNUZ2eWJmbTJmRnUrTGQrV2I4dTM1ZHZ5YmZtMmZGdStMZCtXYjh1MzVkdnlIZm1PZkVlK0k5K1I3OGgzNUR2eUhmbU9mRWUrSTkrUjc4aDM1RHZ5WGZtdWZGZStLOStWNzhwMzVidnlYZm11ZkZlK0s5K1Y3OHAzNWJ2eVBmbWVmRSsrSjkrVDc4bjM1SHZ5UGZtZWZFKytKOStUNzhuMzVIdnlmZm0rZkYrK0w5K1g3OHYzNWZ2eWZmbStmRisrTDkrWDc4djM1ZnZ5QS9tQi9FQitJRCtRSDhnUDVBZnlBL21CL0VCK0lEK1FIOGdQNUFmeVEvbWgvRkIrS0QrVUg4b1A1WWR5UTdtaDNGQnVLRGVVRzhvTjVVWnlJN21SM0VodUpEZVNHOG1OZE81SWZpUS9raC9KaitSSDhpUDVrWHpkczI0c1A1WWZ5NC9seC9KaitiSDhXSDRzUDVZZnk0L2x4L0pqK2JIOFJINGlQNUdmeUUva0ovSVQrWW44Ukg0aVA1R2Z5RS9rSi9JVCtZbjhWSDRxUDVXZnlrL2xwL0pUK2FuOFZINHFQNVdmeWsvbHAvSlQrYW44VEg0bVA1T2Z5Yy9rWi9JeitabjhUSDRtUDVPZnljL2taL0l6K1puOFhINHVQNWVmeTgvbDUvSnorYm44WEg0dVA1ZWZ5OC9sNS9KeitibjhRbjRodjVCZnlDL2tGL0lMK1lYOFFuNGh2NUJmeUMva0YvSUwrVVdUYjVmSzcvNi90VlJiZFZSWDlWUmZEZFJRamRTNFhFdjdXbGJWekZtMWpmTnJabFF2cUNzdjJhSzlvbm5lT0wraDZjY3IwbjhBVGZKQXFBQUFBUUFCLy84QUR3QUJBQUFBREFBQUFCWUFBQUFDQUFFQUFRSEZBQUVBQkFBQUFBSUFBQUFBZU5wallHUmdZT0JpOEdId1kyQnhjZk1KWVpCS3JpektZVkJKTDByTlp0RExTU3pKWTdCZ1lBR3FZZmovSDBqZ1p3RUJBR2hVRDVKNDJwMlpEWkJXMVhuSG53UEx5aTR1KzRYSVI5ajRzU0dzblZoTEhUOG8yaVNsc0RHT0lxeUtkZEZFaENRSUt5K2lCc0VORXQ1SVVRekJqNUNETVZocHh0bXhkM1JpSEl4TU10TXpkVnFiMUFtVDlEaEdhNk1OalhvU0c1dnEyaGkyditmY2M5K1AzU1ZOTzNmK2MrNDk3N24zUE9kL25vLy92YThZRVdtV1BybE9HaFl0dnJoUFpxM2F2SEdkelAzTXh0VTN5UHgxbjk0MElCZEtBMk5rWkVSMDdPOXpibTVZdlhGQUp1dFpSSU5NaU8xa01WM1A2a2pUTXFGN1F2ZkVXeVp1YlJnRVQwNXFuTlFIQmlmdG9NMG1OVGFlQ0Q1K1F1OEpBeWNNVE9xYjNOdDA1c1JibWxZMHJXM2FCNFk0T3d6MGVtM3poS1o5elJ1YU56UWRidDR3OFphR0ovWGdPWDBnUHhyMTRFa2M4WjU0VjNFMFA5QzhvZUhKcGhVNnZta3RNdy9xWEUxbk5qODZaVzNMZ2VaSDlXZzVOblZUNi9hMmVXMERVOWEyN1drNTFqWUFiUHVtbGdOVDFrN2QxUDRxVjN2YTl1aklOdHRtbTFaMEhPeFFDMWQwZG5jYzdPenUzTlc1cTJPb2M1aTJXM3VuZFUzcjByN2NsbzRodmRheG5jTnR0bk40MnVQVHVsb090RzQvYVphaWJlQ2tIM1h1b24vWDFFMmR3d285OURwaHVPVkEyeDZleVYzdG16cDNUVm5iTVRTOWE4WlpNeDZhZWNyTStUTVB0UTEwSE5TMjVWaG5kd0VkUDcyclkyalc5Rm1QenA3UXVVdFgwVEUwKzZ3NUV4VHhMa1lvNXN5Yjg1MDU3OU1DdmJOcmV0Zmp4VytLMXUwNTlDaHNpak13YTdXblFMRUNSV0ZuYnR2TVF3MkREWVBSSDdZcThNWHVrWktjS3oxeVBsZ0FGc28wV1RTU3llS1JzaXdCdmVDaUVTZEx3V1ZnR2RmTGFmdG9MNmU5QXF3QUF6em5SckFCYk9PM08zakdkdkJGc0lQck12Z1N1QlBzQkhlQnU4RnVjQS8zZnhuc0FYdTUvMTd1dVovK3I0TDk5SDJkOWh1MEI3RHRDYzRQTWVZd3JRTXZqSGg1aWV1WE9YK045aWp0NnlDQVlmQWVlQi84ZHNRWk0xSXlVMEVybURrU3pPeVJzamtWbkE0K0JIckFVc0FhelRxd25uRzNncytQZUxPWjlqYmFMYlJiYVFmNWZSdnRkbkFQNTN2QVh1WXg4aEU1SkIrVnVTTld6Z0R6d2RuZ1hHdzdEMXZQWjh3Q3NCQnNwSDh6dUExc0FUeFhiZ2VENEQ2dUh3UUhHRGZFdlk5eC9pM2FaMm4vQVR6SCtmZmg2Zm1SZmpuQytSdjB2Y1hZdDBlc21ReG1qUFNiV2JRZndLNHVjQXJucDRGdWdHMW1IbGpDV25wcEx3V1hnZVZjOTlGZXp2Z3J3ZFZjOTNPOWttZGR3L1cxdEoraVhRVldnNDFjMzBTN216RmZCbDhCKytsN0VEdGFXSEdHNVJsV1oxaWJZV1dHbFI0TFBUTm56T3laTVdOR3owd1pNM24yZHhKcmFRWnp1VG9EZk1RMHc2R0hReDg1UEorbkxBQTVmeDcrUFB4NStGUE9QSng1NWN6Z0krWVp4bmRLSzZQYlFYZDhndU1KZ1NjRStST3VGOUplQUFZNHZ4RnNBSHZqRTRJOERCNEJmNE9uUEkxOWgzbEdjOFd1d3FiajJhQitzSVh4cmRqWkRrNGp0dFNDVVRQeDVMSlJYejZabGZlejh2NHhNNXdMenNPTzgya1hSSnZkbUZtMzh2dnRZQkJVV1hDdzBBOEwvZXhHNjdGM3BCMncvM0hsK2FvdHRsaHNzZGhpaXhXYnA0KzlZdzR6OW1QUityYklYN0dDMGxqNzZGL0VISXY1RFk4aVk1VElHQ1V5aGlWaldESkdpWXhoeVJnbE1vWWxZNVRKR0ZhdTR0Ni9BRmNEM2Z1VnpGT2JSVWF2Y1J0OWR6RFBkdkJGc0lQck12Z1N1QlBzQkhlQnU4RnVjQTl6NEpWa0ZadXlTbi9rNW43T3Z3cjJ4d2p6WkpjUzJhVXNmOFg4QjlubmI0T25RTEV6VGJEZ1ljQ3pldVVzWUdIQXdzQlQxVE04bzd5Y3d5akxLSnQ0eXVBcHdGT0Fwd0JQQVk0OEhIazQ4bkRrNFNqQVVZQ2pBRWNlamdJY2VUZ0tjQlRnU0dmTG1DMWp0Z3crQW53RStBandFZUREdzRlSER3OGZIajQ4ZkhqNDhQRGg0Y1BEaDRjUER4OGVQZ0o4QlBoUXl6UDRVRzhOOE9IaHc4TkhnSThBSHg0K2RHV1dsVmtxUTcwUGw4ZDR3Q0pHTFFaTEFQbUVsZm1hZW1GVHZiQ3BYbVN4WHF5TXNWQm1kV1ZXVng1bnR5MnJzNnpPc2pyTDZpeXJzNnpPc2pyTDZpeXJzNnpPc2pvN3FvYVVXWjFOdTIxWm5ZMTFKTjl0eStveWR0dXoyOVg0YXg2elg2UDV2aS94MDBDa0JpSTFFRjJCNkFveXBlZ1p4NmNETXdWbXFvN21mbmhzbGg1ekNEekR1ZlpvcnRoQ3p4WjZ0a2g3bmFlb2QvUkZUdjczWFM1MlUzZHhOczlkeG5PWGpldDd0VS85di9qUnZmV3pZUE15YkY1R25CU3pGUm4zdExqR1pURjdNaUptVUdYUHd4WDNnV2M0UDRzZU1tdXNGbVdxUlZtZW92YzU5dWtmYVorblBVS2ZWbzQzd1Z1cGdqUUM3cUhPYVkzTHFIR1orV05BZlRCL0R0QXVxY0xZV0dISVBPWUsyaXRwVjhTS1U5YUtRMjJ6MURaUGJiUFVOazlOczlRMGIxaWhlUUN3U3JNUGZBMVlRTmFndm5uek1ITWMwblZoOSs2NlBQa1lGajZCMWJsS3NhZ1VTOVgyVkcxV3hXNXIxWDZSdnArQWx4ai9NdVAraGQ5ZUFmOUszMC9CcStBMWZ2czMycCtCbzR6NWQ5cWZnOWRqdGM5Z0kwUGxsT1FYM1BmTFdQMnQvQWY0RlhpYjMvNlQ5dGZndi9qOUhkcDNpWUJoeHI4SGZzUDErN1MvaFFVREpyQ3FCakFKTkxLcUU2S0s4S1lKdEhDZXE2YXlJYitaVG5BU21BbG04ZnRzZnB0RCswRndDamlWNjlOb1Q2ZWw0cUdzU2lnT2J6NE01b0VlcmxGRjVoeHdIbGdJTHFUL28rRGpuSk5OMkxuTVhFUjdNYmdrS2hTUE1pdWhVanpxckdTVzQxbDlqQ0dic0p1WkllYll6WXlkMUYyMDVqcXdDbHpQMk5XMGEyZy94NWdiT0Y4SDFyTVdLcDhweGQyMjVtYWdTazlWbmlxOFFVQWNHR0xBN0tTTzd1SjNNZzFLUjlWZUNiWGpVWHdsRkk5SDlaWE1mZEZiTWp3bHcwc3lQTVNhaDhBQm9Gbm1tMkIwWFRrNWVrcmhHZC9QZlR1eVBpc3hxU3dxZzNNVGM4cUNNcUQrcXI2NkNxd0c2cTlxbVZxbEZtbWVtelBtNmMvWHpERGo5NWhsWlpycDJzcHNObks1Y1p3Wjk2ZFovNnhTS3g0anc0eU5nb0ExQVd1Y2VOcVg4TktYdWVzMTJxTzByNE9RWW53WXZBZitXOWJncVI1UERYaHFaaWJLR2xZUWtrZG1yRUoxdks0azRIbTZtb0RuNllvQ25xZXJDcXdxNEhYZW5NMjlpOEdsWEMrTnF3eDRVejJmMTdQYnl1a2EydHhUc3JqYWV1L1ExUWM4UVJrSWVJS3lFTXplbklYS0R2ZFUxT3hRVk8rRmFpK3ltbzFacmNob3pYRmZhck9aSjV0NXNwbnFaWnV5V1NsbHMwS2gyM0d6V0hXdjhtejJCWEJIWGZieUZZWGNYbVJrOWlxb2w4QnRpQjZ5TXUxKzRXY2JJdzhCSGdJOGhManJSUmFmWEdSOTdBL1lIN0F4WUdOVk8wK1F4K1duWmllc25GT3BFRVBSU3p6Y2hKajFlWnFvbXZvdStCNTlMbFlDRnl2QkQ1SVBINkgveDlGN0FwNmpYcUhlNFBHR1lLWW55d3NiTHVEOFQybVhBRlJJeGFhcllnVUlsUlYrRnF3RDYrbkxWNmx2ZlBxMjV3MDEwWlRwdnhmY255ckMxNUxQUHdMK091NTR2c2JaRloyZHY2ZmErSjZxcTlGMzFSL0VkMVhON0Jhck5hdGFyTGFtSTFsNlZjVVNmZmZVakdTeHdtS0ZqVlpVWmt2Ni9Ld2FIbjNpMGNPakc4V2pyK0hSUlN1T2dCOUhhOGJqY0RSLzZuOCs4ZWZnenlYKzZua2J5NW1ITTYya0RzNGNuTGt4ZkJsNUYzL29pdHE1TGFwc3JZbU9yS0IyT2JKQ0lDc0Vza0lnSXdReVFpQWJxTDBPV3gyUnIxR3ZFYS9ScmxHdWthMVJIYkRKRWFrYXBScWhHcDJCSE96SndiNmliV2ZHL0hPODNQTityRzQrNXBYVFl5WHpNWThzalZXb21qZXVqL2tpejRxRHNVTDRtQk5TUGxBZGx2U2gxdmszYU44RXY0aXpCV0kvVUhORHJJRzl0SDBncjJlQkdRSXpoRmk3YnFMZEVldE1vTTRFNmt6ZzZhRlNYd3A5MlZUeGlwZGlidld3cFR1cnUxUmx2aHViVUwwZ3Q4bGlrMHMyWmZFclFpUDhhZjB2YXJ2Vzc5eEdHNzhTWE1IdktQbGtxK2FmREZ1ekNodTV6Vm0wZVdlMDIyRzN3MjZIM1ZtTjNXWHNMc3VzR2gyWWUvSno4ZnRHRnIyMStISXdJMllZaDNlNjZKVzFYeEVLNzd3NldxVDVLeU82TXlJNkkxcXJldTNNU2w2dTNmMkNnOXdMbkhKUTV3a0ZIek5UeFNsNHFmV09EeWNQVVk0S0wrbEx5bk5GaFNjSFQ2N0dhOXdZcjZubnlsVnlkUWQ3UzhZR1Q4UW96NGh5UjNTN3VyMmV5anBiWTJTNnVPZTNjcjBaYklucW84VCtsMlJIWGN3TkVZVzViczNrVzV5eko2SmU0a0M5ZG5WeWhQWkYycC9FV1MwY1pqWDYxYUZmSGZyVmFaWkR2enIwcThaeGhuNTE2RmNIMTZwYnM2UmJYZEt0RHQzcTBLd096ZXFTWmxXOW1zRi9oZ3JvUWJNNjlpRkxYL0lzbXRXaEJuclFyUTdkNnRDc0xtcWJGdHFwK0pSbTFuYk9PK2s3aVhZbXlQVnFsblJxbG5ScWxuUnFWdEZBUFp6UFovelpQUDhjMnZQQVFsRFZxUTZkNmxBVFBXWUp1SWp6aThFbElOZXFXZEtxV2RTcUdpTlgwMWIxcVJ1ak5uSjlxcW9qaTluL1JzNUxJTmVuamwwc3M0dGxkckdNdjJRVmZicUwzKzRHdVRiTmtqYk5ramJOb2piTjlhZ3orazJvcWtmcmN5RzFDNGJiNDY2NnBNdGNYVzZzallacUJqNStmbHcvam1jL1RaLzY3Q25Fb0NNR0hkSHVVQVpyaUhnWGExUWU4YTVPRzlWSHZVdFI3MUxVNjF1ZDFpTlhpZnBjQzJYcGpTNVhjUHVqTHRkODQ0Z2xGOTlFb3dXVm5sTmpES0JTYW5SellVY1c3VkQvT2xrdWlEbmdlUHE1dDBaRDk2Vk1WT1RHVlNudVY5T3VTZm14WHJsbnZCZG85YXV0ZkcrTnFuNi9xK29WRlVPcnhlanFwMTh2dWl2ZkdWV1Q1cnlyTHUyRjkzTFNwRm5pWGQrdXkvQmVndmRTMHFENDgwaHZmUGZTTjJwOW04NDFhQWJ2NWNSN09XblErclZ1cEQvZmgzTGFoL3piNVBSS05zNi9ZZnRZZlVaWG5tclZxYzJrWSt2dmd6WEtka3BOSlhGYVJTcTZwcXBuY2oybzMyczIxYnk3NUpsd3ZDeW9IdkZDZklPdnpZRDJkMlErVzVQNUxQdHBVOWJMeG1ROXpYanZ4aml6N0xXdHlYcVdySmY5UDdPZVQxblBwcXhuVTlhektldlptcXhueDgxNnRkbHViS2F6S2ROVkZjQjFjZWN6OWlRN1RrYkxLaG50ODdFMmxjMXRzVDZWelZiYVFjWitnVjNaeHZrZHROdHA2N09jVFZuT3BpeG5vNklvTWx6dGw5dENDVlYxYm12VWhxRk9DUldacVBDV2NwM3VlRFBGWVA3ZEtSeEhnNVFyMzVueXFQQTEyU2lrYkJSU05ncDFLaTdQVEtHU2g5cXd5R0tSclh6MUtyNTQ5YWFjVW8yQy9DdlZ2dlIxaWpjT25tQ2xrVFZVdlgxNXRDdDZ1c3l0ckZaai83bkt0d0g5YjhhbDZGT2RVNnhTbzFDZm9wRVlpTVNBRFM0K3NTL0dqOW9TWXY1ZFFkdFAzK2o4T3pZUGpKK1BKOFd2RTBWTXAxam1yZkZqL0RJcC9uTStoZmVGVnQ1WEo3Sm5QYXp4VFBsRE9WSG15OWt5VmM2VkMvbGxrU3hHMC9mS0orUUQ4a21PTHJtRTQ0T3lWSlpUY1M3bjZKWXJPVDRrVjBrL1hGekRjWVlNeUMzeUI3SlpCbm5TTnRrdUM2UXNPK1VDdVV0Mk0vdFg1RDZlKzREczQ3a1BjbnhTRHNqRGNyRTh3bkVKeXVreHVWU2VrQ2RsbVR6RmNZVWNrc1BNOEYzNUhqUDhMY2MxOGl6SHRmTDM4ay95S2ZraCt1a3o4aVA1Wi9tY3ZNQ3hUbDZVVjJTOXZNcHhreHpsMkNRLzU3aFozcEJmWXRldjVHM1pJcitXZCtSMkdaYmZ5RFpqVElQc01JMm1VWGFheWVaRStVc3oxYlRMUFdhNm1TNTd6UXd6VCs0MWYyUXVrNE5tdWJsRy9zNTgycXlSSDVyUG12WGl6UWFENWpXYnpNM3lpcm5WM01iNytGYXpWWDVtQnMyZGN0VHNOaWd4ODNYemtCd3pENXR2R2pIZk50OWhwc01jSi80UG1aa3NSd0FBQUFBQUFRQUFBQURVSkppNkFBQUFBTWxNNm4wQUFBQUExZnV3M2dBQldkWUFYZ0FBKSBmb3JtYXQoJ3dvZmYnKTtmb250LXdlaWdodDo2MDA7Zm9udC1zdHlsZTpub3JtYWx9QGZvbnQtZmFjZXtmb250LWZhbWlseTonT3BlbiBTYW5zJztzcmM6dXJsKGRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBTDd3QUJNQUFBQUJnUVFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkdSbFJOQUFBQnFBQUFBQndBQUFBY2M0OTk4MGRFUlVZQUFBSEVBQUFBSGdBQUFCNEFKd0hNUjFCUFV3QUFBZVFBQUErR0FBQWd2cnBzL3BSSFUxVkNBQUFSYkFBQUFEZ0FBQUJRa3p5Q1MwOVRMeklBQUJHa0FBQUFZQUFBQUdDaVNNYi9ZMjFoY0FBQUVnUUFBQUp1QUFBRDVoUTJIQWhqZG5RZ0FBQVVkQUFBQUM0QUFBQXVFbTROY0dad1oyMEFBQlNrQUFBQnNRQUFBbVZUdEMrbloyRnpjQUFBRmxnQUFBQUlBQUFBQ0FBQUFCQm5iSGxtQUFBV1lBQUFtR0FBQVRxMHVOSFJOV2hsWVdRQUFLN0FBQUFBTmdBQUFEWUg2QzJhYUdobFlRQUFydmdBQUFBaEFBQUFKQkhLQ05ob2JYUjRBQUN2SEFBQUJETUFBQWNZbzQ2WlFteHZZMkVBQUxOUUFBQURqZ0FBQTQ2dWhHSThiV0Y0Y0FBQXR1QUFBQUFnQUFBQUlBTG1BZUp1WVcxbEFBQzNBQUFBQWY4QUFBUnVUdjZiY1hCdmMzUUFBTGtBQUFBRmJ3QUFETFd0L1QwYWNISmxjQUFBdm5BQUFBQjFBQUFBaTVYOWM3NTNaV0ptQUFDKzZBQUFBQVlBQUFBR0FHcFoxZ0FBQUFFQUFBQUExRkcxYWdBQUFBREpRaGVnQUFBQUFOWDdzT2dBQVFBQUFBd0FBQUFXQUFBQUFnQUJBQUVCeFFBQkFBUUFBQUFDQUFBQUFIamFuWmtOa0ZiVmVjZWZBOHZLTGk3N2hjaEgyUGl4SWF5ZFdFc2RQeWphSktXd01ZNGlySXAxMFVTRUpBZ3JMNklHd1EwUzNraFJETUdQa0lNeFdHbkcyYkYzZEdJY2pFd3kwek4xV3B2VUNaUDBPRVpyb3cyTmVoSWJtK3JhR0xhLzU5eHozNC9kSlUwN2QvNXo3ajN2dWZjODUzK2VqLys5cnhnUmFaWSt1VTRhRmkyK3VFOW1yZHE4Y1ozTS9jekcxVGZJL0hXZjNqUWdGMG9EWTJSa1JIVHM3M051YmxpOWNVQW02MWxFZzB5STdXUXhYYy9xU05NeW9YdEM5OFJiSm01dEdBUlBUbXFjMUFjR0orMmd6U1kxTnA0SVBuNUM3d2tESnd4TTZwdmMyM1RteEZ1YVZqU3RiZG9IaGpnN0RQUjZiZk9FcG4zTkc1bzNOQjF1M2pEeGxvWW45ZUE1ZlNBL0d2WGdTUnp4bm5oWGNUUS8wTHloNGNtbUZUcSthUzB6RCtwY1RXYzJQenBsYmN1QjVrZjFhRGsyZFZQcjlyWjViUU5UMXJidGFUbldOZ0JzKzZhV0ExUFdUdDNVL2lwWGU5cjI2TWcyMjJhYlZuUWM3RkFMVjNSMmR4enM3TzdjMWJtclk2aHptTFpiZTZkMVRldlN2dHlXamlHOTFyR2R3MjIyYzNqYTQ5TzZXZzYwYmo5cGxxSnQ0S1FmZGU2aWY5ZlVUWjNEQ2ozME9tRzQ1VURiSHA3SlhlMmJPbmROV2RzeE5MMXJ4bGt6SHBwNXlzejVNdysxRFhRYzFMYmxXR2QzQVIwL3ZhdGphTmIwV1kvT250QzVTMWZSTVRUN3JEa1RGUEV1UmlqbXpKdnpuVG52MHdLOXMydDYxK1BGYjRyVzdUbjBLR3lLTXpCcnRhZEFzUUpGWVdkdTI4eEREWU1OZzlFZnRpcnd4ZTZSa3B3clBYSStXQUFXeWpSWk5KTEo0cEd5TEFHOTRLSVJKMHZCWldBWjE4dHArMmd2cDcwQ3JBQURQT2RHc0FGczQ3YzdlTVoyOEVXd2crc3krQks0RSt3RWQ0Rzd3VzV3RC9kL0dld0JlN24vWHU2NW4vNnZndjMwZlozMkc3UUhzTzBKemc4eDVqQ3RBeStNZUhtSjY1YzVmNDMyS08zcklJQmg4QjU0SC94MnhCa3pVakpUUVN1WU9STE03Skd5T1JXY0RqNEVlc0JTd0JyTk9yQ2VjYmVDejQ5NHM1bjJOdG90dEZ0cEIvbDlHKzEyY0EvbmU4QmU1akh5RVRra0g1VzVJMWJPQVBQQjJlQmNiRHNQVzg5bnpBS3dFR3lrZnpPNERXd0JQRmR1QjRQZ1BxNGZCQWNZTjhTOWozSCtMZHBuYWY4QlBNZjU5K0hwK1pGK09jTDVHL1M5eGRpM1I2eVpER2FNOUp0WnRCL0FyaTV3Q3VlbmdXNkFiV1llV01KYWVta3ZCWmVCNVZ6MzBWN08rQ3ZCMVZ6M2M3MlNaMTNEOWJXMG42SmRCVmFEalZ6ZlJMdWJNVjhHWHdINzZYc1FPMXBZY1libEdWWm5XSnRoWllhVkhnczlNMmZNN0preFkwYlBUQmt6ZWZaM0VtdHBCbk81T2dOOHhEVERvWWRESHprOG42Y3NBRGwvSHY0OC9IbjRVODQ4bkhubHpPQWo1aG5HZDBvcm85dEJkM3lDNHdtQkp3VDVFNjRYMGw0QUJqaS9FV3dBZStNVGdqd01IZ0YvZzZjOGpYMkhlVVp6eGE3Q3B1UFpvSDZ3aGZHdDJOa09UaU8yMUlKUk0vSGtzbEZmUHBtVjk3UHkvakV6bkF2T3c0N3phUmRFbTkyWVdiZnkrKzFnRUZSWmNMRFFEd3Y5N0VicnNYZWtIYkQvY2VYNXFpMjJXR3l4MkdLTEZadW5qNzFqRGpQMlk5SDZ0c2hmc1lMU1dQdm9YOFFjaS9rTmp5SmpsTWdZSlRLR0pXTllNa2FKakdISkdDVXloaVZqbE1rWVZxN2kzcjhBVndQZCs1WE1VNXRGUnE5eEczMTNNTTkyOEVXd2crc3krQks0RSt3RWQ0Rzd3VzV3RDNQZ2xXUVZtN0pLZitUbWZzNi9DdmJIQ1BOa2x4TFpwU3gveGZ3SDJlZHZnNmRBc1ROTnNPQmh3TE42NVN4Z1ljREN3RlBWTXp5anZKekRLTXNvbTNqSzRDbkFVNENuQUU4Qmpqd2NlVGp5Y09UaEtNQlJnS01BUng2T0FoeDVPQXB3Rk9CSVo4dVlMV08yREQ0Q2ZBVDRDUEFSNE1QRGg0Y1BEeDhlUGp4OGVQanc4T0hodzhPSGh3OFBIeDQrQW53RStGRExNL2hRYnczdzRlSER3MGVBandBZkhqNTBaWmFWV1NwRHZRK1h4M2pBSWtZdEJrc0ErWVNWK1pwNllWTzlzS2xlWkxGZXJJeXhVR1oxWlZaWEhtZTNMYXV6ck02eU9zdnFMS3V6ck02eU9zdnFMS3V6ck02eU9qdXFocFJablUyN2JWbWRqWFVrMzIzTDZqSjIyN1BiMWZockhyTmZvL20rTC9IVFFLUUdJalVRWFlIb0NqS2w2Qm5IcHdNekJXYXFqdVorZUd5V0huTUlQTU81OW1pdTJFTFBGbnEyU0h1ZHA2aDM5RVZPL3ZkZExuWlRkM0UyejEzR2M1ZU42M3UxVC8yLytORzk5Yk5nOHpKc1hrYWNGTE1WR2ZlMHVNWmxNWHN5SW1aUVpjL0RGZmVCWnpnL2l4NHlhNndXWmFwRldaNmk5em4yNlI5cG42YzlRcDlXampmQlc2bUNOQUx1b2M1cGpjdW9jWm41WTBCOU1IOE8wQzZwd3RoWVljZzg1Z3JhSzJsWHhJcFQxb3BEYmJQVU5rOXRzOVEyVDAyejFEUnZXS0Y1QUxCS3N3OThEVmhBMXFDK2VmTXdjeHpTZFdIMzdybzgrUmdXUG9IVnVVcXhxQlJMMWZaVWJWYkZibXZWZnBHK240Q1hHUDh5NC82RjMxNEIvMHJmVDhHcjREVisremZhbjRHampQbDMycCtEMTJPMXoyQWpRK1dVNUJmYzk4dFkvYTM4Qi9nVmVKdmYvcFAyMStDLytQMGQybmVKZ0dIR3Z3ZCt3L1g3dEwrRkJRTW1zS29HTUFrMHNxb1Rvb3J3cGdtMGNKNnJwcklodjVsT2NCS1lDV2J4KzJ4K20wUDdRWEFLT0pYcjAyaFBwNlhpb2F4S0tBNXZQZ3ptZ1I2dVVVWG1ISEFlV0FndXBQK2o0T09jazAzWXVjeGNSSHN4dUNRcUZJOHlLNkZTUE9xc1pKYmpXWDJNSVp1d201a2g1dGpOakozVVhiVG1PckFLWE0vWTFiUnJhRC9IbUJzNFh3ZldzeFlxbnluRjNiYm1acUJLVDFXZUtyeEJRQndZWXNEc3BJN3U0bmN5RFVwSDFWNEp0ZU5SZkNVVWowZjFsY3g5MFZzeVBDWERTekk4eEpxSHdBR2dXZWFiWUhSZE9UbDZTdUVaMzg5OU83SStLekdwTENxRGN4Tnp5b0l5b1A2cXZyb0tyQWJxcjJxWldxVVdhWjZiTSticHo5Zk1NT1AzbUdWbG11bmF5bXcyY3JseG5CbjNwMW4vckZJckhpUERqSTJDZ0RVQmE1eDQycGZ3MHBlNTZ6WGFvN1N2ZzVCaWZCaThCLzViMXVDcEhrOE5lR3BtSnNvYVZoQ1NSMmFzUW5XOHJpVGdlYnFhZ09mcGlnS2VwNnNLckNyZ2RkNmN6YjJMd2FWY0w0MnJESGhUUFovWHM5dks2UnJhM0ZPeXVOcDY3OURWQnp4QkdRaDRncklRek42Y2hjb085MVRVN0ZCVTc0VnFMN0thalZtdHlHak5jVjlxczVrbm0zbXltZXBsbTdKWktXV3pRcUhiY2JOWWRhL3liUFlGY0VkZDl2SVZoZHhlWkdUMktxaVh3RzJJSHJJeTdYN2haeHNqRHdFZUFqeUV1T3RGRnA5Y1pIM3NEOWdmc0RGZ1kxVTdUNURINWFkbUo2eWNVNmtRUTlGTFBOeUVtUFY1bXFpYStpNzRIbjB1VmdJWEs4RVBrZzhmb2YvSDBYc0NucU5lb2Q3ZzhZWmdwaWZMQ3hzdTRQeFBhWmNBVkVqRnBxdGlCUWlWRlg0V3JBUHI2Y3RYcVc5OCtyYm5EVFhSbE9tL0Y5eWZLc0xYa3M4L0F2NDY3bmkreHRrVm5aMi9wOXI0bnFxcjBYZlZIOFIzVmMzc0ZxczFxMXFzdHFZaldYcFZ4Uko5OTlTTVpMSENZb1dOVmxSbVMvcjhyQm9lZmVMUnc2TWJ4YU92NGRGRks0NkFIMGRyeHVOd05IL3Fmejd4NStEUEpmN3FlUnZMbVljenJhUU96aHljdVRGOEdYa1hmK2lLMnJrdHFteXRpWTZzb0hZNXNrSWdLd1N5UWlBakJESkNJQnVvdlE1YkhaR3ZVYThScjlHdVVhNlJyVkVkc01rUnFScWxHcUVhbllFYzdNbkJ2cUp0WjhiOGM3emM4MzZzYmo3bWxkTmpKZk14anl5TlZhaWFONjZQK1NMUGlvT3hRdmlZRTFJK1VCMlc5S0hXK1RkbzN3Uy9pTE1GWWo5UWMwT3NnYjIwZlNDdlo0RVpBak9FV0x0dW90MFI2MHlnemdUcVRPRHBvVkpmQ24zWlZQR0tsMkp1OWJDbE82dTdWR1crRzV0UXZTQzN5V0tUU3pabDhTdENJL3hwL1M5cXU5YnYzRVlidnhKY3dlOG8rV1NyNXA4TVc3TUtHN25OV2JSNVo3VGJZYmZEYm9mZFdZM2RaZXd1eTZ3YUhaaDc4blB4KzBZV3ZiWDRjakFqWmhpSGQ3cm9sYlZmRVFydnZEcGFwUGtySTdveklqb2pXcXQ2N2N4S1hxN2QvWUtEM0F1Y2NsRG5DUVVmTTFQRktYaXA5WTRQSnc5Umpnb3Y2VXZLYzBXRkp3ZFByc1pyM0JpdnFlZktWWEoxQjN0THhnWlB4Q2pQaUhKSGRMdTZ2WjdLT2x0alpMcTQ1N2R5dlJsc2llcWp4UDZYWkVkZHpBMFJoYmx1emVSYm5MTW5vbDdpUUwxMmRYS0U5a1hhbjhSWkxSeG1OZnJWb1Y4ZCt0VnBsa08vT3ZTcnhuR0dmblhvVndmWHFsdXpwRnRkMHEwTzNlclFyQTdONnBKbVZiMmF3WCtHQ3VoQnN6cjJJVXRmOGl5YTFhRUdldEN0RHQzcTBLd3VhcHNXMnFuNGxHYldkczQ3NlR1SmRpYkk5V3FXZEdxV2RHcVdkR3BXMFVBOW5NOW4vTms4L3h6YTg4QkNVTldwRHAzcVVCTTlaZ200aVBPTHdTVWcxNnBaMHFwWjFLb2FJMWZUVnZXcEc2TTJjbjJxcWlPTDJmOUd6a3NnMTZlT1hTeXppMlYyc1l5L1pCVjl1b3ZmN2dhNU5zMlNOczJTTnMyaU5zMzFxRFA2VGFpcVIrdHpJYlVMaHR2anJycWt5MXhkYnF5Tmhtb0dQbjUrWEQrT1p6OU5uL3JzS2NTZ0l3WWQwZTVRQm11SWVCZHJWQjd4cms0YjFVZTlTMUh2VXRUclc1M1dJMWVKK2x3TFplbU5MbGR3KzZNdTEzemppQ1VYMzBTakJaV2VVMk1Nb0ZKcWRITmhSeGJ0VVA4NldTNklPZUI0K3JtM1JrUDNwVXhVNU1aVktlNVgwNjVKK2JGZXVXZThGMmoxcTYxOGI0MnFmcityNmhVVlE2dkY2T3FuWHkrNks5OFpWWlBtdktzdTdZWDNjdEtrV2VKZDM2N0w4RjZDOTFMU29QanpTRzk4OTlJM2FuMmJ6alZvQnUvbHhIczVhZEQ2dFc2a1A5K0hjdHFIL052azlFbzJ6cjloKzFoOVJsZWVhdFdwemFSajYrK0ROY3AyU2swbGNWcEZLcnFtcW1keVBhamZhemJWdkx2a21YQzhMS2dlOFVKOGc2L05nUFozWkQ1Ymsva3MrMmxUMXN2R1pEM05lTy9HT0xQc3RhM0plcGFzbC8wL3M1NVBXYyttckdkVDFyTXA2OW1hckdmSHpYcTEyVzVzcHJNcDAxVVZ3SFZ4NXpQMkpEdE9Sc3NxR2UzenNUYVZ6VzJ4UHBYTlZ0cEJ4bjZCWGRuRytSMjAyMm5yczV4TldjNm1MR2Vqb2lneVhPMlgyMElKVlhWdWE5U0dvVTRKRlptbzhKWnluZTU0TThWZy90MHBIRWVEbEN2Zm1mS284RFhaS0tSc0ZGSTJDblVxTHM5TW9aS0gyckRJWXBHdGZQVXF2bmoxcHB4U2pZTDhLOVcrOUhXS053NmVZS1dSTlZTOWZYbTBLM3E2eksyc1ZtUC91Y3EzQWYxdnhxWG9VNTFUckZLalVKK2lrUmlJeElBTkxqNnhMOGFQMmhKaS9sMUIyMC9mNlB3N05nK01uNDhueGE4VFJVeW5XT2F0OFdQOE1pbitjejZGOTRWVzNsY25zbWM5clBGTStVTTVVZWJMMlRKVnpwVUwrV1dSTEViVDk4b241QVB5U1k0dXVZVGpnN0pVbGxOeEx1Zm9saXM1UGlSWFNUOWNYTU54aGd6SUxmSUhzbGtHZWRJMjJTNExwQ3c3NVFLNVMzWXorMWZrUHA3N2dPemp1UTl5ZkZJT3lNTnlzVHpDY1FuSzZURzVWSjZRSjJXWlBNVnhoUnlTdzh6d1hma2VNL3d0eHpYeUxNZTE4dmZ5VC9JcCtTSDY2VFB5SS9sbitaeTh3TEZPWHBSWFpMMjh5bkdUSE9YWUpEL251Rm5la0Y5aTE2L2tiZGtpdjVaMzVIWVpsdC9JTm1OTWcrd3dqYVpSZHBySjVrVDVTelBWdE1zOVpycVpMbnZOREROUDdqVi9aQzZUZzJhNXVVYit6bnphckpFZm1zK2E5ZUxOQm9QbU5adk16ZktLdWRYY3h2djRWck5WZm1ZR3paMXkxT3cyS0RIemRmT1FIRE1QbTI4YU1kODIzMkdtd3h3bi9nK1ptU3hIQUFCNDJtTmdaR0JnNEdMd1lmQmpZSEZ4OHdsaGtFcXVMTXBoVUVrdlNzMW0wTXRKTE1sanNHQmdBYXBoK1A4ZlNPQm5BUUVBYUZRUGtnQURCT0lDdkFBRkFBUUZtZ1V6QUFBQkh3V2FCVE1BQUFQUkFHWUIvQWdDQWdzSUJnTUZCQUlDQk9BQUF1OUFBQ0JiQUFBQUtBQUFBQUF4UVZOREFDQUFEU1g4Qm1iK1pnQUFDRkVDZ0NBQUFaOEFBQUFBQkY0RnRnQUFBQ0FBQW5qYXZaTlpTRlZSRklhL2ZiMXBXWmFORHBrZHJjeEdtMHNiTFp0bmJiYXlzb25tT1N1emVTNGJLQXBLRThVSjA0ZXd0Qnk0RFFoaDFFTVJsSUtlaWw2Q2VtaUE2TXBxYzd3MFlOQmJHOWEvMTlxY2M3NXoxdm9QNEVaOUJLQzBvcXAxcGF6YXJoeDZYOGNvR3RFVEw1SklJNE5NY3NtamdFS0tLY0hCZlI1U3lWT2U4NEtYVkZQTGE5N3lubzk4NWl2ZmNDTEtRL21wS0JXallsV2lyY0wyeWxadFAyb1h3OU5vWS9nYmdVYXdFV0tFR1JGR25IRWpLTGlMVTBSVHZUQTBMVjNUY2pRdC93OWFCVTk0WnRHcXFMRm83L2pBSjR2MlhkUHN5bGRGcW1pMVFDVzRhTmlQR3hqZWhxOFI0S0tGLzZMSkYza2o5K1dlT0tSY3lxUlVpcVJRYmtxQjVNc055Wk5jeVpKTXlaQjBTWlBya2lvcGNsV3V5R1c1SkJmbGdpUkxrc3lWU1JJbG9YVTFkWS9yS3AwNXptd3oyMHczcjV1cDVsWHppbm5PUEdiR216NjE2VldQNmp2ODM1YTd6ZE9hS0EyNENwc3JzLzNqR2ZWM3VtSFhIbkRIZzhZMHdaT21OTk1UYWs0THZHbEpLMXJUaHJhMHd3ZGYvUENudlhaUEJ3THBxS2NZUkRDZDZFd1hRdWhLS04zb1RnL3RwMTcwSm93KzlLVWYvUm5BUUFZeG1DR0VFOEZRaGpHY0VZelUzb3RrTkdPSVlpempHTThFSmpLSnlVeGhLdE9Zemd4bUVrME1zNWpOSE9ZeWova3NJSmFGTEdJeGNTeGhxWDcvVFRxMnNFM3JIdTFpMk04QkRscGZkcGlqSE9FWXg2M3FCQ2UxbnRKeG1qUFdTVEpuT1dkbDhTelg3U2pUMlQ3V3NFbzlaQzByZGJYNXQyNnQrRXNIRHpVNFdjMTZWYzR5TmxqVk5WTFVMWFZiM1ZVbHFrZ1ZXMmZudGZkUkQ1UkQzZnM1aUR1cVZHOGIyYTUxQjF1MTdpUkI2eTUydXk3WlM2TFdUTEpkZFpiK2Q2MzFBOXV2MDdnQUFBQUFCQ1lGYlFEMUFOY0E2QUR4QVNJQklnRW1BTWtCSUFEL0FSY0JCQUVOQVBzQkN3Qy9BSklBZ0FCRUJSRUFBSGphWFZHN1RsdEJFTjBORHdPQnhOZ2dPZG9VczVtUXhudWhCUW5FMVkxaVpEdUY1UWhwTjNLUmkzRUJIMENCUkEzYXJ4bWdvYVJJbXdZaEYwaDhRajRoRWpOcmlLSTBPenV6Yzg2Wk0wdktrYXAzNld2UFUrY2trTUxkQnMwMi9VNUl0Yk1BOTZUcjY0Mk10SU1IV214bTlNcDErLzRMQnB2UmxEdHFBT1U5YnlrUEdVMDdnVnEwcC83Ui9BcUcrL3dmOHpzWXREVFQ5TlE2Q2VraEJPYWJjVXVEN3huTnVzc1Arb0xWNFdJd01LU1lwdUl1UDZaUy9yYzA1MnJMc0xXUjBieURNeEg1eVRSQVUydHRCSnIrMUNIVjgzRVVTNURMcHJFMm1KaXkvaVFUd1lYSmRGVlR0Y3o0MnNGZHNyUG9ZSU1xellFSDJNTldlUXdlRGc4bUZOSzNKTW9zRFJIMllxdkVDQkdUSEFvNTVkekovcVJBK1VnU3hyeEpTanZqaHJVR3hwSFh3S0EyVDdQL1BKdE5iVzhkd3ZoWkhNRjN2eGxMT3ZqSWh0b1lFV0k3WWltQUNVUkNSbFg1aGhyUHZTd0c1Rkw3ejBDVWdPWHhqMytkQ0xUdTJFUThsN1YxRGpGV0NIcCsyOXp5eTRxN1Zybk9pMEozYjZwcXFOSXB6ZnRlenI3SEE1NGVDOE5CWThHYnovditTb0g2UEN5dU5HZ09CRU42TjNyL29yWHFpS3U4Rno2eUo5Ty9zVm9BQUFBQUFRQUIvLzhBRDNqYTVIMEpnQlJGc25abFZYVlgzOTNWNTl3elBUMEhNREFOM1F6RGNLc0ljc3NsSWlDZ29paUhvb0tJZ05lS2VMQWVxS3NDS3Q3S0tsVTlqU0FxNElXaXJPdXhvdUo5TzR1SUx1c0ZNOGtma1ZuVjAzT2grOTcvM3R2Ly9lc08wOU1NWFptUmtSRmZmQkVaS1lqQ1lFRVF6N0JNRkNSQkVhcDFJc1Q3cFJRNXREK2hXeTBmOUV0Sklyd1VkQW5mdHVEYktjVWFidXlYSXZoK1VvMnE1VkUxT2xnc29XWGtkanJiTXZIUWhzSHlYd1Q0U09IY0kxK1JweTN6QktmZ0ZhWUlLWmNvVkduMmVGcVNoSUJjUlRSZlhCUDJhSzVFMm1vWGl1VXF6VzIrcXZkWUJWdFYycXNJdWZDMk41NzJzRmU2U3FwMGoxZjE2M2Fwcms3UVhaTHExengxM1h2VTl1eVZUSVJEUVd1c3RDSVFsV0xubmpSMnpLU1RSNDg1V1NiRGVueXo4c1N4NDBlUG1EVFJrbWljSWJCeExaY3VrbkpnWERqZmtVSkt3SEhKU1J5WEhaNW5UYkIzakIrSlpvdHIwcDYwcUFoTytFdlJweXVrS20xbFArbDJHSkFpd29DSURBUHEzZ01mVHVCck9iRlhQa1hPd1Q4dDg2aUQvRVFkK053cVFaQzNXZVlJK1VJeG1TcWs4Z1NoS2hVSzV5YVRTVTJJMXdjak9mbGxrU1I4VmtPOXFCWVVsa1VTbWh5dmwzeEZ4ZmkyQmQ2MjJoMXVmRnVKcDJ4T0YvdzdvcFhFdGJ3OTZWeEY4TVBvY24xNkdFWVhZai9CUnp1cTZnZUZBdmFxZWxzb0RBSlYrRzhwOGJTTi80Wml3OTlRWkh1VkZ2THBUdmluTHZZWGVwUlVhYjN5dGc3WWZMQ3ZFS3B5YkIzd3djSEQrRUxMODlXTGVVcWdxbDVpZjFyeFQzaHN2VDNYQmkvQ3ZucEgyQm5BVDZ0M2gxendDejcycDhyK0RPS2YrRHNSOWp2d3IzTFl2NExQekRjL3A4RDhuRUw4bmZvaTh6ZUw4WDFwa0UrVVVBWStGWVZWVUZoVVhOM3FmOXFnUEZ5SG1taHRyQ1lhU0VwSi9BcEZGZmlTWW9FWWZOVW1hMk5WUk9uMlBRa01lMzNZMDhOM0QvK0MvdHp0Si9ybHNEZUdiemxoOTVDRFc3dHRKVmM4LytGT2NpVmRobDg3UDN5ZUxpZFg0TmZ6SDRMK1NNS0VJemZJYnNzTFFvbFFJWFFWYmhhMGNGd0xKUFVDdVVHclRLVENCU2pVY0FpRTZveHI1VW5ZUlEyYWxFaFpuZmkrRllSTnRHNU05WE1TZWxScDBLSStQVVNxVWxKQldTS1JTQWVaYXFVc3prcjRTUXY2OU02Z1pENmxRYS9HNzUxUisyMm8vUVZoMFA2Y09zMnBiaExzdnR5eXJtV1JPczNxMTJ5d0lRSTllOVhXSkVQaGlGSlJxUmFKc0RPVVVLeW1vckttaUVUVXltcFNIZ3hIYXF5QlhqVTlLeW9udlBQc0ZYdTFVMjVadTNYdHNMMHZYdkhONCtNYXBneDZlaTBwNmpOb1NlUGxnNDZSdnJ3bUZiaHBsV1AwUi8zZDlKdWhaeStiOEtmTi91ZTNXMFlkNmpUUVNpcHpoajkrZVpkZWhSLzdHNCtFVCtsVVd5Z0lGcUhma1FQV2RaYkxCWWNRRkhLRW1OQk4wSVJVQ0xVOUNuL29sWEpES2d5N0lTWENIN3BmYmtqYlBGSFJYYVhiNEdWK0ZYdVpMemNRclJxbGxIWnlNK0QwNlQ1UVVBdi95ZUxUYytHbk12NVRHWk5TdW9pYmlUZ0t5cW42VXpZeFZGZFhwMWxVa0pOZWxndnlDdGRwbmRWVWZqUlNoeUswaFZSL2ZXNVJXV2NRbmU3UGh4OHNUcDhBUDRBRWZWSFRvdFFHdzhsRVRjOVlxVFZBa25iUzNsLzBJeWZjOCtkSDdsdTM0VUJWOXlsVHVsZU5sS1F2R3B2STQyVG8rajgvY3Y5YWVEcytkV3E4U3ZvclNYMzZ4dnZ2Zi9yV3hSZDl2My9oWVRBT2gxYVQrL0hOdmU5Lyt1YkZpdzU4dHhEMWEvU1IvWlo2a0Y4aDZGY1BZWm1ReWtIWjVhUHNvbEpEeW81aWkxdEFRQWtVa0Y1a2I5Q0tmRnBseVI1VnQ0SStXZU42cFlKdjZWMUJFaTVRblNSOEw3TEMvS1U2dld1bDZrL2I4Nk5sWGxRWWw1cnk1Y2FZTktJNThBdTVkVm9jRk1ycUNqT3BjRldxSmpXbWhWVklyOXFvaHlna1dna2lLQ3RIRWRRU0R3a0VJd1BndHlwQUdLTXZ1Rzdvb0ErZjFQOTI1V3JpR2R5RFZKY3VIa21LNkozem52anlhL285NmJGa3h1SVo5TVhlQThlZE12Ymt3YlVEaDVHTHJ0aHk0dGhiSjkrb1AzRE5ncWNtMGwvUDNYalpqNmZTdjg5Wi92WWI0MmIySVgyNlRCR25UVGlqMjhsOWszMzZ3LzRqYUwvSjFjeCtsd290YmJXY1phdDFDNmt5YlBKeTB4SUw3TitQcHJ2RnlmRHYzV0NKd2IwSjhBODlUTlhBUUpiQVAvVHlmOWpUWDV1MHd1YnhSMklWNHVqVjErMWZzZks2eS9kZGY3TVlhaVNiSDloTWgzM1RRRWRyOTVLTitKbDk0RE9QTno5VE1EL1R1U2N0dC9qTVpOZ2ZDb3BLckplL3BxZllaLy8xTjYrK2J0OWxxNjZ4ekh1UW5uRG9FQjE3ejBhUyt2czNaRE1iWnoreHQvU05aYWZnQWYrcFNYRUNyaEQzQUg1T3JVVktTdVVSUzBCeGtzcEF2M0l5cGZMWFNuSmFNWDNtYisvY2VzVW5iMG9mN1QrTlRLUDNuWFlnUXIrNmdIU203eTBnZWZpWkU0UjNaVWxlQ1Q1NUl1ekt1S1l3aDZOWndPa1J0RStDdzE2VklnSytKQkthS2xkY2MrelJ4RVRhenIySG5FalpIZmpYZGdWKzAySEhsdzdCWHFXNytjaHFvaXFBZ2xCVWpha1R5TG12ay9Qb2phK0x4NzlPTHFDclhxZXJ5VHljMXhFTFNRdWZDVmFoSE1lUUZvM1ZVK0thdUVlWFFXRnRvTEF5T0ZiTmltNDFBam9Yc1VyOUJwUVNoNmZIb3NOTm40UjMwRi81V3ZZaHE4WGU0bVZNRitDemRHSnR3QzlVQlYwQW15RFpCVnV6THRSRVEzMElKYXYzNzhkL3kvQUo2UXl5cUJhYWdVa0duN2lZVG5CSVlud3pKcGtOT0RKZ3c4UVpmRnh1Mk1oNVRFZkRvQSs0ZndsVENoZ1dIMHVTUklsYnRCS2w2UkNhQWNRSFE0N3NsMVhMbFRDZUNHQ3lsQjAzdk5mYXdGUlVEK0drY3RpR2h5MnR1WHk2SDRRRSt4ME5vZTUzWldCUkNCR1NWYWhqVnN5ZlRQaFZueGdyRlFsdTFWNDFQdHlpUTc3NytmdWZ2dnZsaDMrU3NwUFBQblBxdEZteko0dFBrUE5BWVZiVGUraXQ5RjV5TnBseDVNTlBHb253OGNkOFBoZkFmTXBnUGc1WXM1VGNQQjl3Y2ZJZVhiSTM2QzRZaGlURG1oRUdoUWhDdzRIRTZpVVhrTzMvb0hzbHk3RENlMlE3T2VQUWFxbnNEemNPaTF6R1BuYzRZS0pjWnV2R0N5a1ZaK3dCRXlmampQTWttSEZSWEl2czBXMUtROG9XUVZXeitVRHJJZ3kzUkZUUXVtSVFwdTVSNGJIK09pMVBoZDhxUkpzdit6VUJCVEJBVENhS1NDam9JVjRTQXEyc0lRTkVicWFVNFdkZGZmZnBWN3c4Zi9DcStwUTRyYkdHVEx0emVwZXBvOGJlUGs3ZWV2SUpsZE0zekoveHNINy93KzZmZDVPWmQxMHl1L2VFY2NPUDU3SVlEdXZrZ2pGWENPY0lxWEljczJ4cFNPVXdiMlp0U0x1YzVUbmd3bHlXaHZwUWVZNE5oRlFKKzJ5UFhncDIyb2RHT2g5bTQ4dkhLZmljTUlWT09BV25qREN5dEs1T0Q1WERLMThSVE1LdmF2bDFXZzY2TGRBNWNONjRnRDBycWtnTmU0R1RxT3pGM1pFU3dsbkswZExoWTUrYmZ0TjE5Mnc4ZTg2OXQrNGMvTWVUVm00anlydUg3cnJoa2Nmb2gvUWZuL1UrMURsNStyelR4bjQ2OGF4MTNYcS9jczNHdFZjOFVXb04zWGZOcm84NU5nWVBMZmRtNnh3UXp1QTZ5UHgwV25EYXdURURUdFlGd0RQV0JOR0NjYzJPK0IxWEJ3R09qZGtDbXhVV3lNNFd5STVtQWFDTmJyT0ROeFo5S3ZNelRvSHBpQ2FxbWcrWHFJYUF4UWpGV0NBQmZxWTJabFdpNGt6aWZlZ2graWxOa2RFT01KY0pVckpidXJ6eFQxL1FUMGpKRi92NmZ1b2ZQWnl2eGZRais2VWpNTjU4c0d3TVVlc3k3Qmczcm9WUGFrZ0hiWGx1V0lzZ2JwNkN1R2JkbzBkQVZRdGhUQkh3aHhCTjRJamtQQlhWUmJPcEtlSkVhS0FGL2JwTHJUT2xYbExUTTRxeURvQUNTYlY4NjRPb3A0OTRlVEp4MDRiRWtvb0xlNG8vVUY5dXRNL0VWNzZEVWYvNGRXL2FLZm5obTBIWFFQR0ZYK2tCeGYzWkN3MkhtWHdIZys3a1dwWUJMaW9UenVXb1NDK3dHSHZjWm1sSWUwdERFb3pZaS82OW5HMzNYQkF2SVB0aTNPYXczU3ZnZXk3SU1PVjB1WEdzeFdwSzhqS2c0L2ZyRm9ZTlN3dGdib0lmM3ZLcW1nc21ob1lVellFUVRVUkNvUDNnd1pOOEhtQWFLc1J5Ymh2WXZoaE1wcEdwRngwM2NkeWZ0ayszdTAvOTY5YTNEbjkwNTVmTFNObEZVMDZkZGVyMFU1YUxvOGxhc3Rxekx6Q2wvdjcxRGE5OVRKdHVJT3FrQld1V0w1eTE4RUsySmozWm5wNEQ5cjFFU0ZsZ2hzd3c0MjVXNG1qYUJZZ3hHUmpoRmhrTVlVL3B5NlovMEwrSWR2bkNuN2NjSGlWZnlIQTJ5aXBndVJTc1lTbFk2QXNOYVFFMDVCQ29LMkxFT0JOUkRzSWUzRm94ZUpIajA0dTRyRFMvVDNQaDI1M2hkZWM0dzBMZDRhOWlIQXNCRnF3UDVVZnREQWo1TlM5SXJpdWdRSVEvL21oRnUvQ0g3VElUK0REOGJBMEFtRGF4eitCTHIxdDA5czh2dmZUUGhYOVl1NUwrYys4WDlERHhuWC82dkxsekxuNmwrN0FaMDRaUEh6NWlLcGx4MFpORFJtdzQ4OVl0bSs2YzgrQ3g0NStZdStIMTU1NGZOK1hVVVFQUEhUaE56SytiRXU4NnBkOHhJMGVodmd4a01sZ201SUxkQlgxeE1KOWc2a3NNOUNWUzZFQjlpYUMrVkRCaDVNRms4M3g2Q1Fhbk1PRksrSjZIK3VKd2VWRkxTbFJkQWlYWEZIL0tId2l5TFJrQmw2RzU2N1JDVlF2VWFURy9ybkQzMFJQY0J3QVdVSnZTeWhxWThBQlNHL01RMEpoc2hSblk5UDZkWDE5Q0g2VDNMaDA0NXVUVjIyWXB6dHFiNW01Nmd4Uk1tejc1MGtWVHA1NHAzZmtKa1c2ays3ZlJNK2tjOTdmQms3YmVPL21FYjk0Nlk5SENrUXZXTEJPYXVRSzVEL045ZFVMS1M4RGtoSmdqenFZTWNscFJCbjd6RlRyQlZvNVpiYzlKNC9mSm81cWR0WFRxbUhFVFJvMmFPQUhIZ0xnRXgyQVYvRUpma0RXT3dXYzhPWUFtUE8zbWo1VVRtdHVuaXlCbk1hNEhRYjV1d0NvcHE4TlhWOWVNVjV3a2F3QW1kcm5MSElBQll1UmJNczlIYlBZc1lMTWQ4SHdCckdMSVRrSVRwSTFOaThScnhaa3J5VHRmMExmb2o1L2pPQ2VRVmJJay9ZWHhGM2tjOVFDRVEyU0JPOElXUjE3Q1FEc0V2dUJER3NkS0c4bXExd0dOdmY0NnQ1dFp6NnF0c1JONDNBVHhtcWFMcEkzUGZrNmNwTnNYdFBOS3RpN1dJMTlKNTRPdlEvMWJKUENRRFhSTmk4WFRoWHg1Y3VOTThmTDJwRXM0ZStNdXliTXhKZ0Z3cjFiaVl3S3lHSXJvY2tQMElhcVJ3aGh1T2xCRk8xZ3AzUkpVTVhBVjlOeENrS01sNkFJNTZtSkVOWnk0dWZrOHBKREUwRVVZMjAwSlpFblkrcmY5TDN3OS9hcXAzUnRIeno1OTBKUnhmOXg4eWNSeFkwNmFOUHJFU1JiSFJVK3ZtMzM3ak9PRzFOVU5tWEwxeUtHbjFBNFlOSzF4ZEROZ0U0V1pSK1piendOYjAxTVlLTndxTUFDU0xwZUZFRXdoRVU5MzVhLzhjYzJWVE5meUg0b1NXdjk0T29mOVFMUkJEQ3gyNWhpNU00dm8welg4cHhvZjhpa0c1NklmQTFLSTFxaitRWGFYN004cDd4cFA5QVZSQ0xxL0swdzNYcWZWcW1DSXRQNyt0RTBJUlRFRzAzSVFCckRkV0paTXlINEVNekRmeWhqT3VxWW52QmVPU0VHMkhhdmhMMlFSOTJ1aVYyM0lHaXNSQ1A3RlFJTDdkT1pyWk5rdmI1QmhxVW4zbkQxa1hvNzN6THNmZms0NDhwZHhMd3dLbjlEL2hFdS92bVVIL2ZKUEpJYzRadjJ3OE5WZjZKL29YUEhZK3llZVluZjM2TC9vS3JIZlBySjg3d2I2NGw5WGZuN0Y0TnBMWHQyNDY4ZmlNSTMvSVhYREhmc3VXVWYzUEVkL3BkOTBxOXA4RWxsS3p0bDE4Y28zSGJjd3VjTC9MQU1zRjRDbXVvVVJIQWxyVXBLQng3VFZKaEF3WFZiMERDd0EweFdBU0lwUGx4RktncC8yWWhpZ1FGeE9SSnVkU1luWVFFb3VrRVlQOEJwUktTb0ZvaUxZWVBKM01wdDhTNStmUmEyek5wSnpybzhwSlpZTERxMGlJK2dtOFZqeTdLTFNKZWhQSUZDVE53Rlc4SUtOS1JIT0Fpc2pjSmpBMWJvRXNGdE94SXYwUXc1YTB5Z2JrZytHbEpQUWZGeVBYZkJUQVhvVUN3eXZGQlViVkJmd0RiT2lQalkyV0MvMmhsYmkxeXd3VXNEQkpYSXpSSXRWc3FVeVFSeWd1WTFFSTVYRWVlSE1QeXlrKzcvOWRNZVNDMy9ldkdIeG5JWEwxMWptUGJ4bDZUMCtlOUg2RmR2ZVBqaHR4bU4vSHo3eHhDRnMveTRBdjdBYTltVllPRjVJQlpsWE1IR3pRMnFvVjRJeUFzOEltNElieHBxRGJ0Y2I1RGhaVVZPQ0c5R1lManRVQXhzdzdZb29xRUxXa0MrYTRQcXo0QzVTK2RJcnU2ZVBYamZ5b1NmSXRKdGYzL0FXZllOdUZ6ZTlTNFk4ZnRxQjh0cERIOVA0c0orSGt2TmdyVUcrbGpqSTF3WVM3aTJrYkRncXV5bGRMMEl3UnZucWRoQ2kzY2NDQmhTanlvWUdFREVqTGtFRkZhNU1scWkrYUd3alNaTUpaREZkUW04NC9WTHlDRjI0RGdMNU8rZzIrZ2hkZlpEc0lqdTRQWU5uUzM5bFhQTlFybVhzeWFobUNBalRGcTVxRmh5RUt6TUlqR1ZacUdzSEhBNHhMZzlxalNDUFI3SDhhNk5VUXEza0hkcVpRTEQyQS8zclAraWRCNXVmK3lvODF5NE15b3J6MkROdEZ2Wk1HejdUd1orcFpEOFR3bXZqZ2M1V0Q5d29GZkRINGNQdStMN3BmU0d6NWwvQ211Y0pGM05PaU1WS0hEa0MxdlVIY2hBSitIRTc1YlBuT1dHT25EZlRRd29MOG4waEZuYjQ0YUVGSmswbTJYSVFGNFJVakxaMUQ5SkFvVG85NEVjTTZheERXQXgvb1VsOGVUaUdWTUNnaUNGRy9xaFJpUGpCSW9HdWtNdkp4RDA3VDd2OS91MWZQYWxQblU1L0ZTdFhmTHVVN3FScGNRc1pTeGFmdEc4a1BmTHVad2NDcFBUSHB1NWRZK1Q4akF3dFViWjJBdzBMb1hBTG9WbVNhY25CcENoSm1aWERXWWtKbkJoZ1NaQW5XbzNtTmN2OHQ1RlVpQldrZ3U1dDJtdVoxL1NKV0hKb3RUaXA2UkgrUFBJMmk4MmpyV0p6L0hnMFBQaGx5WHdpZkJJUDBRVnk1RHc2bS8xYnQ5Qk5TRmx4ak02NExob1d6QUtSS2pkYmdpNDZPYWF5cXN5SktRd3d3WWVoczZxOGNlU0FtUk5JeFVkN1R4Lyt4K0RGbDFuQ2g3NDlTSU9tTEZ6dytTNmh1eUVMVzBZV1JIUHorSjhKUVBlWVNGcVhISFY4NTZpMUpHb0h5NmpnbUM4a2k4bFFXa0Mrb1NsNnl6S1F3Ui91Sis4MjNkRjRTQncybWZyNHMyUTdQTXNpZERYMmpHVHNHYUpaVFZta0pLYXRrZ1ZVUm1rV2NnakYyOU15Ny9DS2crWWFXcGZDWndXRnk0elBVcnhKUG5KZHRHQ21Jc1ErTWFnMHBGWE8yZ2JaQWpLTUd1YjVodWYyN2k5a2FRWnZ0VWZ6N2RBbHk2OFdUZHdoQ2Jya3E2NG05YUxrOVJrc3YyNUR3MnZ4SUpCVlFjNUdUT0hpY2lCSmdpclFzMWNnQnRLSStVTWdqNXZJQ1ZhSWJXNmkreVduamQ1Si8wRjFteDhtc0ZldUFNMjRLYjZFV0EvdmtJK2w5ZWMyTFduV3kwdVp2empSV0F1N3NSWkswclJsWHRoWFhwOXV4U2hYWWJaTTkrS1NPQUhEd05ycm9xT094VjlTbmJsV3pqcHpqQ0xxZ3ptOEM4U3BWZyt4MDJ1YjdtUEQrcDU0Rm9nM0hWb3Q1OU9HUlUzbm95K0YvVzlady9paFVETS9aRnFBQU9wZ09LTWZMaDhiaXhYVU1RTGZWZVNISk9hbUF0bjhrR0FZVzBRS1lXWndTNjBMeUNReUNQNGJUeCtsejhKL2o1SWFUU016NlhvdEpXNGxVOGg4ZWdPZy9ZZnBLbklCT2ZtYmI4bmZ5Sjc5ek5lalBzMDN1SU5qalozRmJIOEFyS0hkS2FCbnRhTTFETEpoT3RBNkpUU0hqL2w1OUFRaDFPaUFzOWtUSkdTTXRHTzVwTmxYUHRWRUZQb05wWmZPWEhuMWdvdFhXT2J0ZmVlVDc2aGYvSGp1bWJOUDU3SEVBcnFKeWNrTHFIV0trSElMWER3cGR3QTEyUTIybm9zc2dpTEx5M2g1SDBOdEtETE5rZER6MFdpQ1I2K1huQzZPUFFLQVhUVjduUlpSVzRvdktDcVk5R3RYaEk4OVFzYlFxNCtFT3hMamozVFRLSG90NmQxU2xJWXZsVUdXSHNBcVV3enRjeVFOL0EzaWRIdVpPTjNOcktBSHh1MU5hQjZmSGpERWljUmd3TU5CaVFWQWlST1gzK3RtV0J0bTBSS2RDQkhReEd4QjMwcnlpZmZxUzBqZGRMcVZwdGROdi82cWxYODh4VEx2dFRjdjJkNkxkcjFHRERYdGsrUnBaNXcrZ2UyVnlVZjJTNStEYjZvVUZnaXBDc2JEZ01UOU9OeGN3Q1BoQ2ovaWtVNXh6YnRITDRBOVU4QVNxU3hlRHlWWWpxdkF5MGVxcUp0a3B6KzNCQU53akVYRFVjYlJWSENPSnF6V0UyOUJqR1ZzY3BtbmdxaFBOYWl4YWxKWkxmSmczVVF5d1NJU01ZTDJ5YXVlUDNIbTdPcVRWMTU2MmNoREg4NTljYzcwYzI4ZU12NlVzakczUEhjVC9lR0hqNDhoNm9DZXc0ZDFIdFIzVUw5emJ6NXR5MXZKK0pmVlphTUhWdmJwTldUYVV5dWZmZy9uV1FrNlBnaldSUkg2Z1AzUCtIdEJRZ3FNSll1dGUxRDRLWXNWbGMwQ1RqNWx0YkRNSDdKaHpaRVoycWRLT1pkZVRkK1RGLy80NCtHVjhtTDgvQWRnaitmQzUvdUZXaUhsUXpsYURac015OC9DVUc2V05jbkgwcyt3MXhrd3RXTXkzTWVZVjNReXpkNUdCc1Y4Z0ZSY2Z1dE5WNUR5YStoaG5mNlR2a08ra3k1dGZIejliWCs2VnpxeGNkbWQzMXhDQXZCcytKLzhQZlBEL1lXVUUrZkdVdU8ycE9sNUNUeVhjS3R0NXo0WFhvTTFjVERORXN5TkN6WU5wTjZyRmlFNjZVeXNvYmpWMFo4b3BEUHRSTGRiNWpXK09PejVpcFAzU24yWlMrWFBWVEFmVXlqc0VsS0ZxT21CSkh0MEN0QSt5M0lYOGNjcjdQR3FRWVFWYzZleFk4TlB1OUJwZUxRY254YmVvVHVkdjJydUhWc0hEUDRoeWQ5V2ZlQkxMTWdGQlhaczNiSHZSM3piQ2ZDaDN1VjBCNnJnWDlWSGNzS0JxaFQ4V0hKdHliVXhLMnladWhTOEI5K0VKOXkrSEtjckhESHl5MlN6MnhmSWZnTjlFWUVod2RRTFVRWVF3R295azBFQWFhSGFRRFFBc21BdndFaUFnbnFJSWtWSnFSNFBXVHY1WHlYaFZ6eWRISTdPZm8yVTBydXA5clFqS1ZtclhVOVJIZnkxNDgwN2UzMCtVSEkwL3RUem5WSERQenhlL0FrYzFkN0tmM1pPZnQ2OXFWTkdkaFkvVzdPS1pyd2dtbmpCRldmQVNCZlI4OGdNSmZTd000akEvay8rUWs4a3g1T3VwSnowcHlQSkhycVJQa09mRVhlTDY2bUwvTE5wVE5OZzBkMTAwSHlPdkkxaGU4QWxTa1kzSkhpSW5iSGJtSWx3c0l3RVNFQkVVZkFYS0FxRUpLQ01aQ0FwSWFYd3FDVDlBS2IzZ3RpdlVXdjZYQXpnNThjTjN0a3VWSnY0d1l4bkdQUnp4QmxLMWhYT0hvTjFNUUtYWkEySk1oSXhGQmZ2YUxwWStyTHBMSEhEZHVtcGc5c2FCeHNZZlNYZExVNHc5eXl6b0xMY2dGeWt3WmV3MUorZEZYK0lDY3d3bDhoVjVodFN3dHl6Z0hsaWFqSzBrdXgrKzIyNjI3cCsxNkVmZHZIUGg2MWkxSk9FQllCTGhteXljajI0OWs1aUV5MzBWdzRraWRDZDdpYU5iRXpIQ2NZMCtaZ0VZMHpLSG5nMnNsdXNKc1dYSnB4UElYSDh3UmljWWxJOWthUWFBeGdlN2Y2M3Y1SGR0T2NjaTNmWHI5UFoyR3prTzFteFhDaFlCVlV3b0oxQndySWNEWW5aaVkzY3M1Szg4emw5amY0RWRtRkY0eEx4OUtaMWlIVWI2VzZwN01oWW1GY2g1aC9UZ2l5NFFUTDhXOWIwRkxCbXN0U3A4ZDJOVitFelNWOTVqVFREOGhib1NpY0JnQ1RtOTRMNEQreE0wakxQeURtWVhsclphbmJ2UVdxaTRVZ29WZzMvbUJ6ZjcvNGQvYjZ4YkEvTzJKYlg1U2tRNVRpSWV5eHlQeUZIS0VVV0dMTkVxYkJKQmJzSTZvcmNrSlpLd2k1M1ZWb3lDSmtZNTg3dGpEc3Y0b0VDZ0RXOXpLRFBkVHNpc3lJMXBiakNHUDU0L1ZvQXRGWUtteUV5dW5xWFgzTndGbmdnd1lTTFVza0lKelZXYWZLZ1lHZkJ0SG5JdUc4UGJIbmdzai9QMlBMeG5pOWU3YTBNVzdQc2pvMms4Nm96TGo1ditWTFMvNUgxZGt0OC9hZ1habXpkMXRUdnhxbEROOTY5NU1JWmsyUjVQUFAxdDhQOEZsdDJnczB2RnVZWXVNbUQ4d3RiR2xJMlltUUliS3l1eEVZd0tWdkNKaGRRV0NBVVlMVVFHQlloejZRSGtPdTFXSkdMMUhMQjYzdlFOb2NGNWg2MEFsVnpNanhxK0g0MXlCSUIvaERtQ0N0alNpQ0wyRlZ1SjZVdTE2eVhuMzc3ZzJlZU9pZlk0L2haNTA0Kys1eXBjMDhUTFR2cHc4ZmNkQmZkZTRUK1NqOWV1VkNNYkxqbC9uWHIxdjdoZHFaemt3QUwvRm51QXlpMXY4Rk51Skd4eG9uWUxSbVU2dVRRVk5EZHlFcW9kWnBkVFFsODJNMnhwa2xKcUw0a1Vsb1laMDRpbnNZdHEwOGF2S2p2WjU5TitPUFFJVGZNcHo3UlRieWs2SVJQOG1OME85M1Z0ZnN2M1VwQnJqQU9zQ2xjcm1PRmxBdmxpcFJQUm42Z0hBSHV6aHdnU2dDaUxOVUNPeXpKSkdrTHFQNjA1UEdGQ3hHS2dDd3RiaGljQTFHS1lDUlhJOGtLZExNeHhzWVplWlJhTHI1SmU3ZS9mSTQ5VEdJZjlYYWY5dXBUZTBqRjNGbm56cGJQdm1qbUhGRWxGbEsyOXFKcFpNS2hQdGV1STdHbXRlc3VYMU1NUW1UNmdPUHVBdklMQ3ZuQzJVTEtqeEoweW9ZRWMwSFZRelkvUlBycGtLSHFCV3cyRUhrQ2xOSnNyQWFNbVdOTWM0VnRHT0U3L1hVOEhPRUpMeWZFOXNneVFtVHZnY0Rmb0ZsUjJ2NUNFbVZnaXN0YUlGRUdveVlSNTdlZkhtNGFiMW01ZE1hR2FTTWZXMHFQMEk5Sk4zS2JPSGZxMUxORkozR1NzaVBDNTljdnZiWlQxU2NWNVlBYy96Qm40VUlETDBuRExHK0FMcHpDZFlGUisxajFvd21KbENqd0FOcHFxRVVRS3cyWVhuc1NxVUFRRlQ2Z0FvSUtNdVFlUkFURlZNYnA1VkFjZ210VzcxUlR5MUFmNHlXc2hZU25FeXZ2U2IxNDI4TGhKdzhmVUh2NE1QMVlHblhkNk5HYkh1NzJkc0d3dXVQZWE2eVhSaUVuYUtYZDVKNGc2ODVDTDJHUThJNlE2b25TTGdGOTlTUDlQNURaT2kyWTRCbUpnWno2cll5bnU3Rlg2ZncrUGIyd0V2bkdTaHdUMTF4NzlGcXN2a2xvUXNrZU5kMkZtKzFhSDlZTVl0UUxnWFd0VCsrUEdVajR0WWhQSzhOZjY4NS9yWHNjUzVxd1h1UlkrSVZhTTJqVCs0T2RUSHNMU2lxN29TWkNBQkppb0xobk4vaUZNb0VsZFRDZmxRK0JIU2FPK3pEak5kQ2ZDa1dRU2dmL1lLYXhNc21zU0RTa01PWThEdmdzMkpjWU9VMWUxTVJEZ0ZLcmFRMUFxQmRkMlBXNEljZE5tUG5abTEwdlVjbjVEMVlmK0Z2UHFxNTNiOXE0bWU2aUgzMzg5ME1YekY2cm56M3Z0aFBubmpObTdOaVI2KzU1Yk1ibEJZR1RldlFiVzFsMno5ekh0L25rMVZWREp6KzZYYlNVZGhsNDIwMWIvM0xuZmYwR1R4emVyM3FFVkhyU3JGa243UUJkQWVzaHo0WDlHc0lNRU1NeTdxUnBMVUxjMW9WOFNIdm9ib1dIdFNHQm9RRE5vK3FLbmVWZW1FM3pFcDdkUkFvQWd3QVZMSm1pK0dhKytmU3o5T01OUytBWjlLM1lGU2V0M2ZWMDB3aHg3bGNQUEVsZHVPK3VCNFY5Q1o1dkUxeUl2bG51RzVOQVdERUpQcXdRVjlqTmt0NUNnaFZoeUl5RUFRd095NkNJdkFTMFp6TEJFaElJdzY5ZmQ5ZVlNZXRjcE5SU3QyclY0QkdIVDVJckR1OWw4ZDJSUDlCdTdGbHV3QXhESVpJZ0JwTmtnVTBjeDZ3VGUxb0VPU1hZQ3l6RjdrOGdpNnZiTEZnZkVNTDFQeXJIUk15UkxEMzIrT0hIa2RJWDB1ZU9JVFkyb25mOTQwNlU1eDgrNjVITkVldVBPREtPWTFEK1Q3QjZvOXJtaUZNaGFEQzlQTVJraThENFJBOURsQlljaGNKZXVrd0tTa2xtU0NnUXUxZTZGRUtBb2ZRVXNwMm02R3RMTFR1YjV2MnduaHhIazAwUGtjZFBwNXY0YzhsV2VLNGtGUERuWnFnNFdHYjhhcWJpNEJNdE93LzF5WXpYK2lYczNaaHdub0VaMVR6a25HREViTmlnUG5veENEUU1nVmtaKzBBTU4yTStGdHNiV1ZJc29sSGhFZVVZakFvTXZHdjVxcWJVYVhrUTE5aDVGUWFqbDRxUkM1RHREcFlYVHFySlNISUFRUWVBZjNKVnEyQzZsbmx4KzRlVnZxcDdaeCtZa0ZmMTRPeE5UOUlQUjQyYmN6YjlhTlM0ODg2UUsxWU9HNzkyK0xnbmQ2TUNYbkRCN1E4MDdjUHY5ejJGbW1pdXhWem1BMFlhYStITW1wbnVRNE9aWWRTUVNrTTIzY21wTkQxb1RNU0ZFNEdoKzlDT3lIWFo0dzYzR21pUFIrYyt1WU4rUEc3eWtya3d1RkZqWG42R2oremVwL25lUUo4MERjYmpGbktSZTJKNWFOWDA2aXo1bkpkaElUdzhWNEswTEVvNjZNRVFrZFVtUlZRMWsxeEdkd09SdVUrSWxiS0sxQXp1bUVSOFA5M3g5Mlgwd0k5M05Dd25uYzVhZU9HWitDV0dpRXlpVi8zNkVHMmk3Njg0L05CZDYrKzUrNjUxYXhFL2dRMWZER01MZ0o4L3krQjdZRWhjWEZZRFAybENQQnMzQlRPNHlaNk5tMlN2aVp1c2JqWmdOd3dZMzBQa0JEYVZtSUlNb0NBUk9ha3NIVmNaQzRkeVdZbVZhbUNuYnp0NUVEcWRzV1haVStkNHZiUE9mVzdHbVlDY2FEZkxyOWZlUlQrazlOSERWNjY4S2tUSFNYL2ZjQXM1eHNCT0lHZVlTMisyN2lYSSt5RDZNNzJrbVpFS29hTm5Tb3lXQVhNS2RoOHVQZG9QVEVrNVF3aGJ2UDZjWW5RVytXQWFyYXphRll4RnZXQmw3eHJvSlJ4SjF1S3U2c25UK2kzd3k2Uzl6OHk2clU3Sis1Ris2SFpYM3pucjZiZEpwMWx6NTU4bG43MXdOK0FYbVpTUFBISGxJWVU4MCtmTVVTZGk4SHJYOHJ0aUcyNHhkRmNhQVhQd1lSYUk4K3NaeFhWaE1LZHl6ZzIwRmJlZmoyc3I2S21yclo1R0pFTkgzNi95SkI0K3ZXOWxPSmE4ZG8xY2tabzh6MGEvdC8veHNxYlBNNWh6R1R5ekhCRTByNm94RVpOZE5rc2pzT0thQ1NwVEljS1MwcXdpS1liQndDYko3Z2tWbEtMYy9QNlUxV3RoNVJFRklWNXFiVmRCZnY1Yy9Gc1RvWExVZ1JncEZBeEhXS2sxNW1aWnJaYkJSMDM2WU5lT0owNCs4ZG9UTGg5Ly9kSUxhei8vN01MN1Roajd5cWk3dXB4NTBwSUxhaVQvcWpVVDNvaFZIVjlaMXp0eDh2bGo3dHRRWEh5Z0lqbWx0S3BYV2M5SkM5amN1c0hjUEJZYitNWHpqQm81RjJpM0JlZG00empLd3VxdExMS2RLNHVCcFRMNXBxQlpyNG13S21qUHhsSzZQV2pFNnk0MUd4UmFlRndXcUJrSWFBclpLcGJzQ2JHY3M5cnQ3Z2xQa3M3MG5lUHJSczZaZTlmamQwdWpsc3o4NUxQM21vNzA3eHQ5dDd1MlVTUnMzRGVEelRoTHJ1QTJESGNsaDdKV1kyc3lRaXRrR25xVDBESnRHQ08wL0ZqZnpncHpyRzZqWEtzVndXVkdZamVUVXJSZHBQVGpTbS8xaHZsUGJTUG5pK21tVzlDQWtYOGUzcnR5K05pWE16ekdlQmlURTNNL25PTWlHWTZMa3lXTXg4cHdPTWxlakxvaDhiK1UycTF5eFY5SW5NNmg3OGdWVGZkZGNOYlU1ZUkwNXRBSjJCN0JPaDgrdDFENHl1Q3dJa24yMGZYRUVRcVhSVnFUV01nMGg1dEpyT2M4Qjc1bG1RL0JweFh1OE1CdmFPS09yYysrK2YxZWZOZWlPYW85bW1lSG5pZi9xdVh1Mk5wLzE0SFJuTnNLK2JUZ0Rvc1c5bWtSK1BYVlAzek51QzJIcjk3cDhBU3E2bDNzVHpmK21ZSjNtdWt0SkZyQnEyMFduY0hjUEpmYlk3SlpaSkJUZERpRGtkeTh3cXgzRFpxTDAxdTY3R09yd0lVemtDRERKZUZtcmVVMFIweUtCa2gwU1ZHUlZTNzBYa2tHTFpWOVhqZXgyTHZhTHlVRjlEWDY0cmo1eXJQMFpibUNkbG4rOFFucnhwSW1Lb1hHVFQwNS8vanZ1cEE5aC9lU0M4aWV4czBvVTNBeThoUzJWdG5jRnVtWTIwb0M3TWhuNE1OSkhHUTJmWlNjOE5yclpCaDlrSnhETjMveWlWZ2sydWpqWkZ6VEwwMmZrYm1VMlNvQjdDM3FRMWlvRWt4VkFKQ24rOUdsUmVJOGIrNTM4NjBocU1ia3N6U0RXWDhzamdKUmtQNjdjaDFXUjlHTHBKWU82UC9sSFNPRzFmUWZkVUZVQlczWk1Ick9hWlBFaVlmSFBmaUE3eXYzcWROcmVKMmNkQWs4TzR2ekFwc2xFMDRHL1M3T3F5ZjVsaWFrSEJvbDMyOFE3L3J3NmFZTFB1VDRvWkR1Rm5YTFBQQ0k4d1ZlTHVlUU1iYlZjOUJpeEhXQzh3TjNXTEFITEFTZUdDcGhKN0JTSWNZeWhITEJWdGdUcVFLV0xpNUFXNEV1TWxUQVNXWmR5QUdaQndyQUxSSlY5Nm9zS3RhdEhxWVhOY2lJWVBFVlJKQWgxYXFFd29VRTltc2toSmFqWjBYaDRxVmJ2am4xQk10N0h3MmQvczJXWldURDUrTkgyMGoxVFJmdGtZNDlobjZSaWpxamo5am9GOGNjSzcxejBjMmthdnpKYkQ1RW8wUEV5eXc3R0JkbHdNTzB4Q3Bxakc4R1NDUnFVaVhhNjNTSXN1U1hGVWF0LzZjZ2gxS1VnNDhWSW9BQVNoblBCcEJGejBVNXhQRFlnT1pNNEFtU0VoN3VGVWs0ODZKY3pCVVZzUVFvQ0VIekpoaC9WQ1FaOVVwWVY2ZGJpamhpd0hNNW10ZXZPNE1zNUJwQWFsU011R29xS21IYWxUVUlkbFRNbVlmUW55RnFHSDNxMFBQbXYyc2RNdjN1OUtpRnl5OWFPcnIrN21uaW9NR2t3REh1VEo4em1pSUZ4dzJTOWlUbXo2WnZPazRjOC9ub2FmVHRjK1ltamZvdDBTbEwwb25nRTVJQ0s1NUpvaStvRDlnOE5rNGxPaFBvQlhpNGJDU0JkTW1tbW1hZHhZRE0yek9iWG9sZWRzTE1tNCsvWk9pU1V4T0xrek5XRHp4LzRySXBQUzhTblIrY1ZWUlUwNy9YKzdOell6VURPWjhLL3VnRHkrVkNQcDVOeVVVYnlzcWxYQkk3SXVmeTZSS3JFRTVIMUZ5Wmx5WnFlUW1UcHZEYVdjSVVrQmZ5bXpuOFdKMGxrY3JKUlNubmhFRFZrTGZJeVZWNURhNmdxeEdXNThHektvSTlhUEJEL0ppVDN6am1aRlN0OE9uZ1dhZXlsVHQzUFhMWGNtU0pMcGovNmVqbDB5Kys4aEc2UU56eEMvRVUzbldiZmNESEJhVjMzMHQzRlhYNW9ZK3RmbXR2NDF3STJKc0VxMFZmWk96SGZLbUJIVnRFcUp0V3JJTExqWFlkdDZrV1NqQ0xMdS9SYkFuR0c0SFM1TW80aDl4Q0xPeklqWURxeUd4U3NzQUwxZlZjTEkvUGh5bmxHenRhVmJoaGNhbnNJR095WmdEcFQySTF5UlpzQm5qZlVGQ0poa2FmTnV5UlI5NTc2Y210azIrZE4veEVjZ1pkZTZPNDRkdk84NlpmOC9yVzdhK05mci8vaERGYlhyLzYzdUUvNDF5c01KY3hvUGRoWVluQXlFU1RyMC83VkkvZ3hsUjIyc2ZaRE5EN1lJaTlaMG1tZy93OUpjR0NUODhlakRvaDJvWkpwdHdlTTMyS1p5UTlidnpKNDdQamRtR0JxZHRqTXY4aGcva1BvRFZHTmlhRVg5RWFuQmw4V1VuWFh3OERmcmpseVlhR0JucGczNzU5bTNnNm9LblBJMWMrOHVhYjhBZGlZV0tYdDBpM1dqYXptdEE0bnREUVFrbk1CdUEyWkVrQm52aGtaNTU0QU9Ubnh5SFFEbVNWQnBabnZTYjJvZjBIRGoxaFFQK2g1TkpSZFFPR0RlOWZOOHBTMi8rNElYM3FoaHpYNzlnQmcvdjFPWDRBV0pucFIvWmIvZ202NEFVTFdpT3M1dXdoU3NjdEcrcGV3Tm53WkRjWEtIazZ5Zm1nV0NmMlU4emdnM294TytYalN1NWpOYm5wS2w0VldPVkRvV0ZWSUo1VnFrV1ZyMUw5bTExQnVTQlczajNKTXM3ZGtpRElIblZhSi9VSm15K25SS2pvem5PaVdubUxla0FSSzVMRjJxQmZUaWJLOEdCUkdaWUJScHAxeU53Wk1QL3AyOGlvN2ZDMVl3dXQzL2tDclgveTZyWEVjOGRhNGw2emx2N2p6algwNEpyWDMzeG0xYTFENTV3K2RkYXp2WmIzT24vWmMyK0xUK0EvMkVicmR6eEZ0K3g4a1p6d05QNWUxcis3L1kyRzRmZjBYcldNL2xTWXY2blhmb3hqUmd1VDVlblNHNkNIYmxiTkdyRVR4ZmcybXN4NG5mNU03SzlmVHFhL2dTL2VFRzA1UkY5QU45Rk5DOGpHek10VzUzdUVGcWQzUUwxYnJGRlhXS1g3T2w2bDBocTJMcVZzWFZJMXBhaTdOU1dndTUwUzdhOVNWNzVLM1JKYVY1L2VBOTRvNTIrVXQxbTJIbDBoM0hJRkM3ckl1RGpscWw3WnVZNmQydWdFSzFnRDZCcldUc2dwNzlMTktDZy8rcXFCLzBKVlZmQ3Nhbk0yL3JkWGpSUWQvdk05S3ovOTRaRnVSUU43OVRxbTREZlhyQ2tsblhYVnludjcwVCtRWStrMjhtbXZnUU9TclhNM0FxdTh6c3JkV0RLNUc5MWlSRzJZdStsVkd3M2hvY0MrOS9janh5ZStHeXl2eWRzMkk1aDRQczdzNnBFUGFUZXlDbDc1TVE3QXFzQzB3bWxWWHp5VHJna2cwNVYyYzFmT1Nxb3RSbzRHaTMvTW5Jd3V1SGs1RFdabEpCNWtWZFltV1ZrK2NsNngzRWs1Zys4YXNUbHY2UGdiYmhzeGlINWk5ZlFkazNOem44aU0vaGZQRGJiUnkxbzdxU1VoVXM2L2pTWTIrc3ZyWkFhOWg2aVpsNitRRVdURUFqb21oNDVkMFB4U1lPY1RXRzJyRWhRVWlIVER3cWpXMWExcWMzVnJwTDNxMWh5anVuVVRFVzBRK2ZMNlZ0V29hY2pVdDVxSnNiYUZycktSS1R1blpjR3JJdkRFMmVITGVlRnI5amhENExPbnR4NW51SG1jQmUyTkU5MHg0L2hZVmF1c2JpYWkwNldDMitXQk1LTkhZT1NZT010ckhybVRxVVVSZ2NIRHVKVzJ3KzlUUDRpTUw3eDU4TE8zRGh0K1E2ZVdjN0I4a0ZjL0ovSG9zWGtuanhsMVN1T1pSZ1V2N25rMkYrc3ZNSmNBcTBsZjFubzJRWE0yeURMRWtyb1RYaFVtekxNUnh0UXc1WU5rcHNlbjU4SExFbmhaMGp4aDVBUThtRGV4RWdZMzh2QUFzVmJpVDFuWWdXS1lhNUFSQWxtcjFLSURBYzQwKzUzc1dSZVo3dWNtUHVOVE1rN0ltTHAxc2VHTUdxMXMydUlrMHltWjlkVFdWMWhOV29EMVZHQ25hNUxOWmJheUZZbml0TWZud3ZJZ2o0U2xyK3lseFNpOGN1L1IxRVNtK3BVNWNic0lodEJoVnIrR21QL3NRWnFyWCtGTENrQ29MYzZYcHpZMWtJUFVMVVlhbjZQVk54d2laeTNPMU1QeVltdXh1MW1EMWMyb1QrNHNYTW96UCtuaVpydU1SY3FZUnNsajI5OHNWKzVpbGl2ajhZb0NmcjRiN1VFVmxnZEJERllmS1NxdVJLMHJVemM1dkVHNUpNbzJUVENQL1ZXMERLdUNsRXFzVzNYL2p0cG0wdForZEZEdVRPYTN0Q3Z0bEQ4M1hkbksxUEFhTHVtdnNPK2NRaER6ajBldlNnNzlWbFV5STBWd0crS3hyMWIxeVpuMGVWYWhjbE9sbVVrM1Y4aTBESzNITnVFL096Yk5sL2lONFJrZUludDR6eHZPSWpNODJQU20xeENGaDJCOG44RDRrRzhleXhFczF1dWx2T1lweTBEWTQzV3owa0pHUFh2WXlUNVEvVlNFd2RSSUxoc1d2TUNJQW1ub0NOTFFFaDljb0lWdGtyS0crbEMyVlhveXErdzcyeUlkS3N1cUFwZTRMTUVtSVU2TkNVdVBMazBVWmpTSmRadGFmaVl2Y1JUUjJuMmFIdzhjc0VPL2NYYXF6YzR3aUY1a3BDM3NTSnZpQ2NEV1V1OEFBbWN2UXJJZE5HeE9MV09KTXJCWUVJODhBSDk4eE5aRnhaUEFMTEx3c3JJU1Axc0VGZXduMWgrcUdBdzRjVWhTU3orZ1J0VXAyVEllUmlyYXlKWVZoa2xIbXVCWjF6QzVlc0Z2VFRZeStHN2VSa2JMNWJGQWdFZVdMaFpaMWx1OUxvaC9CWVZ4SEJBWTFQdllHMkVqRys0U3pJeHFHS3RnQTdsTWFGSzI5WWJ4WmY4c21RSktrWXJKcG9neWt2bjFCUnlzZFhGejNNQnFkTm0rQ2dsRldEZmNUcFZ1Y1h0VnVpVkdsVzVhc29kemkxZ3pEMVhQeS85ZEZic0JjMzhkcFhUM1ZXTzdkVmpDSy9adEJtM1o4OGdGblo1c3pLUFFuRWNVNThGMU44L09FbW5GeGp6S2plT0d6QTVveGVvbXllc0w1ZHA1ZHhJZER4d0tlclN3M1FtMTJwVWRGeVQvbXExQVYzVlVuQ3d2elFZUkg1amx0VEtmRzlPcmtCQVZ1dUVwN2phcmhJdFVsY1RhVmEwOFliUWlNWmNNVFoxUnc0cjVsazd3c2xQelFtTDdFVHlBV3k5NUEwYmg4Ryt1WHdjNzlTakxXZEIyNDNhOHN1KzAzc2dpcnpPRjlmWER6aHJjWHFWcFFYdVZwcmlISkZ4Y1hFZk1oL2hDRWN5SHRGOTJtc0d1YmVwUHR4dXVxWjA2Vkt1UXFmdHFIbU1Kb3V1Mlk0eTJOOGJTVm1OTSs4S1JnaEoreHBkdnFBNEdtNjE4YlVaOFY3Ykt0VE5zT2R1R3dmNWhZd2NkODRNVjZDTE1iRHQ2RkhDbnBCNEdCU3NGQmFzeXAxSWZrQVN3V0xsSzlxVHF5MTEyZUxOWVFiM1V5OEdhWVd1WFl1VElmTllPWjlTQlZyV1oyMDl0ZGFtZEdWcmF1Z1BNOWNFOFk1WTNJUHEreU1qMXNZTkp4WEtEMWlPT2ZSR004RnF2Z2JIWCtMRFpnWW04R2FNTWExZU43ZzJUeFJoTmQ2cUJPUlhBS21rZU5TM25GSmYzWUtDdW1rV0FnbDRzTUFaTjY2R21sRkJCSFU4VjRobElPUlQweUIzbDRFaldvVkZXRFJMKzhSdVMwNm4va1A2ZEVnT3ZPNzNIUisrY2VrMWRZbDMvdTR0R0Qxazg3YmhqaC9XOWVQcjhTK1ErMjk5OVpGWC9xU2ZVVm5jSzVTWXFUcHAyNGZEN0h5Z28rYXEwKzhMSzduV2RqbDh3cXQrc2VNK1JYZXRHblRIbDhPczhKbVMxaWhBLzU0QmxxY0xvcExsYXNheEZ0V0xuRnRXS1habU1zRU5FcVEvakQ3TmFzUnNhRTVoenZkMlJtNGM2WEttbUZWYzRuNlYydmY1VW9MQ0lSU1QvV3RsaWMxQjUxUHJGbTR4ZE9xbkRNa1pMeklnMW4ycXVaelJsOENiSW9FTG9qdWkvV1FhZFc4aWd1b1VNZWpBWlZJSU1LbG5ySWxNR0NaQkJwWUJkaTBBRzdGUkFWeWFFZ2pJdWhQcEFZVWtwTTdUL3FoUmFBSk9qaXVLazdPM3Y3MUFlRXMxMk9lc3pRcEVObVd4bWZSK3FoVDdDUGRsU3FXd2hsYTVaVXRGSzQxcnZwRjRBVmlJQlZxSXZFMUU1R0lUY2NzRXdDT1UrdlV0R1dGb2NOeFBzTmIyZllTQlM5bkFsQnJGeDJHTjRKcW5HcjZzQlZKbXVLdnlsNEE4d1FsM1ZST3dJd01TbS9vYllzdEZTUm1qWllMTTlBVDVqMnBpNWh2QUNHVlBUVm96eUdqTUdIbVNJVUhvd1kzU1lmbG52bC9zSm5ZU0UwRnZZSXFSS01BcXVTT3A1WUhXcUVpazNwdkg4TENHaTFTYlN5VWlKTzhQUWFsSkNTL3JTM1EyZHEyTUM3UXc2MTltSEhkWlFqRmlYbDB4b0VaL2VreCtjMVB2QTk4NkNjZEJCcTFaVE5uY0ZpaTBDdURzRzMzdXFLWDllQ1R0RUNjYXJrQldPNUtGMEN6cmpJZHZ1SmJ5K3dJYVMxZHgrM2NuejJGekNGWWFJSTFqdVlOWmZzdkpMTUdLdHFvekxXVG5tdUsrKzNEUngyRlZycDZjL2ZIZmV3UHZQZi9OZzB6ajVtcVZiTjQ3WWVPbVZieDgvN2FuYjduaVNkTDVxeHZsekZpMFNMeU4zaUxQR3Y4YWxmT0t4QTRidG1MRzAzd0I2K0tQcmwxNDcvcFB5aWhsbm5Ec3hmU2NYODdoRDV5emlOU2hHL1c0bllhVVJ1eGZ4Mk4wczR0VXE0dWxjUTRhZHM4K2FRcVNWanZHb3ZZdFJXcEVLRjNaQzJlU3JxZHdpSnJlWWY1UGRIWlNLUzlpdXpjV2pQWjNxdEtCYUh5NHNZVWQ3N0VVb1BhdHE2R2JIeGNDQnRqRjhlL1hCUDdXSzM5dVdDOU9EcmVOM2lkZmhnaTBQQ29Xd2F5OXNYWWxiQ3B1MWlGZmlGaG1pS005VTRoYXhTdHhpb3hJWGU3YllVSUZDWVFNVU8vMlIzSHdERkxkWGxGdDBsS0xjTEU2dzQrcGMwM2hQNmJoSVY5N01yWGVUQzR0MXMrZWJ6N3ZUL0dibGNYa0hsY2NWUnVVeHpyT2d1SXhITS9VZXIwSFkvTXYxeDVrQTUraUZ5SVZtak5OQlFUSzVQNHVYenA1dnFkQVp6MVMzbkM5WTVYU016OWZNNTNUSnpEZkc1bHRtekxmS1dOOVVLRnlLT2x2R1ZqZ250NFN2TU15OG9LaWRtY2VPdXNndDZkT09WL3EwYk4vazZIaTVwZFZaenFucEIxeHoyWkRCWmxadlZpa2toU3RhUzZFY3BCRGxVb2dhalMvaVdvK2tuaU9oclNWYXo0eElvb242a0EyOVVqN21Dem5VcTRhWHBVWmpRcjBHM3NqSDNHQWxwclRxblg2cG5Ba0ZLOU5RSEZIMUtPSm93YkF5WVdTN25IWUY4N3pwYzg0eGhFSThtVmlwbmQwUU41eE8wMDBnR25GUUpsWTZjcjBnaUMrQ25yVGdQRWdXNTZIOE51ZHhZZllpalNDbDhwcXN4VGc4eXlnTWxvNThBYzg2aitVOFczQWVwQ1BPUS9rdjREd3lzV1dhbEU1cWt5UTliTUhCV21xYk9ROVdHOHJra3dzNzZjUjJxME5qN1ZXSGxoblZvV21IbEZmSXF1NFVWUzhxL3QyVm9sbG1vZDJTMFg2bVBXaS9kSlI4YlpxRDdEbmt3ejZZWXN5aDJKeERPYzZoRTV0RGdUMFQrZU1jMk5GVjNQb2ViejV1L1ZKMWswTUY0eTZ4NlhDTEwramx4UjFNcHpVSTdhQU1kbGEyK29nZGxNUkszYkkzK0JLelFKYmxUZmo4TnJNMUtoZDZaSHBKRlpvempJRlRqOFMxZUZKWFFjTTZKOHp1b25rQU5qMTV1SzJEV1gybDRNMnVTZ204V2FFZ0Z0QzdHbDFHSzRKSWZEaFlleDlCanhWMk5Pc1dHTEo1emkyM2ROYjhNL0J4ampsM0VzenM1VlpTMkdYdTR6eERBdUtWemJ3SHEwazBmUHJrRHFzU2k5cXJTaXcyaVFYbXhPMXF2ZW5DbmY3ZlZhS1ljZHR0YWhWUE11bVFOaldMRm9kSjJiY1lleWxtOFRvWWU2eTlzWmNaWXpjZEZJN2VjRTlPZndxOEU0c2lmM3NHMmNyYVpocWpXM0FrYmVZaWZaVk5rY0NlNC9QaHZxY3I4dWJ0emdnWG93djNOMlVKbzNVeVRxOCtKSm5PcG5taTlaVk9KRXBZVzJYV0JwZTFUV1pPeDg4Y2pCVkNhTC91OXY2dTZYWkFvTFNaK1AzdEVDaHRwaTlmMFpZL2tYajlJY2dnekhyY25kYTZCaEZMOUxvbXNSV21WcEZnM2U0aWUvUkNtRjJoVDQ5aFZHSjB0Q3VNWVB0STFNdVlxbHRrK042WlY2ajkzdEpGcWFONm1RNUtHcmUzblhKN1ZZNldlSnRKc3psbmVrSVZDemNha1hCMkdsY3JORHRycGEwMk5aT2VMc25PNFhvSWxpZ2F6YzdyNVJBcmZETnErVDNZTkVxMEVoc3F1SXdCQktKTUZZTUppTlFLbWJMbkZISXFTVlYxVHg1NHh3NWFTMkVId0tTSGhKcnJuOXRwTnZYdUNhZHRPRzU0VmJSbjNlZ2hjNjVvMVhycTBGZUR6aHMyOEt4RXB3ci9vNkhGR0wvQ21vZU04Nnc5c1RjMjlrdm80RmdyZGg4enpwcTFPdUJhMC80QlZ5MW1IRHZERUt4WGk4T3VNYlhlRlZiUVpPbGRNTUJTQXl3YTg2cXB5bTRKSnBNS1BGQVdpNE0wOGcwcXBRUXhHUmJjaVFhdDhydE93NUkyUWp2cStkamNGdUk3eW5IWnBrVXRSTWw3b3NpcmxTRHNuK0tqZHNJcXlYVENpdjdIT21GbGNwZ2Q1WWhmTXNGRzIrU3dmR2xXM01ITzBraTd3STVqaHFqOUU3TEZtUk95SmYrQkU3S2tHUmExRFlYSktIT2NiWU5nK2ZFVzQ5eEl1eGs5dFFveE92S2F1N1JGYWxQTGo2ZkRYRUV0Tm04bVpWejBXM25ObklUUkF5d2Q0THFLN2pYZ1Vya3Y5WVl4ZzVSam5DbkxwRFF0YmZRcUs1bEpKN1RjaFdZZTg5ZVdPZ05Zanc3S25LL3RKdnc1SytMeFo1VXBtREd2VmhWUFYvQUp0b3ArcTF0RnZ3VVo3Z01QbVpteE1PYURDbXpjMXNUVXRPVFBkVEwyTnV6WHFqQXMzZ1JoY1VXbnpyd0pZQVZzeTRJWTBpVzZzL2hmRFpMYkNPZm8wZkw2RnVMcUtHWnVqTFVVSC9nbjBlZ2I1UmI2OFRNVTJINk1sWit3TGxpdVBScEpNTEZnVTJBWE83WHVzRmNaYmJGc1Jtb1FtNWhqdzZxSXd0WldFUjhqRlN2UC9WbnMyZmpnc2VKWlo0dnJhSGo4MXR2b3ZJUGtyVXArYmtPOHdyS1RuOXZBYkowbXhsbGJFanQvR210QmJIUUJVek1mckNvYlNlbXg1K3IwbzhIaXBEbVMzUFI0cDZmT2FicUd2TmpaN0xGektkZ09MMWppazl2cDhKVGJYb2VudkZZZG50S2l3eGZJd1FXMStWTlMwQ2dRNnJqVFV5Wm1hZFh5NmNsTU9VVHIxazh0NmlMNEdka01mdTNnWkdCUmV5Y0RpMXVjREt4WFFqbUZIUC9wdVhsMXYrT1lZR2JrcmM0THhzeXF2OWJuQnB2TEFKbWR0djdEY2lYWTZaaVpGV0hkNjVqeEEzakRlcWxoZDZoTWZqbnRjQWV4bjUzRG1razFZNFZIeE1laVdvd2s3WW1VcDVCVklidEF2Y29OR0pSU0pkN1ZsdFVqRjlacERsVVhzT0d0M2E4Vm1SM3M4UHh6cHJ5SmJ5Sis5azFsVzJrQk9aWlU5MWtlbFhvMy9aM1ZPNFVibnkrN3VncnMvTE1rZnYrYUFSZVdSUy90dWU1K2NTdVpUTTd6MkF4RFkzZVFSV1RpMS91RHFuU3FQM1RBNUppVWZMQTF4VUtWa0JEdTVYMzd0QUtJc3NEY3NGUlp6TEQ4QVByMHpxWVg2QzQzcEx1NnNaK2YwWHVVYUVrbWdoSTdLMVdyYUU2amRUT1dGOG5xaWhMTW5ra3NlNlpiWVZXMWJ2NTZtNXJETGdkeHFucVFIUnQyeDBBd1FVeWpwSVFTaEFDNmhPYzU4UGNOQ3hPT2dHY1hzUFE4eTg3Z2pROHQ0MitMeVVxNWY1eXo3YmhyUHYrR2lFMzlySDljZnFZMmZXVDZNa3BYcmZqdXpuMlhaaDNoL0lUOFdUejM5Rk1XUXNpbWtLSVJ3MjVCZTJOYnZBSU1Ubm5GNnRWWEhYN1lDTms2blgzUlBPYURXRjhwMktPVlFuZXNaTyt3czFTUERqcExKWXpPVWlsWEorVGl3ZUZ2NXQybHFveGE2dnB3dEdzM1puei9MN1NZeW15UjMrbzFkYm14WjM2ejU1VGxRUE1lWW1jY1llK1hRNlJ3UWJ1bkhPTWRuSExzYmxMeEVMalZzYllubS9sSng4N1YvS3hqMnVxMWRLbGlZdmpQblhac3BtU09ldXp4TzJQK3YzSDhrWHlRWFpQQ2VoQlpmeEZzTEdJOHIyVWZJdVRpaXBKNHZoVG16MG9EZUZPaWVxOVZnY2lBSFpPTk03NHN4TjZBdU5IZ2NFQXN4SVVOTXRqVkNRQjA5WHdyTnMzSTRVRngyejVHSGNaS1dmMk42dHNyckdwdWVTVFBhbHRieFhzZ2dhN2JCWDhIWFpBQ3JOMzBVVStFWmNCZlZqdWtKaFB6bVgyUnNsd0tQSmVkUXdPOWF2SGNGaWZSL3BYblpoMUphM3JMZUs1NU5pMjdNTnljcjhLZU83U2QrV3BxSEE4VkZScjE0UTdHSHpMeTBPTXdqcG9jYlVCbS80TnNRVXhqL1E5TU1WaVhHTTBQVEJuc1pHTVoxbzRNamo0VzN2M2hkNDBtV3p6YjJHaE00ZkFtRVlCMWRIbU45SGZHUlViWkhTMjJaS1lNM3hQbk1BcTVITTFaMTdxU1VjOW1ZRnBRekhpZTVqajVEcW5FT3BYVktZNWtONTU0ZVIxK2lOWGh1ek1kMXJGNXQzR1V5OTk4MjFuSDk0eGswM2ExMlhUZWNaZk5uWDNOMWVmTXVmekc2dXJLbmowck8vVzBYSExXa21Xbm5iVnN5ZXlxSGoycXFycDNoL20rQ09ONjE3SURSdFZaWUowbWtta2Jyd3NPMnJ5MlRDb2NUN1RseEkzelBRRkVKMFVpT3Fja0JwL1ZJcDY2ZjlHeDhyektFY09HeEFwN3VWYzVycDBQcjRlV3dtdjVqbXZYbHBRWDlVaGVzN2E0dkNTWkZQNE42bk1iOTNkY24vdi9kRTFwMTMrdHBwUUlsVWNPV0RaRFBGR0VaelFMV2I1RDRGVysyYzBWMDVaOE41dXZVVUpaeUtsNG1HSUJBNEVGMkdxeGtCMWZMY1N6bWdVOEJITVl0WlZodkJPRDgzNFdOenZHbXVuRG1BZ1hFcFk2NW5jYzlDZWd2THc5WXltZFFVYTh1Ky81SGZQSG5YcDhzbnRrOUJUNkxIMGYrelhTcHVmVFMxNTZyZXhnNTZKQk5Zc25IdGQwbWJ6WTdJRmFDRHBsRVR4Q3J4WWRvWEhZdkkwS2F3OHBtTzBoV1RzVlBFMEQzaXBMM2xKenpmVDhwaTBGbWVqZzRPRVZ6ZGFiOTRUKzFISzVVQ0FZTndycVFkT0NPZ0ZEZTlROFBJTHBzVGJVMi9JWUVWTElocURhV1lzbGxZMUM5Y0VvaXRDc3FFRjJTWnB1NHplaTZESm01cFFNS1FLUWh4MFV4WVp2bVNxRkVtSEJJNlRmTzB2ZlBQUHM4VmN2di9kVnB6aTU2UUhYOXZwN3Y1NzEzSVgwU2ZxZ3VPa2RNbVJqeitvRHNib24xdi93NkpaaFAxZEV5WG4vSC9VTS9ZLzNtLzUvc1FiNnY3cEh0aWg0ait4VHNBZHJIbGhHamNlU2VBWW1Id3doU2JBRHlheVJ0VTNrdXlIdGlPWGFzZ0pKL3g0OW4wV1BXajZ2MFBEd3NtWHN3ekR3cGw5V3NUNE10bXFQWnQxaDBZUGVYejFhZUlkbTlkVXJWdU51eWxBNEdJQm8yMnJMYWhjSzcyRzcwQlNBUzJ5amtMWUYrU3V6YzBJczM3eXNsQnNaZjIxVVRXTG5YYmt6UUVyRlFheVZwWm5qZnQ3YUhvbStQU2NWU2QzbUU0SGswQWI2SFYxTzkzbjdudkxZNmhQbCthZXNXTHAwemZIaUQ0R3BoOFE2MnJUdmcxZmUzU3N2dm96bTA4WDNpRVNlTWZQVVNhWi9VNGF3WHJMNXdpeWV0MFk1QlF5N3lycXJxeDZqdTdxbUpEQ1BrbS9OSEFQejh6N3JmdGFmR2RsbDdKZG5aWDF6SWthL3dVSm1OQUxJaGtUTS9rLzRYL1BNMVBMbWpzSVY1RVZTTVk4UVkwYkxhRjl4MytRVnl5Ky9mVEJ2ME01bmdrM2FmNWd4YzhaRXdlZ2Z4M3hEUURpSjgzVFlrNnFGVi9ENU0xNGh5QlpYNVY1QjlUUGJobDdCcitKTFAzb0ZsZDF6eXJ4Q0tMc1hiNGJwYURiODgxOThuKzQ5ZGlSOTBMVDRPM1Vxa205YTJIcExQdGg2N0hmZHZWWG5lam1aM2VaYVRQRGUxc1RjZTF4VXZFOVdOaVZVUWY1QitsQ0xHS0lwYWh1WE1mcE4wOFgxVGJPYXFzVWRUWU5hWW5jY3c4MUg1N0JJSmh1STV6YnRCb2NsRVR6Z3h1N2swaHhxV3ZINmcyRzBubmJ3a3A0TWgyVnhtMlAxbWozVkF6RWlaZUFNc2N0MmkzZ0ZtVUVQcWJhbXBTc3lrS1pwWnYxZjVPSkRxOFUxSzRoeStOMW1hSVBzSWZpc241VHVJTFdvc05oZ0VQRVdEb0VySlRoM0kvbVR5aWxtVFFIeTJTRnpnc1dRd1QyWThhbVVxNHdXU09nWVdDWXNoSmxucHk5S2VOT2pla2tNTUpxMUFHTlhnZDEwZ0taR1VIWFJ3L05nQkJ1VkVZOW9Kc0ZxVFZZMXlySVpwRGM1eWE2U1loS240OGYrOGRuckxqcHovTEl4TTZMMGZTSXBFK2JQT0JXMnJQK2J2WisrYTVuWGVDZ3V2dFBZWmV2Nk1ZV05wY05Pc1R4eTJwaEpwNlR1WGN0c1A1MGpIMkljK2dsOHBuampJbG9uSjJzdzRXVFhMVGEzNjgycVp6Y1dDNUdaYk5RYXRIdkpBVGxDS3VqWjlBdkxQT3doZldnMW5VTnVGZjdON2w3aHVPaHlKZ2VHdGRtYXUweUFKK014eGFDekZkWjI4WDNzWWhqRkJmc1k0eEdmMGJFcmpOc3A2R0p0SUUzSWhGYkhGNjNNR0J3RVRoY1NIK25VOVB5NXA5OTYzYW9OSXdBKzBZOCtlSVdPTmd6TS82NDdZUmoyekw3UElRdDVXdHREbmtyV3ZTTk1XZ3hlTXQxeDBEbVdoNWtQRHdqVGpQWHlTQTI2WUUwa1VrNTJ4TTdwaGlXeEpUallWQ1h6ZUtsNVBhV1huNGVwdDFzaGhtUFVlY2k0QUFwdi8vT3F1dXhoeUtNMm1VY0M3TkpReHBIRGwxVjB6TG4yN2txcHk1UDBpOFk3NlJka3ZWaEV2eXBlOVNNSmloVmt3T0dWVFl2SXJYU09lSzEwNVY2YTl6OTcvd3YyTHU4Q3oxV3h0elI3cnRPVE5QcjBXMnpZdTl5UCtKVzFpc1ErRlFtc0ZPTk5pK3BseGUxalRRRjZtQTJ5TTUyeXlYZTBtc1RKczhSUG5pUGRhVmY0K1VVYUI2Y1pGOThVMXpCM2tPVVM4SXZqYWZrTzgxNUtuOWxBbVBIcFpaYUdkR0dCRC9uMFF0VGp5cmlXczRjMTlvZ2ExWG1wS0d0WUh5MHdiNlFNRzZmdUMxVGRIUURWTFRTeXlHWHc2eFU4QmNsdjUrS25MekpYVUpaVUduY21aaTZxeEFybnlSY1J4NzFmRU0rMmU3ZnZwcnRnSXE4OU9mbjdzOG1wbjM1d3hjSVBkaTFmL3NJVGNzT1lZZHZXck5nWXNRWWV1MjdIUnlOK3J1cStlK3JwWDAyWWNjS0VCYzMzY2R4OHRQczQybm82MWZCMFdQZmhVSFhGVy9mN1BGeHJ4OWJHb1RYNzN1NHdua0xoMmpZandzUW83NmFTQ3JMTFBvTVJkaVNWWldmNFNPdDlFckZWNFgwbzZOQ2FoMTJmWTNmWWpBYXhjYnpja01GVTFZY2UyOHZ1TjQwWVY0T21GSnpLYjNqckZtNnQ5Y3kydDNGbnJWMTM5NHc3TTlZZ245M3gwUjdpY1dZakhsZkhpS2NWMEdrSmNOaHpBT016dnhrUWJqRDhwcERrZVZyRXFrNGZYdkxMRWI3YnNEek9QU2FxYXhmSXV4SEllN09Bdk5kWDcvRzYyd0I1RDE2UUFVRGVZd0o1dHljYnlMY0E4RkVUdVdjQSt6eTZsLzZaNDNRVG54OWFuY0htLzR2dnlmbnZ1Ny9wMy8wZUhPNkhEN0hlL3ZHV3FJdkRMVnQ3Y012ZVl2NGI1UkdnU0FRRGEzbng0WlgvTm5mci9EdmVPL2RmZnljTGkxZVlMZXJXTmxwQmlYUGgvcTRRby8yZ29rME1ZZWFPclFsMjkyYXBVSVdkNEZuL2RDUlUwdUhDb05WZGhmMU53TVZyYWlJdGw3QTN1aVR4ekNXZ012TklvZEhtbU4zQldaUmd2ZFYxSlpaZ1VYeWwwVW03RzQ2K0JHdDEzY2E5cjczSyt1TE5vZURZa1FLU3F3ZzI3eW90dzN0Zit4SVZtWDFUYVNhdEpPVHhCTEVuSGlQa21qdm9UM3FJL2h6UzZVOTNrTkNHdGU3SzY5ZUwwOXgzUEw3Kytrcng5ZFg3VjJ6WXNHTC82dHQvWGJwbno5SmY3N3ptUG5INFdqcnVudXN2WC9mZmU1Y0p4R1NXWGV3NW83UHVQUk5ZUUNaMEhKQVpVVmk5UTVGNVFwR1BoNVVFSzdZVzlFZHpaUFpYTXpBN3ZLenBjaGFZRVdFMjZPdGVway9EalpwWDQweHdXclV5aWhzcnNPMkl5enlXekk0MkJ1Rm1WWS9zb0RQQ2FiZkVLc095RHdEWHNpRXdYeitibEU4N2QvU2FCYVNTdm5mejh5ZS85STRVRndmUThLd3pTeXJGK1dCT2N4TmwyN205VXE3SXR0OEdIOFMza2NXZTdFQVNaaWNkWjRlaHFVWTZFY1ptTWdtdzhKVFZsYzJ4aldVNHppZWMzdktKeGlKNFlCRjhtWTNNUjZBZWZRVDFIcWZOeHZYWm4xa1dweXQ3V2N5bFNXWU5EZGFucVhsNDVpTHgyRG5PN3VFTFliekthdVhkV1FtSnRCUnlNTDltNWU3R3lmdldpQkFjc1o0NlRpU2IzTno1S09aTkZ5RzNRYWVyTlZrY1dXWXZpVmNzeEdpVmZrUy9vSE5KT1lhc2o0NEVRMlF5ZkkwWEc3UVlqMXV0U2NNZlJJVHhmSVJhTUtrN1RYWXZCTDQzMER6R25GYSsxOXNzUVRRT0VYNWZtT0VpRkVOcWZJek5JVFhoNnpxZE9NRXhmMEsvT21uVXpTdXV1RytRVkVmS3dVZnYrM0RYdTNzaHNwNDVvZWtPVG1BM3gvMllWejNXOE5VT1k0aHB5Vy9QakMrUUJSM1JiM2tNd2JHOHM5L1JhbERaWVQ3ZWROZ3l5RWVCWldKOHd1NFJ2NFBaMGFuR3JhUnVNNzRQNDcyWnFnMjlwOS9hVUo5ckU5Rjk1Y1UxM3g0dGtHQk93OGM4aFUvbGJXUUVYWFd6MUt1ZWEyTytWQmZEemZjVWN4QmhHdnRvRGErUFVRWi8rQTlTUThiU0Irald6NTc4K3Q0bnR0dWFIaFJQdG15Ky9kUk5KMXVLVDZOWGdiRjZtTjQ0OU9kaHV2N0QraWRxeW8zODVKSDlpZzQ0eHcveHhmbUd6MmVac2JBUjJxWVVrVGVwVEV1cVd6RlJWbEVyOXRiWHpONEdlSllQY1RJcnQvVHhFc01jQ1BFVWRvd2N6d1E3QWpsMW1XM2piMFpHRXNCM0JvNVliaGYza0srRTFCRUgyTnorZEFkOW0rNm5MK2JTbjhUZTk5eEIrcTVkczNZOXdqWUlZTXZvZFlDZ0hxWFhrWDZrdXVrUmNjdlgrOG5mdnZudU8zWVB3aytnSDlNWnp4RE8zSE1ITVJTYldCQ2dqVXNWY0dJdUsrK2lKbWZPRUVHb2hMMHA3VVlqTlkrTUJmRHNmaGE4OGw1Z1NBK0pocURLZWpuSENIWUJLRXVpRFlpUmdPbkhIT1Q2UmN1Smw1SVg2TjdOOUtsTExsNSs3YzNuTHhOUGo3OTA5ZmJYd0VMaUpYZXZUcDFERm8vNy8rQWVJandqZExwbEQ4d3ZKbHd2OEtrVnNETUl1azl1MEN4eE03V01zM0VsakFrWmFRRWpnNkpWNUJIZFlxM2VKZWhXUy9VdWpGWWNYKzg0d0x0VlczeWFoQkdZWnRzQk03UkJxTUwrWkZlb0ZiRm1GdXl3VkFtbWFnWGtISHdxaTFRQW41ZjNLbzlZTFI1Uk1jb1M4UndScjlsVGZiRlNEMEQxQ0ttOGtSUkdsOUtkaXhmVktaN0VnOU5mZUovdU8zaVFIaUNkTGpuL3RhM0pNeWVJUzhsOGNra3lwNkxSV3gwWXVXcmg2QW5mZjBvcC9RekNuZnhuZDVNQ0VveVBBdHVLTlpaL2xDc1lwNTdGQ2NJaVkvTnB2UVFXT1RlSGNZSzVjak1uaUZjSHRlQUVDenZnQkhNTVRqQzNEU2ZJcnprUDhaUE1HUU5YWTVDRHQ0c2w3NzgzWi9hQ1AvenpNN3B2MnZRWk03OTZjK3IwT3cvS0ZhdXVPV214WDNGZmZ1cWFlMThlTW1CZzd4ZHIrczAwKy9BdmhIbGs4WUdFWDM2VzRRT1ZEdm5BMjhVUDZmRnl4WHVOOVV3M0N1aVY4Z0g0TE9RRFo1bDhvTnlTRDdRalJadmdKVE9xYlBLQldFeFN5WXRKdkx3a21sT0MyRU1UM20vRkNxWWttUkVheUF2MjhyZmdCV05Xc1dEeWxLVTU0b0cxOUhCVEw5cElWcEpWZXlQai83WUtuSG1vOGZHbWpXUVp2VkljSzE2czArZi90OTJqaEgzLzdnUDV0K1laeVgrU1ovd3p2WmhVa1NYRUExOWQ2V0x5R0gyRnpvR1lmNjdZbVRRMU5Zb3lmbEdwNlIweHYrbEwvSUt4REQreVgvb081TnBKV0Npa0tnV3VVcWs4SEVvQXBPcHlWdWFoeVVZTjZNd3Vzdk1sTUdtZkxtUUxubEpZdVlhQ05idllJcUJRZ1oxUlhNSVM5cFU4WWU5VWRZSjlGVno4TDdTQXFvY0xzUkdqWDR1d0ZHb1JhYms1V0ZGQ0piY01RYjZCVU96RHh6MC9aZFdxVys0ODc1ejdyejNqd3VGUGpweTQ0TzByZDM3L3R5dk9YZmJkUGZTbitJR0tyb1A2RGhxd3E2WlBNbGxXL0VwVitlMVhwSHZabzR0bXpMeHRuSEVIeTZkTTUwZG4zY1dNcGJyV0pNdWFrQmJuN0pEaTlwcDhvd1VMS05rbEl0aXUxSlZoNkRLQU5DaHg2cVdXM0U1eXdtUWZtVXEvQ2RBY3VZSk9QWlkyaVEySDk1S0hGN3pXbEd2VWZIOXFPY0RPcGw3ZlppUmFianp0NXp5am43V2I5b2ZZUlE5TW56TWoxTHg0TE1qRHQ2SW5udlptT0VkajZGb0l6WlZaSk9EMTRDVnk3bngrTWJodXphMWpCeGFPTmc5N3kvUlppMW5ScGxZc1k1dHBXZzZZTENPWCt5YVFlMHVPa2JUa0dKWGY0aGh2SjZYa05qS0lUaUd2ME0xMHRGeVJyY21DR2RlUFlYdXFOOGZQbkRUSFlKRGZWWUlhN0dmRmZuWit4QnU4bG9PcnFFdGxqZFQ3RTBSNmFLZmdQNWhjckRSZTNXdFluNUJVQmlqK3g2S1RiMXAwaHZPYndGb3lsd3c0dkZjYVJkZlFlOWVaOS90WTNvSm41d2pyamYzczhodDNGN0ZUblB6c1FRN01Nb2NIZlI1MjVSU21idEduRGxqNER5djZWRm56Y0FyUXB2NnFXYlBZVFordjN1dnp0R0UzNFQxa045TldqMWV4OFJzZjZxM0dTK2FHM1ZnSkxqcE1TbG5qbHgzeFMweEZOazNGcWtneHFTS09FcjdoaWNMdTl1SllsNGZKOWZRSGI4L09UNysydlhPMUh4YTM3N0J0ZzI5WWVqWlpDN00rdnUvTFo5Rnk4dkhzWjQ1cGZNcTgyK2c4ZHEvRHdGYnJtOFVYeXMxOG9kS2FMMVRhaXpkeHZXOGhwU0QzdVRDQTJlUjJVSzBuNlBCLzY3dUx1Q3ltZ1N4YWNvVTRNS3ZjekJVcXpWeWgwcG9ydkYxNmtYNUlMOE5EK2RJbzhOYi9tKzVEK25lNVM1SUkzV0NkRkxaT0dZNFJ4NEMzU0dSeGpNcnY0eGk3U1h2cC9mUWphZFI3eGoyRS81UDNrT0I1dUc2V2R5MDd3UTdtZ01hY3kvR3U1a3JxSWJ3eUpNRlBwMWlUZWhoK0xFNmc0NU16dW9OaHBwOUg2MUlvd2U0SzBDMjVpWVRSd2RmVUpsNHVqSGVQaGxYZExyQjEwVVdGczQxQ09jZ0VQRmhRc01DTE1nRTJWRVQxRU1JNnRsVk9JdVdBN2QwUVoxYlRQWUJNRHNKL2I1Q3FteTlkOGlleGFQbE5OMXdtQnI0bkVUKzVrNTRacHA5L3RZOStGYVkxNU5WY1V2TFppb2RWY2Jsdkl6MUdmZVNxWlgvMi8zZmRLWE03dmRKU3pKNHgzR1MzNUd4MmkxR01wQ1hGcURUVFdvcEJNYWJ0SENDM05IWEdMWGprSVJKYlF4dmxpc2EwTkpKalg3WmZBQ3pLcytEWnJJcmRaZW9wdSszQjRrTEQ2cE16Wkl2eFVQQ2hlSWNGbmlGaW9ZdHhrN2h1OFRFKzI2QVdXektMQzBucFplTnZISWJtZHRaakp6NitUVnhEcnFOTHI2c29JcStDMlgyd3Btdkt1Sjl2WjdhZE4rWEF0azRMWHJIRjlET3NYb2QyL2d6K1pjd2V2Zzd2WlhidlN1VTBGcmY1VEM0Qm42Z3J6a1E3ekNKcHpTeDJOSVpXekdKYlBqR2FOYVMxOUJBUm04ZGxyQXpuRTZOTUZnSGtFeGtQQnZnaVkwWFNVc0NlOFh0QmhqbGN6TytsSE93RXBVT3daMElvUlRIVE9hNXNQaEdqWWs0bmNqWng0ZTRmOTlHdTFFSml1NTQ5N2ZRWHdkclFNOWZlUlIrWFJqVmRzbUpBTGVjUkVZZDh4TENXSDJ5UHlTTUdraXhRWXFvVEJKL3NkMlRHRm1ubGt6M044Z29ZZDFweFc5V0NSK1NscEpYRzBBaGZ4dXYrMmREUWNOdUtaMDgvN1FwSnhOWEU4VDM4Nk1zd09OcWZkY1RoMlBjc2RrZVMyc3dmR2tOTFMycXp6UHhac0JENVE3Y2hLSWJhVkVlcndURCtrSTBGeHJIN3gyOXBsM2RlZ1hIczVHT2dqNy9NQlVTRUllQi9yZ2YvazRzOVBITU1qV0ozdytMeVFReWI0NGNJMG1aRWtIbm9CcENmRDlrYlVsWjJlWkpWTVlsRFBHU0gwRkZCNkloUlFjaTQrRVh6bzFVM01zc1oycERITTM0VlFjYVFCMithZmI2RG5rdHVzczJhdm1ERnVLSHB5YjhlaE5qeHBmaG5JeTllOHV6Q2hYMTNScXZBTnY2RDdxTmZtSGRLVzhmRHVMSC82TndXM0tFSkJCUURDR1M0UXpsejhOeXZ0T1lPbFFZVEhwajE5TGxZOWFtNHMxakQzQXhybU1TYUVJSEJvNHJLbUVxeUFCS0krN2tDSXUzK2xEanBMMzkvc3pGdk8vbHMydHl6cDUxNnpqblRFTGE5K2lsOWo5TEQ5TU52UDZURHhkRGQ5OXh6OTkxcjEyWHEyYVMvczNpc0pWZUlFd25LelZ5aDNNd1ZLaTI0UXVYM2NZVTlDTDhsbDNHRlVvWXJKRVZubmYzMVMrUTcrdEhkQjdyUG5yaCs1OUN4NVA2cTlmUHUzQWdtN3pxNlVQemd1QkhFTlVUNC83QjNYTnMrWWxmK1grOGpWbDlhM2NsVzlUL1NTQ3h0RnNCZmJBaEVPUElmYUNURzdJa01PQS92T0s0UVZnaXBjdFRnVUZ6UFkzQWNvcUEwNGFLeEpEUXB6cXEweXRtTjJHVXdhZGtHWHF5c0hHMUtHZGlVVkhrWnZpeEh2MURHc1JhZTlFUmhsWlZ6cUZXZzFyczhvUWdUVFY2SUJYTmFPYnZMUXZDbm5KNlNPbjVmV3hKUktidGp5cmcxT1hNV3BxYjVUbHNaUWl0U1JkLzIrR2U4OWRTTzFJTm5EdXRkdC9DVXNSZlBveC9KNXoxenh4M1BxR01lVy92U00wMytSNStJZk9HL1Y3emg3TmtQYnFGRDVQTzREWmVXd2w3QU16RjFiWmhJYnp0TXBPWkkvTmF4R01aUG5wNDVlZzVBT3V0d0lZOGJ0akc3UFV0SVJRVE9TSEpOdElFbU9qMFIxRVJuczkwVzlxVGRka0dSK1dVQmJnR2JGOXFjSHBXTHo3eUR6S1Bpd1drbnMrTTIxazJvT2I2SUdyY3RtYWRqZXZGU2hrbUVFUC9HQnliY08rdU1lUjV5SXozUFBmdTBFWCthZWZVRytnczlDTUZHUHZFUGVhMy9oWXVlWGJhb3RNdkh4NVBnLy9MN1RQODc3OW1Xam53RkR6ei9mN2lmWGw3eitablNpYi9aVCsvZjhXNXdWck52WFFxK053SVI0aVFqSTVJREdobHV3Wmo1WVd2Wmk4UG9oWm1XbG1BaWxiRll0Z1FTV2ZsR3hRbUxDSE84SEE4VnE4d1paNU5wSnBhTk1VcXQzSUJxbkZvVEQxLzk3ZWUwbG83OWpORnIwcGZMbjVnMjlSS1RaVE1oTG1QYTNrY1V4K3dQRzd2S1VaemJPQWZqTnhFdXNrNCtMTHpRY3BKR2lHSlNRaXBIUWlwdk53VjY2R2ZrT2tLamtCR2hNR3puODJPMVFhaEZFWWd4QjNZRXhvU2FaRGdwTllaUG54RG5zcUZ6dG9vUEhCbXJEUGFVV2ErUG5VSUJ4dVQ1QW10cTNLNmZLSXhyK2N4UDVKbCtJbzlWbk9haG44alB3NWY1NkNmeU9FWkhPNEgySWkrZis0bUFxcnRZUWF5UXo0Ny90ZXNVb21yUGRsMEIvWGhER3lkd2xaajR5ckQrWnMrU1RXRC9XNStUSVMzUHlTaS8rNXhNSzJxM0l1TUZzaW5lbG1mTk9ZZitGdHRUSjdYRDVrZmFZL056ekhNeUZvUlo3RElCcTl2bkQvSnVMMGRuOVROblpGb1E0WThieUtvdC83MjkrVzRlM2hQdUFJeTBqTjFFMmJJalhHazhuYy9wL254MmpWMStFYXhzSk1FQVpHUVAzcWlKeEg0T2R3bkZCb0RNaWVCSkRuK1pHNGRlcE5aYjVERHpDc1gvV3BlNFZpZGtPcUNaNkpZMmJIODduZUcrYmk0cjVweUovQWNXSDQvSU9pY2p0enduMHk1bkF1RGVZRW95UjJVNjVBMGVJakY2UFQzTTQvUERlK21WRUp1em1rYmxiNVpMaFlTd1NraDF4MmQzU1dLSkgwZzE1ZXZPcWo4Q2VBOHNWdFdVSlhXSGhkOG94aHV5WUEyOW01MlROeTlteDlOVmxVWkRGaFJzU3BHNjh6eEt5aHJ0eGk0VTg2ZEt5cm93WCt6ckRwTHZocEZJdmFDVVZCcFhxbG1qZGMyZGFzeFRxZGpXQ2VZUmJwWHg0aVVuckZWNGliQ0E1QWxIaGp3NDhLeEJrOG91dmxwL2FNeUpwSEx3V1E5dFhIbHgrY1JqenV6MzhGQks4dW5MOU12NWp3d2Y5c0I4K2hWOVNkeExqaUZuMVBiWVhWWDg5WjREaDQ4aGkrbktZdzRmZVB1YjRxcmQ4VHE2am00RFU3cDQ4QWtuRENaWDgzdEYyVDNYT2NLWlJpK2JJTC9uV3JmN2twbThCYkd6UzY1aEg2VWRkcUVDbHNiQmorNm94dWt6TzhGdGs4TkNzSlF0SEVHcCtQeEdmeHE4WFRnbHMzS0l6RDNUdFFFcEdvRHZmalhxRTVXb2swU3RwUHVXWXBmaXF6dnJZakowWTEvYnpNbWtiTnVMOVBDYSsra2VVTGk3cHk4WmZSMVJ5Q2xOOWUvZFFpNGxBWHB2MDZIbnlEbjBOak9XbEhjeXpqTVBUMHQ0elFQbmJMT0I2aEVzZUVpazdYbXNwWm5kMnNBTWJUNHJEQUlyNWJjYmh0YnZZeWszTkxRK2R1RFFoNGJXejVQSFdBQmJnUFlzejI5UWFXckdzTElxcHV6cXI0T2tncHhKNzF4SXZLUnowM04wRHZrLzdiMTNlSlJWMmdmOG5LZE1UVEl0TTVOSlR5YkpwRStZU1NHRUxqVWdLbDBVcFZnUXBJa0k0aW9vMkJ0Z1Yrd1ZXWEZtTXRqV0ZleXJ1Ky9xK2lvcU5tUnQySGF0cTBLTzM3bnZjNTVuWmxKQTMvZTlydS83NDl1OVFtYWV4TWs1OTduUE9YZjkvYXJtWDMvWkZkc21xdlY3ZHUzYTh6cFVOS24xQjUvSG9pWSsvdWZVai9GT08wTWZmK3BDdzhBMFJOclFwQ2JNcEU0R3JBNUZMMW5JTitaaFB0dzh2T0xLeG1zdTBNYzhlb1NkZm1EYmJCcmRCakdWT21vaTVSaFdVWTU4ZStmT3Q1L09pRDRScUc4eUFYOW51Y0VkVXRTN3Vpa2JxcHZLaXBoSkFaRCtZSzA1STEyMklyUEZxSzBwNTVWTzVRaE5xMWM2T1NNSlR5bk13K08yMW1HeGpRZFErRXVBZlFpTzdFQytFYXh3bytYT0s3VlNwanR1SnlVSTVXNy9WVU5PSTc0OXI1NDRiZHVVVzU3M3lLTzdIODk2NGM3akh6dDkvczdsOUEzNmNONXpXT2xrSTdWUW1YemZUVDl1ZTdrcUNFM3VRMGhEOTFiSjRFbDVoZG56cFVZbFZ3SE9WU3had2twNHh6NjNvN0loSUZoU29FOWEzWTk5STd6UXBKU2JKS1ZHTlpFKzNXSmp1dVd3VmtDVkVzOExHTlBFN0hpbWg0SW9jUldoSUp5TnIvbCtlRy82SStNblgzVEdpU2RieUNhNjFMcGs4YWI3ejMvaEkvcXIvelV3VWQ1NHM3YjhoWTVGQzk5YXMycml2cEdmL0pOMjZuV1NWMmdyMkxudDFCa3cyY0VzT2hyMDBLcndVU3pzT0REem1EWWNsK0N0eDBrVzcweHdpTHUwUzdObU9YaXhBbllaQmpFR1E4cmtrRWwya1FXeWgrNTc0VVI2Y081enNFM1d1dTNRYWdodEFmQ2x0Sk94SXlOR3JFaDlEKytUVk1VRUg1Y08zRzNaRFlNcFpZTUJtOGhzRVZGdmZSRE9qRUVFSVJCVUZvSjJ4NTFrTm5tYWZyNng4OERFalh1a1g4dEdGZWFCQVE4aWd5OTUrc1JySjg4MCtxL3ZacklCcHNwenhLcWI3WTVvTkswN3dpMXBjTDVrUjZPOGVJK2JuUjZ1MGg1K2FBb0VPc0JLdEhQeGdSM3RjUEpVVjVZcm9XcklVMmtIcjA2S0syQ0x3a2thSXk1a3FjUmIwSk9TSm52TlRDcVlEQlR4clgvVkVHdjN2T2ZvM28vb0hua1pxUjB3dzJiRHZvdXFsSUM1a0MvWVZ4blJiU3JUTzB6R0huWWJMT294UDJMTWp4anpnNU1IN3dlQWZBU2VkVDVGTVM5WUNiZ2Fzank4Zk1LQUs4dVlEODlIUjQzNUJQWDVSTmwwYmp4QXp0MU9qaVBQMFAyM0REMHc3RmI2K1dQMFBmbjA5NC96NVJvcDRTU2RpRi9NMEpiUGZtWDRhRFlQNkRHSCt2NEFzN1RYQ0YzSjlyQlpJQ1pkUGl4TFVYb1ZIMlJKUkVRMFI1enl4WG8xbjJacWh6aGlYQVh3TlErQ1B1YTQ0dGJDZGlUK3NHQ1ZKZENqSlZXcjIxc2dhTjQwWGozdUdVcmFvT3llRkJPL3AweGgzamFtVzh4S2dSemEySGJIdVhTTCtqcTk5dnpiV3pmUk4xZFdIVDJjdm52RTVLcVZyLzc3RzdMOVFiYm5uOXF3Z1k0TTdyaVhUaVpMempyUjBiMWRudXlZczVKdVZsZlQzYVNXemRQRDlzUURiTDFnbmhkbHpCUE9uSHhWbjJjeXdCdVArRlRGWWlVOHVYaStXTmkxd0NjT2JMM3MxMzdMM0gvam5JTTQ1eURPMmVOdjh5eXRXaldkZnExUSt2blVGZFZMZmpnMjBOSndJTnJ1Ty9haHJkdkkrTE11TFNHelRqNlozbE55eVVyNktNa2JQOHhPcDVFL1drZDAwcytVdVcrOFlkUkpXd2hiMnhKMjhnYWxXL1JJdUNjQVdscXE5MVBFU0JRaEI1Vml5UVNsd0Y2K0haR1ppNWM4bHZBZFdjTE51LzRWQWNCekFzRDlZdEt3VVEvRVVjYkZVYzdGRVVTZExzYk9aV2JvZ2R4U3pRTjlMbitacHhYUUlrZ0J3WjRvK2hpb3dibzdXamZTdDFhR2poNUczeDExVE5WSyt0YkcyaWI2ZUt0YzhxOXY4VHJhMG84NmtPMW5OM1Z2RlVxaDU0Qk10eks5NERMYTBaZU1pSkNSYXNnSUxpVkRQTWtTWTBOekNmMU9GZnFOVWlzR0xYTjdPU2xNVCtreCtTbDlLVkpRU00vZnhvNkh4NzVuMnJSLzJwbWhwVC9NOHJaemJmcGhhVUVKM1RlUDdOajZSendsb21sS05YcVV6VkFxTXY3b0l0cUpxa1drRVBOdTE1aHVrTVl6RFV1MDR1M0MzSUt4NGZoZ0poZGJPRzdYa04rMlhNQnFkYUlTRFRMdlR3eENpMnpRU0NhRFFSeFZOQXJIT3hSZjFiTWZPK3JoeHc3QVM1M0FmallJYnFOY2J6N3VHb2RyZUxhcXVQTUtpMnZDVGEzRFJvOEZSSnQ2d0twamx6aDZFNjJET1c2UERYSzRVVHhEdzh6M2lJWGNYWG5GbGZWNHBmbDFMclQwOWx6bVNiUlZoVnFpUHY5UU9ScnhlK0VabHFIcVhiM2xBQ3dialF3ajdJZk1WSElRNW5Icy9mYUp1ejk4NzRLVjc3MTAzdHJuZHB4LzFQYmx4Ly9oeGVnMW5WUG10STlwREhUTW5IWDd3OXR2ZVBocHVvdCtNbU4yNkxLcDh6ZGZXT1NZSHYzalA3Yyt1K2llYTgzcW5BVjZmKy96MFhIT00vNlFYM1h0aVJQcW5GZmJONWR0WDNOaHpHL3liTDlzNXdmT3l0QlVUUXZ0Y2VTcHl0MW9TeFhSTWNyWFdvazBVYnBWU3JUcGVlWE9jSHdJK3pZaWd1Sm5yNnJEd051QzRqOFNsWFFRVjFJdTlwZ2pFbTgyNzA4MjhCdDFraTVzcjYrZ2tCOVJ3MjAyeFIwb0tta2JNYllUbmpTNGs4SGFwZ0ZIWUVDNGJVaWFwSnRSMGswRG1LU3IzVjJCa3FvR1hkSjlseW0yaGNtaFJDMThQUWpGZXRFc1piNTIwVHNmbm50ZWVpWGprTE03Wms1NW9uWFRwR05PR0RpNnFUUjY5SmhWNjA2YWY4NXA5QXRLVDVrOWJ1b3hFem9ienk5MEhoTVovdUJaRDJ4ZGRmK1dJVU5UbFk3K0V0c3B4d1ZDbStlT3EzTnN5bDVZZXRIeHMxWVdRT0hqSFZzckIwU3FRZHhPdjNrVDcxVXlqV1RuWjRGMEZJK2o4dzRZQzd2bGt3R1RINEptdG1nOFlOcVBBQjJGNlk2NW53blpISUc0S1dEdCtQZ1o2ZUpSVktOaHFZTmdxQXhEazA2MURBMlUwb29GeEhQMTFpSmlLYjUzTS9IU2orbStBZlNuSnZvKy9WeTVpL3lWdGw5M29meGhkOG1sVjhKcitrTTNuVWR1TzhqR2VnbHRZUGY0Yyt4K1c4ckhDdjB3SmhXQllrMStQUm5MYlpPY2FNd1gxczB0TVdEb3JqVkZnUEVMd3BWZWpwd0xFVUFYTDUvazZVUUVrZVR1RURHaENhYlB4Yy8raFoybGxMbTlUbEhMY2duSlhYTUx5Yjcvb29ra3U1UHVZeDczZC9STCtvWHNrUDNkKys2OVBFdjk2WUROZWV1RGI1QjYrc1BQOUNEOTBFbUhrbWNzeEtOenNHS2ZxNXZOYVZyUFRsYy91N0E4V1ZadzZqd3AweEVxenowUkFkM0hGZ1ZiWHd0MDZEN1IrcHJWWit0ckpYZDlPTWxZSCsydlVjLzJPMjlKdXJ0SHlIL0syMzdkOWZHZVhiQmZiOXY1U1BLSE94KzhUK2RUd1pvN3FMNk85cXk2QzJqN2s5NGNHNHpkcXlMaUVNY1M4dWIwVjJTWE1iYk1NcnVHbkFWemoxK1V6UTdxYmRrTDVzNWUyS1BhYnRRUzlyK1hGaTVhcFBjWW5xQ2RMWG1oTXM0cjRoZDJtVWVFbmFuZVljSXJ5cURXY3ZDclh6cXcyenEzTVNmbTJSVTNPWCtPbVhkSkNaUFp3K3Nuelo3Y0ZOQ1Qwd3VrRXNEQVlIZHhWN21NK1B5dGJSNWp0NXZNekttb0laNmFYR2YwcnVZWloweGVjc1NBeHZvaDFVek9PN1hGQisrNGNjT2F1OGpYZDE4N3R2SVQzeEhMRG9iMTNrajFHclZSOGdHcUhBVGRzZUVFQnUzU2pLb01vamZjdW53UXRGUXhhSWtsQm1rUnZjeHhoSjhOVzlTczJwVk40MDQ1WnR5b21zcmlwbHo2RG4xYnJlcCs2T1lKcDUxRnhsNTBjcmhncjd1MnVUdWdZN0JxSjVoem1meEtwQnJBYmV0VGhyWEdjT3Ardnd4NVRCVmlRcjlabWkwY0FwT3BpZkdxUHduVEYwbHh5WW1obTBlL1NJN0hWemQxdk5LWDFNMVM3dWg3V3ZKYm4yckM3K0Zka29GQmU0MzIzMndkU3FWYWFYaGZhMUZuVEI1SVduRXkvanlZekc5ZmxiN20wODlLMFZqditmUzFldHJPUHVlem5EYllUSGpHK0tWR2lEWm5uakZlOWlJUEpsY2FqVldHNDdXYURqS3NOOWU3ZVhOOXpNU0pnY3FzSEd6WU9HemlwV0NmNUZVMm9uMWlyVVdxdjNoZUpmTUdKRk9XdXhBdnlwNzk5L3BkV2RsM0ZIbzU2U0F0SkVvRzBSZnB5L1MvNlBNa3ZPWHVlMisrOGQ3N2JsRTlaTWhMK1ZhVHJlUTUwa2FIRGYzNHBzN3h6VU9QWEZIcVlvZlZ5ZVFrZWpPOWhkNUJyeU1MeVB6djkrNzU1YWYzOTYzcHJ5YlNraFExdzAwZ0YrUDhnajZIV0huVXFCNW1abDY4SHVReW9JOGlZaWlMZ3ZhZm9KWHptQnIxeFBGeU01TkxmcWdKNVdLclozS3BiWS83UTB3dVpxbTRwRW1YU3o5MXhxUnZ5ZlJYZnJ5UERINHB6MjdLS25xT0RNUlEvZmdKclVNbXJpaHo5Y2VNZFViM3RuSExld2hGNG53Ymwycjd0WDNJRFhtU2xLaUVNaXlUSXRtWVhlVUtKd3Z4bFU0SjZXUHo5M0dlWCtoWGhtYVBNaC93UTFrZEhnNDE3V0x2SEo0QUFuVlZ1cm9rWDFhWllNeFRyTUdRTG9OS0hycFNRVU0wU0Y5V2dKYjQrZE1LbDdNU25xbkxTUW1UMVBCQmtkRXU0aUpsN0s3OXBuelJza0w2Yi9vK0NWKzh3VHV5b1c2RWoxanBnY3E1YzBQMFo2WVBVYktnb3IycGRsZ0Z2WUgramI1Q3I2dGF2RGhJVGlmUkp6OEpWaGNWVlk4bDU1RTFuZVBHOFJyeUc5Ui9xS3Zadk91a2VWTE1HVTRXS0lpUnk0eDhEVi9wSGZkcHM0WmFxUVpqMXVac1B1c0NKM3VYN2NrcjVueStYVGFmaExQVzRIY3Fhdm1zbTkxby8vbmMzbHpaekxsQXErUktwNWcwcjR6bGowMHpQbjNIdmVEazNEZisvYzg5MWxITnJVZFlYLytFVkYvdmJtMnQ2UWdjTldIaUdHZkhvT2dJOTFXeTkwUGlMWmswcVpUdWYvOEQrblZGcEcxZ3RKTDQzcUsvRHFxc0xta3FlbUQxT2JjV05yUTBOZzhWL08vbTF5MmwwZ0JwckhTczlJNlVDTU01WDhQeklyNElUNFlFZVRLa01CSWJGbzVGb3NuQkhMVjMxT0JobHJwNEc5enJzOUp6Skd3REpNZHlaT0d4enZnMDltNFN2a3RNbThTTU0ybmFNY3duR2hlSlRlS0ZabFhNeWpxT2ZZOUFDc1dtaE9IVUhPdUtPODNzK3pSM29tMlVDWjVNY2lVOTlTTkdJcE5Wd1AySXJ5UllNMmpJVUpTenpRbUhqTmxUZ3FpZ2lpdHVnbDZpWWU3RXVFbkh3SDg2MkJXYjBEdkw0Z1l6QTR3TmQ3OUpGaVo4amo3Y1FieE04M2prMks4bi9NMHRzRHFOTXFaaWp0emNQaFZUTWZmZWVGeDh6TGpZckp2dndWVE1sUFpySm9wVXpDbGJqeDUvUDAvRnpCNTgydnkyUmN2UDY4eHhianQvWGppdnZ0cWUzM2xFNTlFUG5qTmdTTEEyeUZNMUhRMllxdm1TMG9VbnpGbEExTTh4VmRQUW9hZHFqcGcwdHBOY3JKMFhucjJrdWJLMjR2SG1VTmFBZ1pPaWJkUEh6YnpRUERtN3JjanRjZ1FNZkluVFRkK3plM3k0TkZuYXkzdTVZRkZ6VktnbzRIWGZSVkZJNWNmOEVlWmdKU2R3dk9pQndNaVZiT0dyUGFSbG9BVUpDMGhzU2pvVExOdnV5ZUY4dFljN3diOFNhNStZTkJaV2UxSW5XMjNtckkzbEtZWlN0bFdtc3UvRGEvR0FDT1hBbWsxeWRabWFobWp3Y3F4N1I3NnpjbEFIT3NKZTF5TnVmMUdRblgrNDBOWWN2RTJjK2FWaW9iVUNkc0FPbk1DTzJoRmpnZkxZRlJ1RkMrMDJXZ0RRd2NMajFJbHJqSjBMVHNEcFlHZUpEQXNzSDNhQlozejQyVlZuVFI0OExCaGJmc3JsNS96aGlsT1h4YXFHZEV3KzY4cjllMy82NmQ2elZ0ei93d0VTTDIyYmUzVGJ3dVZyTzdNZGJFbWIvUFUxdGtEbnFNNmpIenE3YVNnc2FUSEpJczcyRjR1eTZKKzJ4dGF0aXo5QVJtY1h2dGpPVHEzdm1aL3d6NFVMU2I2NnMybkVuSTd5aXJxS3g2S2g3TWpBSXlOdDA4WWZ1OEUwMlQ2d1dLeWx6UGVyNldNcHd0WXkvdHV6bUxHaDRWaDdOTm5NMTdYWkdSK3U3SSszZFFEWDlJakRwRGRIaXZUbURyUFNGRzBleXRjbGFTcHJHRFFFWHVlN2s2VVZ0UzN0eGxiVTg1dng0VHpsR1c4ZXloWW8ydm8vekhSQ3BNd2NEQVg1VitabWk5OC9jUW9KVFowaDhwNTliN1lLeFQrcEpid3B6TDZhbWpPMjFyOE9qQ0VyNlBWSGlTeG9yNjFWTkhYcVBmUFkvMER1bUEvVmpwY0ttVFc0V2tvVWd0eno5SXhvYmpRSzhNWEJxS0JQamhXemJjRUVYRllKQXE2REVpZEVQTEJ4ZXdHb3B1dngybUQ2Yk1rdnFLd0dRZWE2dXZJQ3lLSExGcllRTXFQT2ZJRFFLYTVtNGlzcVRlVkloeExJa1JZckdWbFNUNGFZSUdjYXpOSk1ybHMza1BCT2s4ZnRWcTBuSDBjcS92dzYvWGJ0UnZyWE9zVjdaRXZqTlkzTjRjM2habVpGM24zYTh2d291WVRNNis3eWRRd2VtTHVSbkVWSzZlMDA3ejNtOTIzV0xGT24zajJYL1E5eTZMUUJjYWo5a0UzMTZqYWsxd0Y2NXdXOWMyQTF0TVBOWHFiUWdyeUlGcFNub3dXQnB1WHlqbks4QW5MaDZGZHREclNSekZCdEpXVWZFandJV3hRRUlQWHU5K2RNajAxNzRtL2swclp0blhRUDNVWnY0RWpVa0tUN2VTOE51NTNkTldRWFdjYnI3V2dEMWd0NnBSTWtVU2JJTm9nN25NeFJvQ2d3a1lOSjBSeW50UzZ0NXdpT09iY0lhaUM2bEp1TjE1S2o0SGh6M0p4bHhlS0tTNmIydmdvRkRVV3ZrdlVpd1h2bXJ6NTl6ZkpWNTlMMy8vMERydzJjK083UU8rNjg5dTVnZDRRODV5WXVHT3Y4WDM5Umg2c3ZTeDdtZzNBVUFnMlRXam9Ra1FhZGFpWXI1MWpTUEpYc3k2OW81a3I4Q25ubWp5U3VKK20zbzBqT1EyYy9SRnhqNmZkUGtld2o2RGZiMW15VExXZmVRc1p0V2JXRjFJNmhyMjladVlVK2VpdjdaL2RZOXJGRTJxYU9WSzVqdm9KVHFwZGk5bkJTNWtSWmRoa3JOS0N6UXJiRDBTNXJWa3o5aVhZSlQzTzBySlhYbS9HNmtXMExTTkk2ZTBGeks1Mm9OVGUwTnFsUExKMjF1RzFVVGRNUlBGZjZHZklCdk1EVzRtSGtQOGd5NnAyVVNKZVRTQlptYTBhUkhNOFV3ZFhJMWhrTGRKZmRQZkNaKzlEZFZCcGpMdVp4S3M2NHgvMnpCblZjSnZmUFQrU2FuMjFqUDdhejUxMnFZdkxVZFdud2I4emo3SEo3WEI2bW9Zb3AxVFRKbGkzQkhrUGZaSmRIMWR6WU5mbUlSMUhaUHNJM0tXdzRUMHMwZ2pjSEtTSkJmbTJZZ3A5bGQ2NWR2ckR0cEFXREg3TFYxQmVPR2JOMnUzckw0OEc2aXVqUzQ4TURCL2lLbWlWQ0hsRXZrdDh6bVNVWDg4SmlEcVoySW5LSmJRMlFIb09iMHc2eFk4bnVzTmJwRGQ0cDdvVWNHU28ydmN4UmZPU1k4VWQwQm1zclJvUlhiOWRPR3ordExSb0lPSjN1a2piN1pOTUZUTDRreWY3V3UvcmZzb2FUdHRUZllwTGtiQStKYk9oams3S2hwMS9xK2JlTUs1QWsrVjNXT0NKWUY5UnVqWXFMeVRhd3hPMTBzb3ZKSW9Yb1A4d25hSjNZdTF3anRVbWptS1V4UjFyTWRsMmlCTXlMNlZFZ1Y0T3pjWFlrMW94Y2gvQ0dIUWxIUlpNdS9tWWNoSFJqQzZPQ3BDSTJQOExzUVd5S21jdDBUaktkRW9sRTJIV1ZITVQxY2NRZytObUlnV3prUTVoK0xPRzF2ZHdTeWVhRmZJV1JaQUYvVUlNbzRHYUQ1UUljV1lBUURFYVN1ZnhCZVFRUStKZzFFeHNZU2JieFo2TWlzVFpuZkFCN05qU1NiT0xQaGtSaVRjNzRhUFpzU2lRNW1UK2JFNGxOZHNibnNrOWZ6QjhzZHNZbnN0K1lGVWxPNEErT2pjUW1PT09uc3Q4NGhXdndVcWh0Tjd4RUV5RHd1dkxRaEkwUGFHT1BHd2F4eDR2bnNzZEhUWjg5RGg1UG1NZ2V6MStJMEJJTmtDN0lHVDBCbmxjcDdFMWgrWlJqdVVmQlBRZWhsWm52bEl4M0pQTm5yZjMvS1BNajAzOHhwTTJaTjJPeGFhTFdQbnhDV0p1YjhXNWN4anZ5dG5iaXZCbEx0QW5xb0JHZFRlbzQrNTltbm00U2I4ajc4S3RMdElscU83d2RuL0Z1c2UzSm1mZ3A3STFHa3RQbnpaMVJWMU1acHBYVDU4K2RDYStVQjZlZE5IZG1iVTFsNDRGSjArYlBuVkZiRzJyUWRqMCs1MWg0Y1dCYzcxK2pBeDZiTjcyMnRxb1I5WGF6dVVpN1JESkxPZXdjS3BJcXBRYXBWUm9xclpOaWJlRmtPMWRFRW9scHBidGRzU0dHYWxhR0NmaENlYnVUK1liMkZNT3YrS0xKQ3I3QXc2RWNEOUovbFlpbFdsVEdnUTBDa0ZUUU9Ec2JNMkdsd2V4eHV6czJFQnpqSFc1UGJxaU9KeFU4TFd5WHN4dlAwOXJtTnpPcHR5RXBBMmx0aS9vaDJ6V1V0RVZONXFEV3hsNzQyUksxK1lzSlhKQ2VsallJSkZXRlhsdVRQV3pIc2dmT21DMWZjNGR6Mk1weHM1MlR5UE5SNXdhN2EyVDViTS9vb3RrUjF3WnluenhzeDdDUkQ1elJPdHRaT1QxM1dQRTV0MlFmOGRUUTErVEE4ZXluTnVjUjNXOHNtRHJiTVcydytzWElKMCtZTFYvNHk4dXZuWk16OUpFSjJxT2puaHJ5ajNOV09pcW41bzFZTVBYZ1o3UGxrWSsxand3L1RsN1lZSGVQTGo0K2dqbFp1c2owaXNEL0xwZXVFZFdZMmRGRXVZR0ZaajRFQ25qUWdFL05SZmhVcndGbGtDUGdVd3V0T2FKOXBDQ01BT0VWQWlBOFlmS1VnZXRYNElxVkFEUjRsem5MNWViZzFyenN3K2FxOEdkQ3FHSjFRVzhZMVRTRVdESmtLMzI4UzBkVFZVM1RGcDh3eDBiTTdzL2UrZkJOZForT3AzcGdZL2NTY2wxUFROV2ZMNEg4SzEydmRXdi9ZdWR4S1pQSTlVSWVXZEZFbWRHL2FZb0NKUzduMlV6NEVFRERGNEFDTFk2S25vSjU4QURNZzV0TGhGa3ZuZ3paUUtWNEFCSVorUUkwM1FNR2krWXExWHU4T2NoRzNPNXNOMFJpc1RvTmtmRHFWaTZSSG5nUDdON1JDMTFKNFdYMHl3c00zQWZMdEVYelRyUVFjKzZuNzl6NDlEejFQS1AwbGZkRzZ2QVBwM1llTjczcnpqRlgvN0lSL1prR2dSc0c5WGxMMHVyendIMkJxanlGVitVbGlRUXZzV0xQQkJWNy93YzFlcDcrYS9RYUxpQlZwSkIrSkFESHNFZ1BNY2VVTDcvWnVQR2JhNkZJVC9teVc5TngybVNzNFQ0VjZ3d0QwdUswT2oxUlo1Z3E1SWI2UE1Mcjg3RFU4SDlkb21kTW8xZG5LQlp3bjBKdnhyNUhhaFkxZW1ycms2Ky8vaVNkRGtWNmF1dkJ6YngyWHNjZGhlNkpPZW00b3dWTStEbE94QjNOU1hGR09MQVdEYXFWL0FKM0ZGb20vS0wzVzNQRmJHQVpHN0JYVGxmY1lvZjltSUZLeW54dGM4aFVSd0lrMmhacTg2ZWprODZhT1dYajRzbW5yNzNNMTdaNVVraGdsSjZ6cytPc1JWdHlBYWhVbnJSd1dYUWFncFdtY0JEOFVqVlUzU0huWklHQmc0QmRBR0U5VmdsWXkza1JZSmNzRjRFN0NGZjZBUU5COFdCMVZia3JvVHJNU0pjQVRXWlMzQVhUQVBobGRwd2tzdmd2RVhlWG90b3ErVW10azJpNlhVNmNVUW9Xb1lQb0V4UFlDTTdvelNjOCtjWmx4MTUvU21RUXgwZHd1dWJlZnFRdkJaSncxRkdBa2tEMzNyaHkyUWFIZ1pRZ3IxNTVZdWVwaUpiQWNXZEhtYTdoR0FVcC9IY1QxRk9hOURyUUh2aXpNck04TkY1ODFRT0NWcjVlK3JWN2s3YVlWSFYvQ3FEd0hFL3FObTFjMnVmTEFxZ2lJZVBueSttZmIwNy8vRkN2ejc5UkprU2poV29WS2FjYWdFeHhqSVVBWXNGTkZYMDZtSU13TVUyVFNKYlk1cElKOHJrNjBTemJIM2FFSDB2WXMzUU1Ldll2YzBBU1dYYmtEWkFFOHl4dWlCU2t1NnZoQW1WaDk1T0FHRVgzeUszZnlxTy9vWC84dHZ0bHVWWFNleStVcTdEWDFCZ0w0YnowNldOUmU0N0YvUHZHNHVWalVTOVFMRFNmZE5EbjZmdmt5Zy9JRTEvKy9RTzZnbHlKV0tYNVdoUzVzZVprWVBvektUakNrSjRCUXhiT2pRTEZhTjh0NXREMnhWaHBVZ3p0ZE1VYzl3L2FWVXFGK1pFd085eWMzeEM2d1R3R2lRS3o0bFFJT21QZlZ5b0VZM1k5RFBJNjVjckhTUG1tRGYvYXRHREQySFBPMjNEem5pOGlZd0VSZjczOVRycjMyY2ZwSnpmbDVoR2w0ZG43bjNncWkrWmdYWDhRTVhhS3BBVVpuWCthTWY1OFB2NzhGSFJoRWJaOEpZcHcvRVV3L3FMVStLRXR0Z2gySHZQSEFMbVF6Y09ibW9kYm40ZTNGVE1uSEl4RTRFVTV5OWcwYmdSUmp4bDcvYi9Xbi9uRzVSY3ZybHNSWHJLS3ZsNWRwMVo5K1pIOXd2L2M4K0NQNXczNDJWZDB5OVdrM0VUdjRMV2tkSkY1RzFzRHIrU0Q2QURXelRrQXJjZG5uSVljZ3NzZmpubDJaM1lKNVlpekdmdU9NVHhnczhOQmtRMEZUQnhvWW9kcXRtZTVjbnNqZENGVUliN3BSUWN3a2pUUWorN2dqQURhdnpJNUFXZ2RXaG82THdDTWY3M3BGN1lHTVA2NXZjZFBEak4rOEoxZy8rcFRpRnRzT0FHMjg5b1BNNFZvMmhSNklvMlp1K25CU3puV21MWTRFMjJNYmdQTHdFQWNReDVZZHBaemJvTjI2VHJPYnBCc0VrVGRndUFBRFBNYVR0U2RUblV3S0J5cjM1MXM1cnpjMWtpaXZoblVxcjdRaXZIT1BMNCtCZzFDdklNOWFLNkhJTFN6b2dsTlEyY05XN1pRZlRNRTNRcWJvQUlOV3NlTFhJSU93WTEwQ0wrWkNNRWp0bFFvS3JvclE0ZW5Sbmg4WUV0WlhlY1JEMDRZVnJaKzRkZ2pEOFdVOE10ZjNGWFZrVk9IdFkrZDJEQnZ0UmRsMTBrYkJGNWJoM1E3ai9JbkkxeDJPbWhickQyY3JPT3lTNGR2R3h5T05lNU90bkxadGFLZjNDK1lHM09sNDBPWThGb2JtYmc4K1JFUVZ4cTJXNmlPUGE1cGJFVnE4d2lFOGhEaHpTVVEzdHlJOFBZN3NOMTZ5L0V3YUc5VE1vVjRTUEEzK211bUZCR3pXTHVSblFFNXpCS2FsdUxkZGhnZWk4b3BLRVFHV0k0STNBR0RoY0lHaUdxcXljejd5SkNUQ0Exc3hXekpOZ3pzOUcxdmNDU1E0MGdiL2VoaGFsSEc2RVFKcVMzTzdaejE2cmRzZjhQWVp2WWNHOGtjbXpsdGJEckFqRDQ4ZHF2ZzRPSm1yYjNmNGVsYk90V0RsLzhWUFhnQm5TUWYwUHZ2VXRzM3hRK1FoWGpYbzFLK0RRck5hblQvWlZTOGd6bnM0UDZ6T2FNajBLVVh5ZzRqcnFqWEE5SlN2RUdYR2JvMHpwVFgvb2VNcFlYa001cjRmdTFaVEZRYjdwSEowWEhTMW4zVHdWL0l4ZjlOTmsyalRoMS83Q3JFeUJtVnlhQWVzMFIxYkp3VUJBWW5Qd1BvUEF3UFJUZ2ljWS94dExIaHRNRndRbXc0SWRlTkpPZUV5N2F6TXhvNkZGLysyMlhIZzJoV2t2bzE3MEYzWXZmOVpQSUtnVUVIL3NFL2tRK0MzU3dlQ1N2VGVJN0d6cHdEeWRQRHVmSGlDWjNoM0hnTXI4Q0RYb0ZING1TazdFYjBNSld6Wmp2VCt2eWpiSGh0dkozU2pJWUhxVnEvL2t4eU5obkRCVWV2UFpmdVVRNTh1MjdkdC9USGU4aGJJRHA1L0xIVXFSd3c3Q0wxRWViUCtLQ3ZIbXQvbkZIZVR0MVhZeXE3VUx3NDNGemRpY25GTkVBdUROZUwxY0JlR0M2Y3dybFE2Z09Yb3hUUHhwZnVESGdDbHptYVBuRFJnK3BRMXBJYXR1cXp5RTQyK0wvL1FXOUVwYzkrY3ljNWdrYVpxTGZQcHp1Z0VaWDNxbXdXZTNpTTZBTzJwTzloNkpzQ004VEplWXc0bm5jMkduUFpNRXdYU2hXU0VvclpobElGNEoyMFlTbnljU3ZKS2wwTFFaanZ4QURBZTBPNktKSFJRUi9QT0thSFdjektIR04wUFFwRWVMNXZ3Y1JFKzlLdU44Z203RFlkWDV5VEtFcDJHQStFKzhWNERIUlBSWjVMYm1CU09wNjhSUDlLSjlGdmJsU09mRHU5UlZiZ3hVRThab2pBWXo4MnRTT2NhWEpKS2prcEdnK1g0ZXJKRWRHWUltZzh3T0szMmZtaGh5anNPYjNCOFkzL0M0SVA4S2VCNUVNNXlHaytSS0FFcUQ3NDJhYXRFcGhPeC9jY0c4a2NtNW9hbTdubjJNejYyUFJENzdEREUzaUN4RXdQMEhmcDZjb2sza0lpb2hhQUxDaDZmRXd6MEdmSkFmUWtIWk1tQjdNeW9yUEFBcDBGV2Rqb282UllZRGxjUEVTazdYeU1GdXYraEFVZEJZdVowOEttM0NWdnVzems0K25MNlJMNzRjQWxYRnk4SjBkN0J2MldQc1lqcXZnQkFFTWZUd3FCSTl1c2o4Zkd4OE1XTVdGRlpiUDJPeDRVa253bTNRNndpN3FJM2o3WUplU0Qvb3VsbnNtblZPOFFpaFVLTHBRU1pUKzBOSHVZY0FJYUxtQkFNZENVUzVsd1NwMFlQQ2prY2hKMHZsWkIydzUwdmdrTnp6WiswTVZjN1p6WVZ4R0wyYThqd3dsV0toYmZGaU9leThHVldUZnhuUFBPdmZQbFBXMno2UjVheldSNmxlTXV1dTg1OEdZOEFlYk52SHpIRTAvbFVwL1l0K2pUbU01ak1pNkcra2VjVTc3QWJDeFNPYUV5ekVsSnpVbTRaVXpBeFJ3RElaL0xPcC9IYml6Q0xZTitmQVQwQWNoVllLUm5NK1BBUG5FRkVJb3MrbVhUeTdNQmEwbUFRVDR3OGVxUHoxdnh4bFVYbjE2M29uSEo2bXV1MXRqU2JHRUwwNlplOU9NOUQzNi9qbnMzVjExTGI4YnRqN1VETVcyN3RsNnFrWnFsalFMUk40ZXRUaEJzNG1LZFFzeHEycC93d1NRam9ETXQ2VGxRYUtDclpWT3FkV0x4WDRETnB4VWVlYUE2d0tya09MR3Z1Y21WOEZWaTBVN0FuU2dzRHZJc2FZaXRZMkZwSlR5T3VKSjJ5Uk9BT0hmYzZ0T1poMFZwUUZXd2xGZHRjR3dtbm9ieWlSN0dFQUN0OEpvd2dFYzNMU2N0cExIbDh2b0pNenJwQzA5dDlac0dqLy96SS9FWFpwOWVQMnpjaUk2bDkxdzI3M0w2Tm4xWUdkQlNNV2pzb3VZTytWNnlrSnlaNS9xb2dCYS84N1U2N3ROVnI3ejV5ZDh1K1h5UncvdHgzdXhTc29LVW5ubGZZMHZzeFBkWFlpM1lrK29Ueko2dWxhSnN2eVdxMFo5aS9rY0Z5S3RFVGNGVEp2MlJhdkJEL0NBeERuQWt5UEdnS2FhT3Q4Z3dQNnZPR1ErekIvbThHUWJRamVweVhlNmtZblc0c0FRZzdJcjdxM2pmZUZGSkJjck5VYzNrVmxSV0plUW1aZVhtYzduNVUzSXorajI5aHhKY3VWU1pLMEpSTTRqNlpmV0t4dUZUVzA2YmY5cXBlZmJxZ2x0djNiUjFjbWRCcUgzd3FLT3ZXRDE3M1lmME8vbnhjZk5xNjZiSkRtSWlsVjczMjNtM1ByenBkblhDbXZHM1B4RGJzandXTVRsZjhoNVRTa0wvdFhyS2tJMnRvMEMvbU8vR09ZTnFnTWtjVUR5VHBkei8wRXNCb0l3dXdPdUpCSVZRYlhwUlFDR1RUZ1Y2SVZCUUhDK0VLOWhmQWowdnNRcFgwdWJJVlV2UlZjc053QThLUVVSeGMranc5UUljb1lmMGNpWDZvUjhpajJUNkVIM1FFWFZmM2R2L2d0b0NqbUZhYmN5L1JQaXVRbE5pVlhxMlF3OUlpcTNGVG90a2tNOGNBcElGZGtqdytZbzUwYldyeTVxdGxPRE04NnF3c2phV3l6WlpBV3l0dUxXRXlVSXlJY0dyNGpvRUNHcnY2ZmNGaTBxRzlwaDdiNWpVbmw0VDh2ZlNSY2pOWklkYTZReGFwaXdFT1FTR0RadG1JQnhxenJqRmpnZ09DYk1GUFV2RklHVFUwVk1ObGlhMEhKQ3A2ZUNGWURNQVd4UEdFWmsvWk1iZTN5T2tUSmhXOFRmTmZmeE4wWmw4NkQrTHdLMUVwUWM1ZUd2M3hXQUxLRWVLK3Z5bjJEd3RnSEJpaHRzVythRVU1bEJZQVFNZFl3czJoSFJqQ3lYRDBjNWZRQTI0SGpFWlJrclpmVHFFUnVtNzdCWjZUaDU4TU5iOVQ5bWo0OFBPUmgrdlNTQ0NXQUVSQkM5dnpybUpyY0lBcEI4M29mc0dkaXF1T3RTWWx4QmVMSXgvNWY1QWNaYTl2R3dyKzB2ejZidnNhaWdiZlVuN3R1UElCd2YyMEFieTMwYS9BY3pIcWJOLzZ2TkpadWZZcFd6RWc4MVdPTk9VQzh4VDZLY0NDMVdMSkd4b3hOZ3N6TVlYeG1xMmxiZDgyK3o2NUhNeUppL2lvR1V0WlMwcElaQXcyM1B2MG4rUXNDNk0wSSsvc3FIOVdKUW1qMXhBQXZSd3F4QVNLN0hzaUNFZVp4Z2RKdWR1YUlNQms5QWVTVGd3aWVMSWhpUUtGaWM1M2R4ZHduNXFYWFNlUGtTSFhnZ2JZRm1tQUVrdS9aS044a3VTbXlISVBULy92RWZFRHJXMXdyWWVsdkorblhya0VQRk1YTHA5YndncGJqSHBzYlV1MVdMTk1TSnJWaU5FQUhMTDVMeHFJRDc2MFYxQWU2VzhtU0srb2lQUW5rYnlLMFd5c2IzeGpMQ25YVHBYcWpFaWx4NFF4R0c1WVZoSkc3ZVhQWWNhbVFESkpSNk1EdGhKV1RRREt2ZmRIK2pCUCs3ZHExaHRLYmhjK2dqYTBRaVp5ODhKMHhjb3A5TTVVemt3ZWlkeWNKZm1aRm1OdExCeGZEQWZMVWV3dXVVWWlNdmk5OFd1Tm5IOFlZQ0Z5Ykx6NkRIMzREU1JmOHJjM1B4YzBlaTU1RmNTZ3JQbHdBNDhXODVsaHQvR0h1ZUw5aW5LY0xZK1Z0NWtSZ1I0aUg3Y2lER2FEemRHc3o1R3ZiL2YxZXZrNGFkUEhmMk1uTTkyQnp1QkRuYmdDWFNsampFTE1OSk0zeFl3ZllOZWRyK1VCeDE3Z2xnTVFBWk5DblJwY0Y0eFJKVU9wQk5xdVF4ZU1VU1paZUxLRVZBdExnV2g3M3BUakJsZ3dDVEZNOGFQWk9RYTAwclQyY2FFVndlTVk5M25zWEd1WkRJOERmR3UvY0N1SUVDS29ZUk5VdzIyS3RHWDV6SUFpaEZ3MW01RXBBUDY4SElCcmpnM3ZSbXZqMUVhbU1YOEFFZmNZdlhpTk9SaTRkb0JlakcxcHZHMElYcERLa3FRRlUzNlRaaXI5VE1WOVdQbXk1OExlTjlHajZIUldNaUZtNHVOaFpDTWh4Q1NCY05jRUZheVJ5Qll5SUhtRllUZWt1SW1QMEM0dVRuYWdUV3R0ekRxRWpOaU4walFaUmIwYmd2T20zWVYwTHV0T2UyOHFpcWQ0TzIwT1RJWlNGL0xHc0JaM3VyODlHK2tYTjZaamc4ZGtNNlYwaUtFTUNjTjVzUVdBY3pWaEY4enBxWGh0RFF6VjFpM3VyOUgyK1NoWm1kT214MllLWm9iWVRiRXJEcElTOVJyek1vYmJERUphR24zcXM1akFWdjZwR0dyOHBvTWRPbnZQbmFFT0w1MHMvdmp2NnVKZE81Umo0NjF6YlJkTUp3N2RJYnptQnQwWGtseDZhV0NqWGFSN0VVd053K2FpY0xKNVFGbndQTENBRFJFR0svNDY0eG4zNkY3WmkrZGNQc3lkaVY5T3FEeXp3OTNQME0rUC9tVWt1cnV6WkxPNjZCZWdsaHo0OVBHZzEweVBFcGhTb0VWcDhEbGNCZ2NyRGh1ZC9GaHhLSDQwUEJtVThNQkY1YTUzU2R0bTdMOUtmcmV1a3Z2WXZmT3JOYTYrTDEwSmJsNjNTamFZdUQxM2NSOHVqSm1jMTdOMGVQWUt1eFBaSUVKVnNYOFUwdEpRVlkyUk84Z1BJR2QvR2gzUWhsY0tTK0RLK1pIZ3NzS1A0WlJRc1dJUTJUR1RSSmU0TEZpRnh0aVBBZ0l3Rm01U0JmaWNJbDJ0OXdDRGpOWkFxZ2Q4U29MbU9NeUJxbWEyNkxRVHQ1Qk9Mc1lCNk9wYUhPWlZNVGNLYStxTEVPcFJ6Nnd1SThMQmNsazRpZWRwUE9nTGZ2RnJ2V2s0N1JWOUp1NzZXdjB1c0tPVzI2Vjc1ZDNQYlRqaGo4cGs1Wk9kWTRxbWtLeVNRMjlsRjQ5NnRHblpvNmdQNDBkUmthUnFnMW4zSC96ZzdwY3RBSm1peGRMbFZCcGt5L3gvRWZDRG1aaVVOMmZOQmZsMjVsY0hOR2ttWWN5U3lJQ2JSUHkySkFIMFRBdUFTY1NjRDZWSU9jVHVPODVBbjVURTZJcEF0SEVuTzVZWVh1czFKV3dlNkJzTzVhanR6WjY4amtpSy9zMUg1T2dPVU04SnBBT29paG53TmVXVjRSS1JRdHM2Tm04NDV5bHhQTHFKMFRxSHFwZHRlN2srT3pPNUxvZjZRZHUraGY1UlBLUXZIemVySlh5SGNlTmFJNTB2dm8rUjZpdHFkMWJXZlhUSjA4dlBHc3h0MDFRUnlxa091a3VnVEJZSEFYYXRVUUJ4bVlMaWlCM0RScFRBeHBUWHBTbU1aVTZ4V2lheHBTbE5LWVNOUWJqTjB4SWhVNUVvWFBvL1ZBbTFPeDRFUlFxdSt1UVRZS3BUMDE3dXRxVW85clUvQWExeWNIWWE5VnYwWndGZjExTlAvbWNmaDQ0dk9ZTTZiRFExZVRLS3RKT3BEVDlZZmRXQWVJNGhjRDN0d3RvWTNZaUpqMktaQUY5Q2FjcFR4bVRVblVQNVNsSktVOFpLbzhlRWNybnhTZWdSeldBM2FlaGxJQUVyUmhMWkVMdHNYeFh3bU92Yk5mMUorNHZSRXhvMEtES3cydVFDZVRVU0E2cFE2dTMwbC8rK0VMT0lYVm9zSjF1SnVkVWZma25WQ1E5eDBQZVlPZXd3azZjVkowQ2lhbjZQWWhmbWhGRFJGWlFvSWprY1hCenJibUpuWmtsMHNVWjdGWjZhcjMvNHJmU2NNeTlXeTl6OCtqWkdzR0JCWG11QUJjdXB6U0I3SFVKWWM1eERqUVRRTVl4bmg5d3ViRXE2WEJVV1o3TStyK2VHZm12NmZNOEhYOVpEL0REek9ROHB6aUhyM1JlZFpuemUyRU5ZRThaa1AvdnlxQmY4ckFqZThxZ0h6S3hGT3VUaUJWckp5Tld6OUkwSFdLdUNET2trYW16a0plS0ZHcjdkZnFSRkN3UHpERkx6REZRQXBXTFppZjBXMEtuTmR5bVBpZVd1Y1FrUkhBdWRNZXpBaHg1VEw5aGdhbTUzOW9YVW5VWnN4L0hkcityUGtWS3I5anc5ZVlGRzhhc1dYdlJEYnYzajEzSVRJSDV6NU8zdXMrNGxuNzdhRm9Kek9NNzgyaStpQmVyajJFTnpOeTBHcGlZR2hYeDcvUzZGemFab2xTa0c0cGRmRVd3SnFac1FFWFRNOGNlQTYrVEdWTllkR2IxQmRMU3RDUWk5UXdRb3hFRDRmb3RaQ3dkOWpaUlZyeXV4NGl2MzlSMFpoR3pJdXJKNjdTU2Z2NjlDQkxmZXVXVjErWGE2ZU9vbnc1MlY3UUp2K0krS1FYN2l5WWs0RUFtTExCWlhRcDNMQnpZMktTelZRM2I5Tk9WMkk1aGFjeUptWFpwY1pmalo0QUJTTkZWR1owWG1YUlZvdTBpNFRhWm9la2l5UzREZkNXQUFtd09VWUVuK0RLbDlwakxsU0JZWVNQb0ZJWVNkNXRlczFwbVp2b1lLcTkwdEEySWREVFBLRllXaTlMZFBmU1BqbzVaRDExenRIYUMvSTNuK0Yva2RxcDdmT3RvQVYxOUI4UmcrTm0vU05UUlRCQnNSQ0NEYkowSWxJUDNPUVgvUU01dWczRUFPaFRqV1p3c0FjcVFKZkErOFdUdlFTTEd4OGxSajNVbU1WRlBxL09KcWZmcFdNZTY0NGRZeHg3SjJFTmx1RTdIOWRoRDlqQ3NUbEx4cFJKNTNNdnk4ejNrNTVZOFQrVHg5aXR3UmV3NGFwZkJiWTZ3QlhxeURMZEt5TVYxakovcWtOSmIrOFZOTzlhT1BXL1Nxb3U3OS9BVTFTLzcyYlZ5WlQxUkFybVAza1AyUXJLSzc0dGw2QVBPVDk4WGJLeTJNSFF1SmhXdjFJTjN4TWUzaUE5ekRqb1hHRWpZWnhSamVseHhHOVl2TzIzOWpCa1J6WFUvVnFUNURydzdidG1RaFl0UFdhZ1k5R0gvL29MKzVDLyt1ZTNLaThpbHlDTUdlZElUUkN4bjV2OHFUNHB4SHFnOUZ3bnZ2dktRWEJWU2FWS2hxbjBtU25tZTlBb1IxNW41djhxVC9wNng2VGxTWFVQN3lwSVNpRW1nSCsyWDVoMHFJcEZ3VzdHVUljZHE5QVQyQ2s1MDVXUzVMQUlSTVl5V0VpaXFRNEhRbmJlOVY1QWlpQXc5UGJqUWY2RC8vS0lQTm5TNlNONU1Db0VSSGYxa3VoNzlaQjlreEh0R0ovenA3cS9UaUU1MFpkdWRscm8wa3NYMHdqa1lJc0EwOWhPb3dKRzJaSElyL1ljZTJOT2JYUWtvVGw4RGdpV2VmNmFMekk4ejJlWXhqLzVLM1c0QVRMK0FVU3NxYTFEYmw2OFRDa0svUklBalJHY0pzT1FDZmt3L3MrZXJJanltUGV5WXp0M0ZQT2FmdFppOFM0RkRDMEJhWk1VQWFZbG5BVStnNXNZck5HR3p1OXIxaXFHRTJlTFVpV0RTT3loYVBVRjJMd1hkWHREb1RXU2NpY3htMzdoU2Y2WFlMZlJtWmpqRUxXN3RURzN4Z1QxcWxkRHVUZUUxeEhSZ2x6cVNkaTN0WGlPSnV1NzFKdUNpTFdRM2FrTE0yZWxqY3k0eXRCMG9GUG1sS3R3UEY2ZUF5ZUtYYWlhRm9wdFB0eWVGWXE2enk1UHI3blVuc1dlY1F0SHRTVkVvZXRJb0ZGMkZna0lScXRzY1JpdEZJZ3ZwTkh2UUthSndVcFNLWlJtY2lxVHdjdnJsK25SbXhlZlR1UlhGK2QrTFgvRi9ib3R6ZkoraHpCWTNzMXV1QUxMQkJpY2h4bFI4Umt6RkUwNW1jV3MwQ3l1UXNxQXIwY0l4d0N5N1JaVkZsOWtLMUZtU0Zia1V6RHdXQ3hSV3pQbnBVcDBPOWpORjlBaFlMV0lQeHh5dXBFdzhQaURlQU84WksrWGdkczgzOEZpaHNUbkRFQzJUQVpuMWM3S0FmRW1mUFptYVRsN1V3d0JsdnQzQ0s0TG1Vb0NMSlJQb0RzUDRQdkF5ZWZxczhqVTRkK0Qzcm1BMmVKNVVKVFZKTDZZemZOZGtNSHczcGpGOHh5ckN5U0l1aUNKa1pDa3FaWUlJUkhROG1CQ2JkTWdaeTRlK25BQS9HUUpoU1BYQ3E1QVRHcjRGSlRnN2hua1pLaUQ4bG9ialpXYU9HUVBXZWNKYWhSWkR2V3VIT2N0WFZGR0RlSUNjS3J3UmdpK1MyeU1TZlRMYmttNGtEWGNkbWpRODA1ajNISkpDZkdBUGVYN1VMNk80TmtWSTlxQ2E0aFpYdVY2WmZtSjZCV2k0bFJCOXpOU3NYRU96WE5BeEQxaklpTEplbGQ2dFlPSHVNZmcwRUpwR1FRbGVUQ3NQdnVRQVQ3T0pZRE5HUG5MZGxMb1Rtc3hMeEVrdWhoWU1OVkl5eVlCQWlkS2ZwQ3RVc2M3aHNZa3IwaXlEeDBOb2xHbTE0UE00YUVLTmttZWs4ZjZvbkR0ZWU1VHBWb1hVS0EyUzdralhybENHZHRXbmExZDVPRFl3R2k5a3dnRElnQTRVUmlXN0J3T1Z3SkJVd2dSUXladFRoUTZGUVlGYW1PWU1oZ2dDYW80UDgrUmhGN3ZVQVF6REhYZDVRQmoxLzFPMVNaZVpvVFRwSEVwOUtWQkNsOThxb1RrV1hZQjk2SkI2aXk3TDRVS0hsUHNNYVhKZitXVzB3enhnNVdZSlBnOHJNOFZsdlRuQ0hVbm1PTE93TzRrWmtwb0ZYMm9tblpRODVvcGdha2lOSkt6WldPSWtJK3VRcUhYeTR0azRnQmp0SXZDbHNKTTZLQzlSaisvZVQ3NmoyYkwvNERPMDhlcGZ5S21yb1FQaWxXL3B6ZCtCSXNnajVTWkpQMDlNOTZpRHBXb3BJZzJVSHBNUVN6VldGUVdvM1ZoZGhKZE51ckVlSzlZV1NVYjlwZGxzNGFONnEzc3M2b1FTZDZ3SmFNZUZyMkVqcm5IR0cvbHlROHRTRk8zMlpnRWVNWWg5cjVHRTVSWnJkQ1VzMlZnZzRuZkhIVkJ0M2V4S3VQT3gyYy9yamhjV0lhRXJvSzVLaFJCNml6ZVZjdDRnQzJnQXdCWGJIZTBwVGFnU3FvQVFSRHFyRm85S0NpaWlTa01iZUh4cDhpY2Y3NWcyL3NJdEp5YmZlMnZ4c0h2T2VPMjc3c25xcFg5NDR1RUpENjlkLzhibzJYKzYvcWJIU2MyRmM4NVlkTlpaOGpweWszenlsTDl6YlRoNjVORHh1K2I4WWZCUWV1RDlLLzV3MlpTOWxWVnpUbG82TFhrelY0Zkp2eXc4aStuQk1yYXhiT3l1QW95dXkwVW1EbEl5RHBrM0N5WTl2aHdIb0NNeWZiQ0hreW8vcFZYTVRxdG1iR3hIdXlpSCswRHVTTUtQYVRvL0JGYWNUQmY4eUtUdGpFbHdlQk4rWlB1eENoNXJ0aUJ1QjlZeGN6TGladkNWVkRzM1FUTVAxcFFHZVpmMU9FWWpTaWsxa1RkcERma2xyU1hVVUNlRFIrNWZVcTVVTHRWSU4vVmtWV01uUnpMSVdkV0NYRzlLOVVLYVJBRHg3d1BRNk9DTjZBVTFGblpPK29JUllKalRHMmU5WVdCWnE4QzJlTTUzYjBiY3ZyZ0ZPbXJLc2NSR3NiczVPVVVSVXlWMHVIV3V0ZUNodU5ZeUJYRUl4cm5xSG9MNTZSRE1jenB4U1BjMG9KNWplckRsMTYrMDU3VDFpRFI1cXBCUW5wN3IwTmoyOXhKM1ZqYUMyZWw5aWdMTEJneGZPWUp4YWJCQnZMQjNMRmJzNk90U3RDelJHdXpsd1JiTkZiTUFKejNQeW5HU1J0WGMwbG9STlFBMHVlT3hSZmtoNnk5ZFY5Si9MTnhBckxlUThXUXB2WTgrVHgrblNUSmcyNk8zUEc2WFh4LzE2TTRaUjlDalJ0SUxhSXcrVEM4bEs1NjU3K2FIcnVIMkxhejVVSFVRenVjMGZUNzZGY0VjRURHZnBGY2NEbUpLWnB5U3pLWlVnSGRCanluSnJvU1d4VnUrRGpVanhIYmdNd3FXVndqWXpSbnlzOXBWYTArSW5USTF1WktZU0loKzk5M0hsQktYdk9Ta0U1Ylp5Q3RzZFNyQ2Uydkw2VWUwbS82SHZrTWZYckJxMlZLNDkzQnQyTDBQY3dGZXdDc092VDVBWWpNZ2lyV2hLVkpBc1ZoQWNWZk9KbGx1VUFMR0dqT1dFQXJucXNzaDlKZVZCMHNYTDJpRUl2Mzg5di9KSXFaZmFKVnBydys3dU4yejlhdU9yRFZZQXZ0YmNIVzZ1T2tHRy9jYjUxSWNtc2FsZUwyUVdVVzZEcFJ4SGVpUFM5RzdHL3JmdThvS3ZDa3VzekpvaU9jYUVrSU42V3AweU96SDFXWUFTd2FCR3N5SzhTd053SXlaWDE2QjBpdjdyUXFUWVIxdzVVbW5RdXRia2VLNnhPWndoYnJTc0ExNmE1WTZVYmNOYmdjZFUyN1ZCYWZ3UEFMVE5SZnpDMnVRT2FtUFRFSkJPQmFLb3FxVjhVUFJzVHNWTE8vS3l3R2ZCSm8vM0dGd2xydUs4VUdGT0JFZEVEejNBcnBZQlVUMHlrTHRodythVy92VHBQNVRDTVRiaHdyMWswWXc3TTdCYWZhbUl2SUpqL1lwQy9ML21peUlwejlaOUp0S2VLTVBVZlNYVFdqcktRcEZPcGJ0cFp1WVRsUXhHMnlvdElWM0RpSUpydDQybU5Zc0dHc0t4d1pIQWFJcjFocEJJSS9RYnJnVUc1Z01Hb3hld2E3MjdEd0xoMjJQaHVQdDBEanVUUFVQQXJ4SHRJRVpWYzRLd0lHS3RidmlOdXlUTFBSQmhOTFR1M1VRckcvcGR6UVE5aVBDdzdjUnp1b3R5a08xRXNwVGUybVdJblgrK3BYeU5kT3JhcWxaR2k3ZEs2ckZWWFcvMFVxWTFrQVlpNFJqUTZQeGVpYlBnUnhScm1aM1BBeGVpaE5QbWc3b3lnQjBGR2UwNzU1Q0JKbHJDVU5EWVFoQno4dzFIQ0dseU5WVlVqcVE0enpha2M2M2oyNUNjQUQ5djZlbjBOV1BhQS9UV2RoYnJJZHNMdFE2ZThtVlNLMU1UeU5ZYTNTODRKbFdOV0hKZ2dQanR1V0JKYXNYMzVqeFVrUUQxQXRwWDZjTE5Fd1ZCTk0yRjd2dTJwRlcyb09VcFZrWUszRDFGQVVwNDN3SkNEcmZPblB2L050dWZlRzVsV1E2bFpXcjZja2ZmMC8vU2ovNWNlQXZ0WkdUVHA4NzYrOWt3bmRQMHRYV2Z6enh3ajRZTDIxUWk5VXFLVjg2bWxuZWdyTW9saGZtWlRZRndJTWR6d1VTYkN3a01OblpXc0w5bld0aW8rVXhNYVREem9kRzRvVGt5dVdsRVZnYTVPOXppQ1kxV0I1cW5mbm1uT3R2Mi9Ya01uSis5eXZLRGZUNEQ3KzZtQjU0OU90SHI2b2JjUDdxOWVmK25aeiszcE4wVmVDYk56Yis5eGtUUlgrT3R0bDBEL3FLczFMOU1EcklqRE1NdkxEb0ZKSjBSam5NM0hnRi9SL1F2TnBjWFdhSDA0MDVPRDNueExuL3N0c3pBV000V0F3YmRnb2hobVBETk1zYmREQ1lYNjRSUUREYXUzLzVTeG8vNFh6bXk3aWdxckFIUHlHaXpvdkNvZDQwaFo1ZU5JVnhFN1FvVzl5SkxHY3FNdHNmVGFFM2c2Rnd0YnloRnptaGVnc2JwU0prK1JOaWdZU01mcDQwYVFiQ3Njb29aRFN4YUtZNmZheE96ZzBQbVpzME8wNlhOSlE3WUlMVzBSNHZMOFFPaGtPTHQ1K04ybFBrcmIyM1pxOGw2T3NDVmNSNlBJcStaU1h3ZC9kY0VUOUdxVnlwS0pYQUpNb0JUQ0xvZDB4Ym9hNVNpOVVpYWp6Q0VMWENVQlZpUWNQODRxVlF5bUhLT3ZSQzlUUGxqTVg3UXg4bmZDK215YmJlODFVNTF3QmJXN3ZrbGNxa0JrQnh6RVFDeDFVTngrcWkwTktFMVQrTjZUamd2bFNsRDlTd29FbUpVWGZrSHdqRGtoZENPN0hEWThWRDIrUG9rNElBMEw5TFhjNnljbE4vMTF4dldvS1dXSXpNcFhmR0VvVjltQW85S0FySXpNKytKSytUM1YvSmIvYVVBcmU3Wnh0clBnQ3FFQkQxdTBobkxRZ3lFNEd0ZTVpdmV3MlRRUVJsa0ErSnFYeEpySHMrTHdjenM0ZjE1bElMSWhrekJRRjZsM2dVZ0kxem1TQnNTbEVRQlJFczZvZnhJRFBPbGdiOW5jRldub2IzdlZPZi9tazY3amZ4R1hMSXhQbFdYdElweXZNRjRyZThQbVV6L2YrOEUvL1h2Qk5hMnY1eUMrMDY1OUJ5QlpnenBtaEZHWXFXRW5KYStCc3E2NWh1eGVvelJJK2FWc28wemVyd0szekwvUmJwLy9adDEzTlZsTVB2UG1PaDVJMjl6eUF0WS85eHo3ZlhEcXhrNjFlV2ordFhwdUptSE1BM28zQjdjM2JqRnN3MVFnUm9aK0pKbTErR0htMlhZaXNDZktaWW96dGVqc2dVWmZtL1pRZG1TS25mUGZoblhRakxldWdHSVlmYmlnY2YxZlZGbnB6YWk2T0UvOEoxaHZrdkZvbVRZbktYRnFxaTNDNExCTGZkcHYxZEFRdno1M3RyVHY1dVhWY2dXZTJKWU51RUV5dThuUzVyWFZlOTV1eDlUTUdsMUNWYmZBRC9FSGRXTWZQQ1VSTkdZOEtWemVHODNGQ01GSmQ1NVEzNEx5S0dJdWdJMnNyMEFFRi9TalhxdlcrWmlYY012WmMrc2UveFQrOTZaS2VsK3o1NXB2Ym9qU2ZzbUhsSkgxZDN5VHg2SVgyWTZkTEdzZjhaSDQ5L2MrY2pMWlh5bUQ3OTN6SE1UN21DNlJLWDIyM0NwZ1pDWVRmb0VYTk9raFp6bmp1N0xtbmhFWlJEQ00zRXl3KzhZTTU2OVJKL3FGeW9FcXhkS1hrcFdlNDhrSmVwQ3E1eEcyYnM0aUEyS1c2R0duaUMwWFV2eGxCeVVJSU92VkxKa0JkM1ROd1lUK252MWg5ejM2WUZaOWlBY2RKeThvbkxMNW84Tm5uc3o5L1JYK21MWlgwNEkvc21ucjNtNlpVck8xNG9xMk1lOWJmMEMvcFJIejRJMWthclB6SmIyU1A1bVhlSFhWOVFoc003dnpRc2YvRHk1Z3lvdXBEaVRxTW9LQzduY05ab0FpQU5KRWZXS1NuYWtKSnRJSmx1ZFpFU0VxWlRqcm5xNmN0WG5UTGwzS1BtbE4wTDl2REJYOEx5bXdkcm43anpxS0tENWVObnFkT0VQY3c1c09kTFB1WmhSSHB4WVB2REVCQWxDTzhJSS9tdC9OVTRtbjVZcS84RWhtOXZMaEQxR3JSOXVXeCtZcklwa2VvQXE2T1hkSXJDUUkvZ2g1T2JsMGJuN3RhcmVrc0ZuUUhVUHVmbmdyY0tZWUJTVjF5UnNWRHB0OGl4djhCSjM3TGQycGZoMjFQVzMvVGgzM081UDhya1hpNDFRcjFPRDhtWGhtUDFVUURyaWxWRmtBckd6K3NXaTNoN1FJMlo4NzhVUVRxRStOb2hQeERYZ0wrbjV2Y3hqZmM3MzM1V2IyZGZsbThmck9QaHZ1WU1hMnZPWld0YkpGVXgyN2ZYMmhMZ2VLbis3U28vbEhDZStxaE9XTi9QS3QzV3NkQkRpb3ZmSHJOM1F5c3B6dHQ1YWgvN0lmL28rME81MGFlaStZOHN5SzNaZm1ScWpUZ0hVUTNUeGg1ckJKRThpTkQ5bm0zUmU4VDl5UG01bmtQdWU4LzBHaldNRy91cGpEMTBwaVNRVG5oQldOSmx5b1lLQUxqTXNTSXNCd2dLZXU0cFhyL1NsYXRJd3A5aVRsWjJxanFzS2l2YlVxZlhUMlRzT09pRDd0M0MxaXVobmE1cXFZb3gwZEgyWFc4ZHl5d2h3L1kyNWNlKy9FbnN1Mkw3eWkwVlM3WFNDb0VwS0FyTGtrNHRDK2J1WkNaTllUaFdIWVY3SFh0eTZ2UktzeTRQVGpuQXA1eVZxam1ydEdlSlFvQ1NjTHhTTUFnRVBIRDlZSmhGYytwNG9CbHRjWWVjdVZHQkpycmtkdlJoMnFXWHBHSExuREs4OTd5aEhuV1JXcVF0bHF4d2luUG9RdkFaYkRndlpvYjAwL0Z0MTR1VFJBUGt3OHFTN3NlZ3VWQmIvTjNCOVZBWmh2V2o2NVdWYWhYNzdCYlI1NjJxcWM4MjcrKy9zN3ZueDk4b3YwZEhRMXVnV2lXYXVzRWVCV3lYS05OWG05RFlzSFFKdDBmaENMU2JPRXQ1ckNHYVZEdzJMS3cwOWRUWUpxT1ZYNDVBNzJKdXF0TURXaXg1VlFzM0kxSktDNFV1c0loaFpzVVBBRWNTN05OZ0RUcFFkb0h1Z0l6ZXBTcEU3a0o2c0t6ZjJEb3Y4VHFSMkVrVjNVcy9tWDdrNW9zdXVIdDRIOUZnTW9kVWFvdTd2M2p2cGJmMmZETm43dHlwcXF2SG12NzhFbGFLYVlnejh6N1RaNXZRNkVaRE5uVlJURStqYXRjREE3Uk5GSjMyVU8yd1FRM09aZVBoeUNGQUdRdGw3NVZZMm9MaFlaMTMwY3lyWGVxRVpRLzNqRG5BWkZOZURiSnhaOGlHVHo0a0VHOFBKWm9iU2ZubDMrL2Z2Ly82aTU2ZVArK0NJWDFJWlF3cFY2dm9LVnR1ZStEQnYxdzB0RTA1czRkUUR0aUFBSnpuYmh0b2pjQXd6WmZXOTBBeEJjUEp5VHdaWjU3T3h0SUhybW5CYjhjMVJmb0pPeS85Z0tDYUhSeThIT3k5eTNKaWRyNG42Q21BNWtHZE5xSThwQ09nRGgvWXZwTGtQWFRuaWNka1lLRWUvSmZuTG5JNlBlMkJ4L0lBeTVqV0NFelV0TGtKVk5SRHowM3RPVGZ6LytIY3ZIM01MUjFSZGJBeHQzUnMxZTRiMmRSRzA0MHdOYlEzYTdUVEVLY2l6OEQzczBUMUZ2MllMd3ozVVNMSGg3M2JMcWhRRGdDeUFOQS9veS91Y1JxdDhUayszc0FtWWVCZGRzZFZiRFZQZGU5YmlaWSsxaDVkL0x1WmgvTm4rbWU1S2JVa1JpOS85eWpvNDM4bnRTaW9jemFtYzM5RnZJczg2Y2kwc1pQMHNmK09BWGNCWUVwNlh6LzcxNTQ1NW96MmZyS1FQcnAzTHprbk5XQ2p5Nzk3SDNUNHY1TW1hc0hCNlVaczd5Rml0RGxSRHBabFllZUZETUJVc2F3b0hxZTJDTVM4a1g0Q2M0c3haM3RjVThSR0h3RFpBWjViWkNvQUw4alo5RnRTUUc4d3hIa2J5YVA3eUdWQ3BCTytrUWVnSUYvNXBuc0hSMFNBOGJCalN6ME9lM2JUeDBONmpVYzl6SGlpSk5nUzVVQUlVVzhRWkdZamhjLy9qZjVMQ09yenY3OUlTbEJVZjl4RDdnQUIwVGw3NkZRREEyRVF1VVllS0s4REN3OWEvd2NSU3E3NTZpdnBmL1d6U2VRMlphMThOdnVaSDdoVTRrVGREMTlRREN3cWdPRS9tYVFNSUxlOTh3Ny9mZlBFdy8rK2lZcmZ6MU0ya2F2WldySXJWdUxnN0daRnNxb0dERFNrUksxNnY3Q0NKbGlyR3lnS3l2SzhjeUt2RGl1alB5cjNUU2VtUmZSOUhLLytlU2I0UE5oOVNVbDhuamtjazNmSFZmWjVVQVdxeW5xenRzZmRWdVkzS1hramlvazlPN3lhL2ZlQlo3MS9vdC96K1EvK1ZTTkphUi83dkVxWVQxSSt6S2Y1Vy9IVEJnOHRKN2FjQVdjZDZON3IyMFYvNXZ1TWpVMlpnSE4xQUhLa2p0TElKeHpMaWVnZ215WXo4bUdLWWxVZUJPZlRCK2RmeFVTWFBWMFVsVDFGUXJaNzUwUXpoT00xWkpRYWg0bWR4S080bE1DSTVJS0ttVGtnTlo5ZFRPVkpDTUMrY0tRbUNuMWs1dmFZSFN6RGxBaWptWkw4WW1RUnNUbWFVaEpOQ1ZZR3VTckxVSzdaMGtoSmdEOXk0ZXFRMkw5bkJFTHMwVXpwZnpHRWZYZEU5RlZJclFXUlpwTWI1Zk9VNzltWnh6bHNGS1JwRXQ4UTZBYzZrNjNRa1N1KzZYQSthZGYvN0NzM1hIRFYxZWV2djBwK2NmTXRXelp0dXUwMnROV1gvdnFKeVVscWtCTTF5RTVVOXZseGIxazBDcC91WVIva0tJaEV4R3NTcTlEL1VnbnZnV2FtZWRMTjM3bXhaQ0Jaak8rQTQ1NzkrYlorTEpIMDEwdW5IM1BVakptVGpwb3AxMDZiY3RUMEdaT09tU0hYVFpzTXI0NmVjY25SeDB5Wk5HSEd0Q043ZkllOUt4M0xaUElQdGlabEVtbzR0QjNqM0dOS0JOVVJXOU5WWFBJVzRyY1M4eVF5NTFYNkgySjlWYmJra2ZoeXVvUHVXTTdQamQ2ZnhTNXU4WEdwenlMd1dXMVcwa2E4WkJLeDBKOWVKWFBvSFMrVENXVENjbnBVSGowR1Btc1k4Ni9IYTZ2WWpyNUlTbFJJSFBzUENZTWhNTS9zaEFyb3VNOW5Hc3hEY1lXUnBObUV6M3hHSTNVdVR5Z3luV0kyWWlJZzY2V043RjhmRUU4RkVIOWU0c3hJa0U0TXlIQy9ZVkdLVk1KR1d0WWVkNWxUaGtOVlN4czdyRnNOUEN5Mis3eGxacStmL2V2anVHRGxGYUZoeTFSNXlYbEIwdnhwWXN2c0VXY01QZk42SDFsTFY4Z3lPWWJ1YkNMa2tuT1hQTENmdmg0aUwyMzFWVWJ1LzRUWUo3MWJWSDdSdXZ2TEdrcTJmdHI2M2NEdUQ3QjNVdDZsemNKekkwOTZVbmhCdGl5bVR5Yk9MV2JKeVkxRUlxSU9uai9DMXhMbmxBRWttUUFrMUtHSEhLaVpOSk1CSm1QQ0lLNUpoN0ZpMnBiSFlUanlzTTlDb05icWZaalBmUDNsdXdZTHMzZFgzSjc3c3hhelFZT1AzUXR0TERaN3JsZHY4SEZBZzQ4QUlUUm96dG5SSDNRRlhjUVZMU0JSOXFJdHFMRC8rMTBPT2UvUGQ1QkxQci94cm8vdVVFMzNYbnlyU1ZVL3VPcXE3Zy9sRXZiMUVDMGdIM2RQSVJ2T29EYnk0MmwwaGNDWHFsYXIyVzRMcGZYK2lSNlZwR0xsdXhtL2lYdG5BTUMrc3Yva3dGdlMvd1AyM2M0aUFBRUFBQUFCR2RzK2JVZURYdzg4OVFBZkNBQUFBQUFBeVVJWG9BQUFBQURWKzdEby8zRCtHZ29HQ0NBQUFRQUlBQUlBQUFBQUFBQjQybU5nWkdEZ0NQemJ3TURBeGZxLzRIOFBGeHNEVUFRWk1CNERBSDR1QmJrQUFBQjQybDFWYlloVVZSaCs1dDV6enIydXlpUUdDYm1WSkt4cHd4Wk15N0lPTGVKZ29MSGdFQTRyYmFHbUxmNVExMlVGSVMxcmkvbXhVYmFRVjloZ01SYkxxRW5VQlNzV0s4dy9mZm1yRHhHaFpOc2ZnZ1d4Rk9aT3ozUG0zbzBjZUhqdk9lZDl6M25mNTMzT21lQUd5dUF2dkFiay9nYUNoN0UzZkJ1SHpReldtQzE0eXYySWtqMkRuc0RpY0RCS080b3VzeElsclFWRmxJTDk2QXBXTStaQkxPYmNCbUtRMkpoaUJmRXNVU2FLcWUyV3YySzFSNFp3SE01ZHhqYjdPR0R2UmQzOGdBRTdUcnVPV0lPNmZZbmo3MUVQaG9YR1BydUk4NXRRajFhajdnckVJZ3lZaTAxckRkZmEwV3Qyb2MxT1ljTDhEa1M5M0hjSllLYUlYV2puUGpYbXZKRDJFYk1RY1hoLzR4OHpsbHRyanFGaXZrTVN6cUJLV3pXSFVBMytRQnZQY21ZT1NiQVpJOEhteHJDWjlOOUpkQUNKNXMxWjc1OG9KaHhrL0NYYUoxSGcybHVtQXJnaldHcWVRNHUrdzNNb0JuTm9OZTI1ajJsN1ZMKzRwNjBSR2p2bXNzQlZ5TjJINUp3YysyL21sM3VqY1ZWem5xY1VVWW14NU10ejFjUkpXZkkwUWR3V0p4bkV4enllWjc2cU40WDdDeFZmOTZIL2cvV3E1dXUreGd5cUswT2xtWWZmaDNuNFBaU0g0amNoQ0Y1bS9leVJlSXAyWWlEYXczbjJSeHhsL1JBbjgzWU1wODMyM0hyYWkxbE43ajcyWUQxMXNKSjFNamJWd1cxcElUcUdmUFJPMDBmYWNZcVpaVTd2MDE5NS9VUXJUU24rVy9aZ25kY056QTMweWxmUU92M3owcE4wNXJsaXZEVGx1YVdXdEtlcm9Tb2QyWnYwcTZFL2ZoVDErQUMvWCtQYUwvVFZXUzBveHl0b0Z6ZG1QU2Vmc000cjFNUUpKTlR0Y3ZIaVR2RDhUbXkwQnpsMzBPc25NZFBjWXpmSGNhcW5QNzJlbWxvc1VrdlNVVHUvcVNQYnhiVmJHSXI2eU9rTGpObkp0U0hPbmFML2RXeHd0T1lJejhqNk9BZWo4OE5iMU9VbDlkVHJlRnBhZGhjWWU4SHIyQ2dQbjAvRjM4TWtMbE0zNStGc0s4Y3h0ZFpKYnU2bXp3ajN2c3J4dXh6L2pNUXRKeitmWVdtOGl1TTY0Ny9odUJPdDdqMzB1NmRSOC9lVE5kbjlqRHZPdlZMYllqRVFueUVmVzhuM1E2ajY4NzVNcmM1bHY1V3pHY2NPc3hZZm1PMllvVFltaWJQUksyaUx5bWh6c3p6ekhwNzVFVGs2eFJyVU05M0YzYWlUaThSMG94QitDbU5IT1Q5S3ZpNHo3MVhOL3ZzZVRLbFh2amQxOHpyOWYrVWVrL1EveWp5ZklEYzd1RDdCR3JmUWZrRk9SbmplNS9UL2pUVXB0MHp6MGtpQk9ValRmZWxiUTh0WWNkVVNMV0d1SVFya3F0OE9ZMGo2VVE5cDZ6YlB2SXIwM2NQY1VpdU5TNmZTaXYyS1BvNDVQSU84dENhTlNpZnVWZHFUekNYZEs3ckdtQVY4bTRaVDdWTi9tZFU3b1R0Ty9lL3pHbndNWStib2Z6WTdLK09GUGgza3NNUGZEMnBpM3FhOXZOTks5OUtlN29uMGM2Zk5jdFE5bEJaMVg3eG1zLzY4U2I5cFNrTHZ0TjdLdTRENEFYNm5OamhIVUlPNXJTa01NYzQvcjBITzYzOG9SZmcxZXFMajZNbE5ZSmtRZEtBVWJzTXlqNXY4ejdxQ1B2Y2k5aW8yb0s5SDdOL2ZibnNhZVVOdC9BdnZUWkNVQUFBQUFDd0FMQUFzQUN3QWVBQzBBWmdDS0FMSUExZ0RlQU9pQTh3RDlnUTRCRjRFZkFTcUJNUUZFZ1UrQlpnR0JnWmVCcllIS0FkTUI4NElRZ2lFQ01RSTJBajZDUTRKZ2dvdUNuUUsyZ3NrQzJJTG5ndlVERUFNZUF5V0RNWU0vQTBpRFl3TjFBNGtEbWdPeWc4aUQ1WVB4aEFFRUVBUTNoRVNFVUlSY0JHZ0Vib1I3aElNRWlnU1VCTEFFeWdUYkJQSUZDNFVmaFZFRllRVnVoWUVGa0FXWEJiS0Z4SVhZQmZHR0NnWVloalFHU3daZGhtaUdrd2FmaHE4R3VvYlVodHVHOW9jR0J3WUhJUWM2aDFNSFlvZUtoNU9IbHdmQmg4d0gzWWZuQi93SUZZZzFpRXFJYXdoK2lKS0lxQWpGaU5NSTZZa0NpUjRKUG9sVENXcUpoNG1waWNvSjdJb1dDa0lLWXdxQkNwOEt2NHJrQ3ZHTENBc2dpenlMWFl0MUM0OExyNHZPQys0TUY0d3VERU1NWGd5R0RKU01ud3kxak15TTY0MFRqVFVOVlExeERZQU5qdzJnamJJTnZRM1FEZDhOOG80UURpbU9ONDVQRG13T2M0NktEcFlPdXc3VGp1Y085NDhPRHl1UE93OU1qMStQZVErQ2o1aVBwNCs1RDlVUDV4QUZrQktRTFpCSUVGWVFhaEIwa0lXUW1CQ2tFTE1RMFJEZUVPNFJBQkVPRVNLUk5wRkxrVndSY3hHUGthVVJ3UkhpRWZzU0JKSWJFalNTUmhKakVuUVNraEtmRXE2U3poTGNFdStTK2hNVGt5U1RNSk5BRTEyVGFoTjVrNHNUbVJPc2s3K1QwNVBqay9xVUZSUXFsRWlVYlpTTUZKcVVzcFRPRk51VThoVUVsUndWTXhWTUZWeVZjaFdRbGFBVnhaWGVsZmFXRHhZc2xrZVdXcFpyRm9jV29CYTlGdHVYQUJjbWwxWVhnNWVaRjdNWHlwZmRsL1NZQlpnbG1EK1lZcGlGbUtTWXdwai9HVGlaWjVtSW1hQ1p0aG5GR2RJWjhKbitHZ3VhWXBxT0dyQWEwcHJybXdPYkd4czVHMFViVVJ0aW0zT2JpNXVrRzd3YjFKdjhIQ1NjT0J4TUhGNGNiNXlGbkowY3J4ekFITk9jNTV6NW5RdWRKaDFBSFdZZGpCMnNIY3VkMmgzb25mU2VBcDRXbml1ZVBaNVFubVllZVo2T25xTWV2WjdYbnVtZStwOGRuejhmWlorSW41QWZzSi9SSCt3Z0JLQWxJRG1nVHlCbElIaWdqQ0Npb0xlZzFpRDZJUUdoSVNGTW9XeWhsaUdySWRjaDg2SVlJaklpUzZKeUlwa2l1cUxib3dXak1LTkdvMXVqY0tPRkk2S2p3S1BoSkFJa0dhUXNwRkVrYzZTYXBNRWswcVRrcFFHbElDVTJKVTBsYktXTHBaY2xveVhHcGVtbUJTWWdwamdtVGlaZ0puRW1jU1p4Sm5FbWNTWnhKbkVtY1NaeEpuRW1jU1p4Sm5TbWVDWjdwb0dtaDZhUnBwdW1wU2EySnNhbTFxYmlKdmttK1NjQ3B3d25EQ2NzSjA2blZvQUFBQUJBQUFCeGdCdUFBZ0FBQUFBQUFJQUFRQUNBQllBQUFFQUFYQUFBQUFBZU5xZGs3OXVFMEVReHIvekJUQVFVcVJBVVVSeEpRVTV6a0VJRkNvVEFrS0tTSkVJR29UazJJNXpjSTZUOHhrVWFrb2VJMDBrbm9DYWdqOHRRcUxoRVhnR2ZqdTdOcGdvQldnMWM5L09uMjluWnZja3pldUhZa1V6NXlXVmlNY1I5akxnbXVwNkUzQ3NWRzhEbnRFVnZRLzRqQmIwTGVDeld0VFBnTS9wS0tvSFhOZlY2RjNBRjNVNytocndySjdXWmdPK0JONE5lRTVidFE4QmY5VGxlQ0hnVDhyaU5PRFBtb3VmQmZ4RkYrTEM0Kyt4RnVPWHVxZGNQYVJDWHF1cmpoS2t4YjRGYW11Z2ZSM1NwNHZheFpyb0dGbFdwZ2F5RkZCRDE3QStJSHBBWEFGUG9sVndTYmJUTGVNZmFJL1piR0RyZ2hKdFl0L1RVSGZ4Rkp6YXdPdFk3NkNiZUZkQjQraHg3TklrK2lSUE12RTl4bE5pOFdjbUUrWi9ZOHROdXpsVTFrT0hpRDdmVWkrd0RiUnpvbWVYNlNib29nNzVicHUxUlBlTXJiSzYvSlJ6TzYxdEZqZHR2Myt1a1UxN1NFeU9kenkzSVIwMDBXMnJzbU5acDgzWTNWT0ZkVVhYV2E5c3BmaW5zOXNoTnpYVUovSi84eXA2M2JldXVqYnpIckYrL3FseDlwbk91blhUdFU1OC82TS8rcWlJYzVOcXd0TWl6dSttYzl3TCsvdGVsemtoTzdYdTMxeXAxZHpEVzB4eERyR3M2eUZ6WE5NamJuN05YclRqZklKM214dDI1MVRoQldYYWdtM0Vic051Sm1IZFJETDBDcEtoYjVBLy9qOXVXWDg3VkRIaTNNcHE4Slhmbi9CdTZnQnZqc2U5aStJWERuYXlxUUI0Mm0zVlpaUldSUURHOGVjWllCZVc3azRGQTVUMzlyMEdlRk5Bd0VBVUFaVVZsbDBFZDZrVndlNXV4ZTRPVkZCQnNSWHM3Z0lWN083R09Qcyt4MC9PT1hQKzk4NkgrWjM1TWdPRHByR3BEalB4UDRPUC96c05tNkVabXFNRktsQ0psbWlGS3JSR0c3UkZPN1JIQjNSRUozUkdGM1JGTjNSSEQvUkVML1JHSC9SRlAvVEhBQXpFSUd5R3pURVlRN0FGdHNSVzJCcERNUXpiWUZzTVJ3a1diRGh3NGNGSGdCQVJ0c1AyMkFFN1lnUkdZaWZFU0pBaVE0NENPMk1VUm1NTWRzRllqTU40N0lyZHNEdjJ3QVRzaVluWUMzdGpFdmJCWkV6QlZPeUwvYkEvcHFHYXpYRWNqc2RTbklGVGNSTmI0QlNjanZXNEdjdndCQTdBV1ppQloxQ0RKL0UwbnNQemVCRXZvUmF2NHpYVTRXUWNpTm1ZZ3l2UmdIbVlpL2xZZ0lPeENJdHhLQTdEa1RnS1IyTTFLMWlKVGZpTExka0tHN0NSVld5Tk83Q2NiZGdXOTdFZDI3TURPK0pOck1OYjdNVE83TUt1N01idTdNR2U3TVhlN01PKzdNZitITUNCSE1UTnVEa0hjd2kzNEpiY2lsdHpLSWR4RzI3TDRTelJvazJITGozNkRCZ3k0bmJjbmp0d1I0N2dTTzdFbUFsVFpzeFpjR2VPNG1pTzRTNGN5M0VjejEyNUczZm5IcHpBUFRtUmUzRnZUdUkrbk13cG5NcDl1Ui8zNXpSVzh3Qk81d3pXY0NacldjZFpQSkN6T1ljSHNaNE5uTXQ1bk04RlhNaEdIc3hGUElTTHVZU0g4akFlemlONEpJL2kwVHlHeC9JNEhzOFRlQ0pQNHNrOGhhZnlOSjdPTTNnbXorTFpQSWZuOGp5ZXo2VzhnQmZ5SWw3TVMzZ3BMK1BsdklKWDhpcGV6V3Q0TGEvajlieUJOL0ltM3N4YmVDdVg4VGJlemp1NG5DdDRKKy9pM1Z6SlZieUg5M0kxNytQOWZJQVA4aUUrekVmNEtCL2pHcTdsNDN5Q1QvSXBQczFuK0N5ZjQvTjhnUy95SmI3TVYvZ3FYK1ByZklOdjhpMit6WGY0THRkeFBkL2orL3lBRzdpUkgvSWpmc3hQK0NrLzQrZjhnbC95SzM3TmIvZ3R2K1AzL0lFLzhpZit6Ri80SzMvajcveURmM0lULytMZkJvYkdtR2FtdVdsaEtreWxhV2xhbVNyVDJyUXhiVTA3MDk1ME1CMU5KOVBaZERGZFRUZlQzZlF3UFUwdjA5djBNWDFOUDZ6QW5WaUpWVmlEdTNBMzF1SkUzR0w2NDBFOFpBYVlnVGpOREtxb25iTjRicDFWMlZnL3ExUXFaZVhHSlRXcmpCdHFHK3ByWmxkV3E3bGFVMjdGK09ycGpRdHJLdXJMbVZET2duSW1sN09rS1ZXVFp6UXNySjQrdmFaK1lkV1MvejZiSExkVVVpM1ZWaDNWVlQzVlZ3TTFWQ00xVmhNMVZUTTFWNHR5TGZtV2ZFdStKZCtTYjhtMzVGdnlMZm1XZkV1K0pkK1NiOG0zNUZ2eWJmbTJmRnUrTGQrV2I4dTM1ZHZ5YmZtMmZGdStMZCtXYjh1MzVkdnlIZm1PZkVlK0k5K1I3OGgzNUR2eUhmbU9mRWUrSTkrUjc4aDM1RHZ5WGZtdWZGZStLOStWNzhwMzVidnlYZm11ZkZlK0s5K1Y3OHAzNWJ2eVBmbWVmRSsrSjkrVDc4bjM1SHZ5UGZtZWZFKytKOStUNzhuMzVIdnlmZm0rZkYrK0w5K1g3OHYzNWZ2eWZmbStmRisrTDkrWDc4djM1ZnZ5QS9tQi9FQitJRCtRSDhnUDVBZnlBL21CL0VCK0lEK1FIOGdQNUFmeVEvbWgvRkIrS0QrVUg4b1A1WWR5UTdtaDNGQnVLRGVVRzhvTjVVWnlJN21SM0VodUpEZVNHOG1OZE81SWZpUS9raC9KaitSSDhpUDVrWHpkczI0c1A1WWZ5NC9seC9KaitiSDhXSDRzUDVZZnk0L2x4L0pqK2JIOFJINGlQNUdmeUUva0ovSVQrWW44Ukg0aVA1R2Z5RS9rSi9JVCtZbjhWSDRxUDVXZnlrL2xwL0pUK2FuOFZINHFQNVdmeWsvbHAvSlQrYW44VEg0bVA1T2Z5Yy9rWi9JeitabjhUSDRtUDVPZnljL2taL0l6K1puOFhINHVQNWVmeTgvbDUvSnorYm44WEg0dVA1ZWZ5OC9sNS9KeitibjhRbjRodjVCZnlDL2tGL0lMK1lYOFFuNGh2NUJmeUMva0YvSUwrVVdUYjVmSzcvNi90VlJiZFZSWDlWUmZEZFJRamRTNFhFdjdXbGJWekZtMWpmTnJabFF2cUNzdjJhSzlvbm5lT0wraDZjY3IwbjhBVGZKQXFBQjQydHZCK0w5MUEyTXZnL2NHam9DSWpZeU1mWkViM2RpMEl4UTNDRVI2YnhBSkFqSWFJbVUzc0duSFJEQnNZRlp3M2NDczdiS0JUY0YxRS9OL0ptMHdoeFhJWVl1QWNsaUFIRlkxQ0lkeEF6dFVQWWVDNnk0Rzl2ci9ERXphRzVuZHlvQWluQ0FSRGtaVnVFamtCaEZ0QU9zTEtLY0FBQUFBQVZuV0FHa0FBQT09KSBmb3JtYXQoJ3dvZmYnKTtmb250LXdlaWdodDo3MDA7Zm9udC1zdHlsZTpub3JtYWx9Lm9wZW4tc2Fuc3tmb250LWZhbWlseTonT3BlbiBTYW5zJyxBcmlhbCxzYW5zLXNlcmlmfS8qISBub3JtYWxpemUuY3NzIHYzLjAuMSB8IE1JVCBMaWNlbnNlIHwgZ2l0LmlvL25vcm1hbGl6ZSAqL2h0bWx7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjstbXMtdGV4dC1zaXplLWFkanVzdDoxMDAlOy13ZWJraXQtdGV4dC1zaXplLWFkanVzdDoxMDAlfWJvZHl7bWFyZ2luOjB9YXJ0aWNsZSxhc2lkZSxkZXRhaWxzLGZpZ2NhcHRpb24sZmlndXJlLGZvb3RlcixoZWFkZXIsaGdyb3VwLG1haW4sbmF2LHNlY3Rpb24sc3VtbWFyeXtkaXNwbGF5OmJsb2NrfWF1ZGlvLGNhbnZhcyxwcm9ncmVzcyx2aWRlb3tkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZX1hdWRpbzpub3QoW2NvbnRyb2xzXSl7ZGlzcGxheTpub25lO2hlaWdodDowfVtoaWRkZW5dLHRlbXBsYXRle2Rpc3BsYXk6bm9uZX1he2JhY2tncm91bmQ6MCAwfWE6YWN0aXZlLGE6aG92ZXJ7b3V0bGluZTowfWFiYnJbdGl0bGVde2JvcmRlci1ib3R0b206MXB4IGRvdHRlZH1iLHN0cm9uZ3tmb250LXdlaWdodDo3MDB9ZGZue2ZvbnQtc3R5bGU6aXRhbGljfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOi42N2VtIDB9bWFya3tiYWNrZ3JvdW5kOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1cHt0b3A6LS41ZW19c3Vie2JvdHRvbTotLjI1ZW19aW1ne2JvcmRlcjowfXN2Zzpub3QoOnJvb3Qpe292ZXJmbG93OmhpZGRlbn1maWd1cmV7bWFyZ2luOjFlbSA0MHB4fWhye2JveC1zaXppbmc6Y29udGVudC1ib3g7aGVpZ2h0OjB9cHJle292ZXJmbG93OmF1dG99Y29kZSxrYmQscHJlLHNhbXB7Zm9udC1mYW1pbHk6bW9ub3NwYWNlLG1vbm9zcGFjZTtmb250LXNpemU6MWVtfWJ1dHRvbixpbnB1dCxvcHRncm91cCxzZWxlY3QsdGV4dGFyZWF7Y29sb3I6aW5oZXJpdDtmb250OmluaGVyaXQ7bWFyZ2luOjB9YnV0dG9ue292ZXJmbG93OnZpc2libGV9YnV0dG9uLHNlbGVjdHt0ZXh0LXRyYW5zZm9ybTpub25lfWJ1dHRvbixodG1sIGlucHV0W3R5cGU9YnV0dG9uXSxpbnB1dFt0eXBlPXJlc2V0XSxpbnB1dFt0eXBlPXN1Ym1pdF17LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbjtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRdLGh0bWwgaW5wdXRbZGlzYWJsZWRde2N1cnNvcjpkZWZhdWx0fWJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixpbnB1dDo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MDtwYWRkaW5nOjB9aW5wdXR7bGluZS1oZWlnaHQ6bm9ybWFsfWlucHV0W3R5cGU9Y2hlY2tib3hdLGlucHV0W3R5cGU9cmFkaW9de2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjB9aW5wdXRbdHlwZT1udW1iZXJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLGlucHV0W3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbntoZWlnaHQ6YXV0b31pbnB1dFt0eXBlPXNlYXJjaF17LXdlYmtpdC1hcHBlYXJhbmNlOnRleHRmaWVsZDtib3gtc2l6aW5nOmNvbnRlbnQtYm94fWlucHV0W3R5cGU9c2VhcmNoXTo6LXdlYmtpdC1zZWFyY2gtY2FuY2VsLWJ1dHRvbixpbnB1dFt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmV9ZmllbGRzZXR7Ym9yZGVyOjFweCBzb2xpZCBzaWx2ZXI7bWFyZ2luOjAgMnB4O3BhZGRpbmc6LjM1ZW0gLjYyNWVtIC43NWVtfWxlZ2VuZHtib3JkZXI6MDtwYWRkaW5nOjB9dGV4dGFyZWF7b3ZlcmZsb3c6YXV0b31vcHRncm91cHtmb250LXdlaWdodDo3MDB9dGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjB9dGQsdGh7cGFkZGluZzowfSp7Ym94LXNpemluZzpib3JkZXItYm94fTphZnRlciw6YmVmb3Jle2JveC1zaXppbmc6Ym9yZGVyLWJveH1odG1se2hlaWdodDoxMDAlO2ZvbnQtc2l6ZToxMHB4Oy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjp0cmFuc3BhcmVudH1ib2R5e3Bvc2l0aW9uOnJlbGF0aXZlO2ZvbnQtZmFtaWx5OidPcGVuIFNhbnMnLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS41NzE0Mjg1Nztjb2xvcjojMzMzO2JhY2tncm91bmQ6MCAwO292ZXJmbG93LXk6aGlkZGVufWJ1dHRvbixpbnB1dCxzZWxlY3QsdGV4dGFyZWF7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtsaW5lLWhlaWdodDppbmhlcml0O291dGxpbmU6MDtib3JkZXItcmFkaXVzOjA7Ym94LXNoYWRvdzpub25lfWF7Y29sb3I6IzM2YmE1Mzt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO291dGxpbmU6MH1hOmhvdmVye2NvbG9yOiMyNTdmMzk7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX1maWd1cmV7bWFyZ2luOjB9aW1ne3ZlcnRpY2FsLWFsaWduOm1pZGRsZTttYXgtd2lkdGg6MTAwJX1ocnttYXJnaW4tdG9wOjEuNTcxNDI4NTc7bWFyZ2luLWJvdHRvbToxLjU3MTQyODU3O2JvcmRlcjowO2JvcmRlci10b3A6MXB4IHNvbGlkICNlZWV9LnNyLW9ubHl7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MXB4O2hlaWdodDoxcHg7bWFyZ2luOi0xcHg7cGFkZGluZzowO292ZXJmbG93OmhpZGRlbjtjbGlwOnJlY3QoMCwwLDAsMCk7Ym9yZGVyOjB9LnNyLW9ubHktZm9jdXNhYmxlOmFjdGl2ZSwuc3Itb25seS1mb2N1c2FibGU6Zm9jdXN7cG9zaXRpb246c3RhdGljO3dpZHRoOmF1dG87aGVpZ2h0OmF1dG87bWFyZ2luOjA7b3ZlcmZsb3c6dmlzaWJsZTtjbGlwOmF1dG99cHttYXJnaW46MCAwIC43ODU3MTQyOX0udGV4dC1sZWZ0e3RleHQtYWxpZ246bGVmdCFpbXBvcnRhbnR9LnRleHQtcmlnaHR7dGV4dC1hbGlnbjpyaWdodCFpbXBvcnRhbnR9LnRleHQtY2VudGVye3RleHQtYWxpZ246Y2VudGVyIWltcG9ydGFudH0udGV4dC1qdXN0aWZ5e3RleHQtYWxpZ246anVzdGlmeSFpbXBvcnRhbnR9LnRleHQtbm93cmFwe3doaXRlLXNwYWNlOm5vd3JhcCFpbXBvcnRhbnR9LnRleHQtbG93ZXJjYXNle3RleHQtdHJhbnNmb3JtOmxvd2VyY2FzZSFpbXBvcnRhbnR9LnRleHQtdXBwZXJjYXNle3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZSFpbXBvcnRhbnR9LnRleHQtY2FwaXRhbGl6ZXt0ZXh0LXRyYW5zZm9ybTpjYXBpdGFsaXplIWltcG9ydGFudH0udGV4dC1tdXRlZHtjb2xvcjojNzc3IWltcG9ydGFudH1vbCx1bHttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTouNzg1NzE0Mjl9b2wgb2wsb2wgdWwsdWwgb2wsdWwgdWx7bWFyZ2luLWJvdHRvbTowfWNvZGUsa2JkLHByZSxzYW1we2ZvbnQtZmFtaWx5Ok1lbmxvLE1vbmFjbyxDb25zb2xhcywiQ291cmllciBOZXciLG1vbm9zcGFjZX1jb2Rle3BhZGRpbmc6MnB4IDRweDtmb250LXNpemU6OTAlO2NvbG9yOiNjNzI1NGU7YmFja2dyb3VuZC1jb2xvcjojZjlmMmY0fWtiZHtwYWRkaW5nOjJweCA0cHg7Zm9udC1zaXplOjkwJTtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzMzMztib3gtc2hhZG93Omluc2V0IDAgLTFweCAwIHJnYmEoMCwwLDAsLjI1KX1rYmQga2Jke3BhZGRpbmc6MDtmb250LXNpemU6MTAwJTtib3gtc2hhZG93Om5vbmV9cHJle2Rpc3BsYXk6YmxvY2s7cGFkZGluZzouMjg1NzE0Mjk7bWFyZ2luOjAgMCAuNzg1NzE0Mjk7Zm9udC1zaXplOjEzcHg7bGluZS1oZWlnaHQ6MjJweDt3b3JkLWJyZWFrOmJyZWFrLWFsbDt3b3JkLXdyYXA6YnJlYWstd29yZDtjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2Y1ZjVmNTtib3JkZXI6MXB4IHNvbGlkICNjY2N9cHJlIGNvZGV7cGFkZGluZzowO2ZvbnQtc2l6ZTppbmhlcml0O2NvbG9yOmluaGVyaXQ7d2hpdGUtc3BhY2U6cHJlLXdyYXA7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItcmFkaXVzOjB9LnByZS1zY3JvbGxhYmxle21heC1oZWlnaHQ6MzQwcHg7b3ZlcmZsb3cteTpzY3JvbGx9Zm9ybXttYXJnaW46MH1maWVsZHNldHtwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOjA7bWluLXdpZHRoOjB9bGVnZW5ke2Rpc3BsYXk6YmxvY2s7d2lkdGg6MTAwJTtwYWRkaW5nOjA7bWFyZ2luLWJvdHRvbToxLjU3MTQyODU3O2ZvbnQtc2l6ZToyMXB4O2xpbmUtaGVpZ2h0OmluaGVyaXQ7Ym9yZGVyOjB9bGFiZWx7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWF4LXdpZHRoOjEwMCU7bWFyZ2luLWJvdHRvbTo1cHg7Zm9udC13ZWlnaHQ6NzAwfWlucHV0W3R5cGU9c2VhcmNoXXtib3gtc2l6aW5nOmJvcmRlci1ib3h9aW5wdXRbdHlwZT1jaGVja2JveF0saW5wdXRbdHlwZT1yYWRpb117bWFyZ2luOjRweCAwIDA7bGluZS1oZWlnaHQ6bm9ybWFsfWlucHV0W3R5cGU9ZmlsZV17ZGlzcGxheTpibG9ja31pbnB1dFt0eXBlPXJhbmdlXXtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCV9c2VsZWN0W211bHRpcGxlXSxzZWxlY3Rbc2l6ZV17aGVpZ2h0OmF1dG99aW5wdXRbdHlwZT1jaGVja2JveF06Zm9jdXMsaW5wdXRbdHlwZT1maWxlXTpmb2N1cyxpbnB1dFt0eXBlPXJhZGlvXTpmb2N1c3tvdXRsaW5lOnRoaW4gZG90dGVkO291dGxpbmU6NXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO291dGxpbmUtb2Zmc2V0Oi0ycHh9LmZvcm0tY29udHJvbHtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjQwcHg7cGFkZGluZzo2cHggMTVweCA0cHg7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MjJweDtjb2xvcjojMzMzO2JhY2tncm91bmQ6I2ZmZjtib3JkZXI6MXB4IHNvbGlkICNlNmU2ZTY7Ym94LXNoYWRvdzppbnNldCAwIDNweCAzcHggcmdiYSgwLDAsMCwuMDQpfS5mb3JtLWNvbnRyb2w6Zm9jdXN7Ym9yZGVyLWNvbG9yOiM4YzhjOGM7b3V0bGluZTowfS5mb3JtLWNvbnRyb2w6Oi1tb3otcGxhY2Vob2xkZXJ7Y29sb3I6Izc3NztvcGFjaXR5OjF9LmZvcm0tY29udHJvbDotbXMtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6Izc3N30uZm9ybS1jb250cm9sOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiM3Nzd9LmZvcm0tY29udHJvbFtkaXNhYmxlZF0sLmZvcm0tY29udHJvbFtyZWFkb25seV0sZmllbGRzZXRbZGlzYWJsZWRdIC5mb3JtLWNvbnRyb2x7Y3Vyc29yOm5vdC1hbGxvd2VkO2JhY2tncm91bmQtY29sb3I6I2ZmZjtvcGFjaXR5OjF9dGV4dGFyZWEuZm9ybS1jb250cm9se2hlaWdodDphdXRvfWlucHV0W3R5cGU9c2VhcmNoXXstd2Via2l0LWFwcGVhcmFuY2U6bm9uZX1pbnB1dFt0eXBlPWRhdGVdLGlucHV0W3R5cGU9ZGF0ZXRpbWUtbG9jYWxdLGlucHV0W3R5cGU9bW9udGhdLGlucHV0W3R5cGU9dGltZV17bGluZS1oZWlnaHQ6MjJweH0uZm9ybS1ncm91cHttYXJnaW46MjNweCAwIDB9LmZvcm0tZ3JvdXA6Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDowfWZpZWxkc2V0W2Rpc2FibGVkXSBpbnB1dFt0eXBlPWNoZWNrYm94XSxmaWVsZHNldFtkaXNhYmxlZF0gaW5wdXRbdHlwZT1yYWRpb10saW5wdXRbdHlwZT1jaGVja2JveF0uZGlzYWJsZWQsaW5wdXRbdHlwZT1jaGVja2JveF1bZGlzYWJsZWRdLGlucHV0W3R5cGU9cmFkaW9dLmRpc2FibGVkLGlucHV0W3R5cGU9cmFkaW9dW2Rpc2FibGVkXXtjdXJzb3I6bm90LWFsbG93ZWR9LmZvcm0tdWl7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO21hcmdpbjowO2xpbmUtaGVpZ2h0OjIwcHg7Zm9udC13ZWlnaHQ6NDAwO2N1cnNvcjpwb2ludGVyfS5jaGFuZ2UtcG9zaXRpb25faW5wdXQsLmZvcm0tdWktY29udHJvbCwubWVudS1maWx0ZXJfaW5wdXR7cG9zaXRpb246YWJzb2x1dGU7dG9wOi05OTk5cHg7bGVmdDotOTk5OXB4O3dpZHRoOjA7aGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO2NsaXA6cmVjdCgwLDAsMCwwKTtvdXRsaW5lOjAgbm9uZX0uZm9ybS11aS10eHR7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO3BhZGRpbmc6MnB4IDAgMCAzMHB4fS5mb3JtLXVpLXR4dDpiZWZvcmV7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MjJweDtoZWlnaHQ6MjJweH0uZm9ybS11aS10eHQ6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZX1pbnB1dFt0eXBlPXJhZGlvXSsuZm9ybS11aSAuZm9ybS11aS10eHQ6YmVmb3Jle2JvcmRlcjoxcHggc29saWQgI2NmY2ZjZjtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kOiNmZmZ9aW5wdXRbdHlwZT1yYWRpb10rLmZvcm0tdWkgLmZvcm0tdWktdHh0OmFmdGVye3RvcDo3cHg7bGVmdDo3cHg7d2lkdGg6OHB4O2hlaWdodDo4cHg7Ym9yZGVyLXJhZGl1czo1MCV9aW5wdXRbdHlwZT1yYWRpb106Y2hlY2tlZCsuZm9ybS11aSAuZm9ybS11aS10eHQ6YWZ0ZXJ7YmFja2dyb3VuZDojMzZiYTUzfWlucHV0W3R5cGU9cmFkaW9dOmRpc2FibGVkKy5mb3JtLXVpIC5mb3JtLXVpLXR4dDpiZWZvcmV7YmFja2dyb3VuZDojZjJmMmYyO29wYWNpdHk6LjZ9aW5wdXRbdHlwZT1yYWRpb106ZGlzYWJsZWQrLmZvcm0tdWkgLmZvcm0tdWktdHh0OmFmdGVye29wYWNpdHk6LjZ9aW5wdXRbdHlwZT1jaGVja2JveF0rLmZvcm0tdWkgLmZvcm0tdWktdHh0OmJlZm9yZXtib3JkZXI6MXB4IHNvbGlkICNjZmNmY2Y7YmFja2dyb3VuZDojZmZmfWlucHV0W3R5cGU9Y2hlY2tib3hdKy5mb3JtLXVpIC5mb3JtLXVpLXR4dDphZnRlcnt0b3A6N3B4O2xlZnQ6NXB4O3dpZHRoOjEzcHg7aGVpZ2h0OjZweDtib3JkZXItYm90dG9tOjJweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDoycHggc29saWQgdHJhbnNwYXJlbnQ7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7LW1zLXRyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9aW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZCsuZm9ybS11aSAuZm9ybS11aS10eHQ6YmVmb3Jle2JvcmRlcjoxcHggc29saWQgIzM2YmE1MztiYWNrZ3JvdW5kOiMzNmJhNTN9aW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZCsuZm9ybS11aSAuZm9ybS11aS10eHQ6YWZ0ZXJ7Ym9yZGVyLWJvdHRvbS1jb2xvcjojZmZmO2JvcmRlci1sZWZ0LWNvbG9yOiNmZmZ9aW5wdXRbdHlwZT1jaGVja2JveF06ZGlzYWJsZWQrLmZvcm0tdWkgLmZvcm0tdWktdHh0OmJlZm9yZXtvcGFjaXR5Oi42fWlucHV0W3R5cGU9Y2hlY2tib3hdOmRpc2FibGVkKy5mb3JtLXVpIC5mb3JtLXVpLXR4dDphZnRlcntvcGFjaXR5Oi42fS5idG57ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWJvdHRvbTowO3BhZGRpbmc6MTFweCAxN3B4IDlweDtmb250OjEzcHgvMThweCAnT3BlbiBTYW5zJyxBcmlhbCxzYW5zLXNlcmlmO3RleHQtYWxpZ246Y2VudGVyO3RleHQtZGVjb3JhdGlvbjpub25lO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtjdXJzb3I6cG9pbnRlcjtiYWNrZ3JvdW5kLWltYWdlOm5vbmU7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDt3aGl0ZS1zcGFjZTpub3dyYXA7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5idG46aG92ZXJ7Y29sb3I6IzAwMDt0ZXh0LWRlY29yYXRpb246bm9uZX0uYnRuLmFjdGl2ZSwuYnRuOmFjdGl2ZXtvdXRsaW5lOjB9LmJ0bjpmb2N1c3tvdXRsaW5lOjA7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAxcHggI2ZmZn0uYnRuLmRpc2FibGVkLC5idG5bZGlzYWJsZWRde2N1cnNvcjpkZWZhdWx0O2JveC1zaGFkb3c6bm9uZTtvcGFjaXR5Oi41O3BvaW50ZXItZXZlbnRzOm5vbmV9LmJ0bi1kZWZhdWx0e2JvcmRlci1jb2xvcjojNTg1OTViO2JhY2tncm91bmQ6IzU4NTk1Yjtjb2xvcjojZmZmfS5idG4tZGVmYXVsdDpob3Zlcntib3JkZXItY29sb3I6IzcxNzI3NTtiYWNrZ3JvdW5kOiM3MTcyNzU7Y29sb3I6I2ZmZn0uYnRuLWRlZmF1bHQuYWN0aXZlLC5idG4tZGVmYXVsdDphY3RpdmV7Ym9yZGVyLWNvbG9yOiM3MTcyNzU7YmFja2dyb3VuZDojNzE3Mjc1fS5idG4tZGVmYXVsdC5kaXNhYmxlZCwuYnRuLWRlZmF1bHRbZGlzYWJsZWRde2JvcmRlci1jb2xvcjojNTg1OTViO2JhY2tncm91bmQ6IzU4NTk1Yn0uYnRuLXByaW1hcnl7Ym9yZGVyLWNvbG9yOiMzNmJhNTM7YmFja2dyb3VuZDojMzZiYTUzO2NvbG9yOiNmZmZ9LmJ0bi1wcmltYXJ5OmhvdmVye2JvcmRlci1jb2xvcjojMzBhNjRhO2JhY2tncm91bmQ6IzMwYTY0YTtjb2xvcjojZmZmfS5idG4tcHJpbWFyeS5hY3RpdmUsLmJ0bi1wcmltYXJ5OmFjdGl2ZXtib3JkZXItY29sb3I6IzMwYTY0YTtiYWNrZ3JvdW5kOiMzMGE2NGF9LmJ0bi1wcmltYXJ5LmRpc2FibGVkLC5idG4tcHJpbWFyeVtkaXNhYmxlZF17Ym9yZGVyLWNvbG9yOiMzNmJhNTM7YmFja2dyb3VuZDojMzZiYTUzfUBtZWRpYSAobWF4LXdpZHRoOjQwMHB4KXsuYnRuLWFub3RoZXItZWx7Zm9udC1zaXplOjlweDtwYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjA7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXI6MDtjb2xvcjojMDAwfS5idG4tYW5vdGhlci1lbDpob3Zlcntib3JkZXItY29sb3I6dHJhbnNwYXJlbnQ7YmFja2dyb3VuZDowIDA7Y29sb3I6IzAwMH19LmJ0bi1jYW5jZWx7Ym9yZGVyLWNvbG9yOiNmMzUyM2Q7YmFja2dyb3VuZDojZjM1MjNkO2NvbG9yOiNmZmZ9LmJ0bi1jYW5jZWw6aG92ZXJ7Ym9yZGVyLWNvbG9yOiNlZTI5MGY7YmFja2dyb3VuZDojZWUyOTBmO2NvbG9yOiNmZmZ9LmJ0bi1jYW5jZWwuYWN0aXZlLC5idG4tY2FuY2VsOmFjdGl2ZXtib3JkZXItY29sb3I6I2VlMjkwZjtiYWNrZ3JvdW5kOiNlZTI5MGZ9LmJ0bi1jYW5jZWwuZGlzYWJsZWQsLmJ0bi1jYW5jZWxbZGlzYWJsZWRde2JvcmRlci1jb2xvcjojZjM1MjNkO2JhY2tncm91bmQ6I2YzNTIzZH0uYnRuLWxne2ZvbnQtc2l6ZToyMHB4O3BhZGRpbmc6MTRweCAyNHB4IDEycHh9LmJ0bi1zbXtmb250LXNpemU6MTZweDtwYWRkaW5nLXRvcDoxNHB4O3BhZGRpbmctYm90dG9tOjE0cHh9LmJ0bi14c3tmb250LXNpemU6MTRweDtwYWRkaW5nLXRvcDoxMnB4O3BhZGRpbmctYm90dG9tOjEycHh9LmJ0bi1ibG9ja3tkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowfS5idG4tYmxvY2srLmJ0bi1ibG9ja3ttYXJnaW4tdG9wOjVweH1pbnB1dFt0eXBlPWJ1dHRvbl0uYnRuLWJsb2NrLGlucHV0W3R5cGU9cmVzZXRdLmJ0bi1ibG9jayxpbnB1dFt0eXBlPXN1Ym1pdF0uYnRuLWJsb2Nre3dpZHRoOjEwMCV9LmJ0bi11cGxvYWR7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVufS5idG4tdXBsb2FkIGlucHV0W3R5cGU9ZmlsZV17cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDttYXJnaW46MDtmb250LXNpemU6NjAwJTtsaW5lLWhlaWdodDo2MDAlO3dpZHRoOmF1dG87aGVpZ2h0OmF1dG87b3BhY2l0eTowO2N1cnNvcjpwb2ludGVyfXRhYmxle2JvcmRlci1zcGFjaW5nOjA7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlfS5tYWlue21hcmdpbjoxOXB4IDI0cHggMzBweDtib3JkZXItcmFkaXVzOjRweDtiYWNrZ3JvdW5kOiNmZmY7Ym94LXNoYWRvdzowIDVweCAyNXB4IHJnYmEoMCwwLDAsLjM1KX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjQwMHB4KXsubWFpbnttYXJnaW46MXB4O2JveC1zaGFkb3c6bm9uZTtib3JkZXItdG9wOjFweCBzb2xpZCAjY2NjO2JvcmRlci1yYWRpdXM6MH19LmNsb3Nle3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxMHB4O3JpZ2h0OjEwcHg7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO3dpZHRoOjFlbTtmb250LXNpemU6MTJweDtsaW5lLWhlaWdodDoxO2JhY2tncm91bmQ6dXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0MlM0Z4bWwlMjB2ZXJzaW9uJTNEJTIyMS4wJTIyJTIwZW5jb2RpbmclM0QlMjJ1dGYtOCUyMiUzRiUzRSUwQSUzQ3N2ZyUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDEwMCUyMDEwMCUyMiUzRSUwQSUzQ2xpbmUlMjBmaWxsJTNEJTIybm9uZSUyMiUyMHN0cm9rZSUzRCUyMiUyMzAwMDAwMCUyMiUyMHN0cm9rZS13aWR0aCUzRCUyMjIwJTIyJTIweDElM0QlMjI1JTIyJTIweTElM0QlMjI1JTIyJTIweDIlM0QlMjI5NSUyMiUyMHkyJTNEJTIyOTUlMjIlMkYlM0UlMEElM0NsaW5lJTIwZmlsbCUzRCUyMm5vbmUlMjIlMjBzdHJva2UlM0QlMjIlMjMwMDAwMDAlMjIlMjBzdHJva2Utd2lkdGglM0QlMjIyMCUyMiUyMHgxJTNEJTIyOTUlMjIlMjB5MSUzRCUyMjUlMjIlMjB4MiUzRCUyMjUlMjIlMjB5MiUzRCUyMjk1JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBKSBuby1yZXBlYXQgMCAwL2NvdmVyO29wYWNpdHk6LjI7Y3Vyc29yOnBvaW50ZXJ9LmNsb3NlOmJlZm9yZXtjb250ZW50OiJcMDBhMCJ9LmNsb3NlOmhvdmVye29wYWNpdHk6LjV9QG1lZGlhIChtYXgtd2lkdGg6NDAwcHgpey5jbG9zZXtmb250LXNpemU6MTVweDt0b3A6MThweDtyaWdodDoxNHB4fX0ubG9nb3tkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3A7d2lkdGg6MWVtO2xpbmUtaGVpZ2h0OjE7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCUyMHZlcnNpb24lM0QlMjIxLjAlMjIlMjBlbmNvZGluZyUzRCUyMlVURi04JTIyJTNGJTNFJTBBJTNDIURPQ1RZUEUlMjBzdmclMjBQVUJMSUMlMjAlMjItJTJGJTJGVzNDJTJGJTJGRFREJTIwU1ZHJTIwMS4xJTJGJTJGRU4lMjIlMjAlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRkdyYXBoaWNzJTJGU1ZHJTJGMS4xJTJGRFREJTJGc3ZnMTEuZHRkJTIyJTNFJTBBJTNDIS0tJTIwQ3JlYXRvciUzQSUyMENvcmVsRFJBVyUyMFg3JTIwLS0lM0UlMEElM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHhtbCUzQXNwYWNlJTNEJTIycHJlc2VydmUlMjIlMjB3aWR0aCUzRCUyMjEwMHB4JTIyJTIwaGVpZ2h0JTNEJTIyMTAwcHglMjIlMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIwc3R5bGUlM0QlMjJzaGFwZS1yZW5kZXJpbmclM0FnZW9tZXRyaWNQcmVjaXNpb24lM0IlMjB0ZXh0LXJlbmRlcmluZyUzQWdlb21ldHJpY1ByZWNpc2lvbiUzQiUyMGltYWdlLXJlbmRlcmluZyUzQW9wdGltaXplUXVhbGl0eSUzQiUyMGZpbGwtcnVsZSUzQWV2ZW5vZGQlM0IlMjBjbGlwLXJ1bGUlM0FldmVub2RkJTIyJTBBdmlld0JveCUzRCUyMjAlMjAwJTIwMTAwJTIwMTAwJTIyJTBBJTIweG1sbnMlM0F4bGluayUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMTk5OSUyRnhsaW5rJTIyJTNFJTBBJTIwJTNDZGVmcyUzRSUwQSUyMCUyMCUzQ3N0eWxlJTIwdHlwZSUzRCUyMnRleHQlMkZjc3MlMjIlM0UlMEElMjAlMjAlMjAlM0MhJTVCQ0RBVEElNUIlMEElMjAlMjAlMjAlMjAuZmlsMCUyMCU3QmZpbGwlM0ElMjM0RkJFODUlN0QlMEElMjAlMjAlMjAlNUQlNUQlM0UlMEElMjAlMjAlM0MlMkZzdHlsZSUzRSUwQSUyMCUzQyUyRmRlZnMlM0UlMEElMjAlM0NnJTIwaWQlM0QlMjIlRDAlQTElRDAlQkIlRDAlQkUlRDAlQjlfeDAwMjBfMSUyMiUzRSUwQSUyMCUyMCUzQ21ldGFkYXRhJTIwaWQlM0QlMjJDb3JlbENvcnBJRF8wQ29yZWwtTGF5ZXIlMjIlMkYlM0UlMEElMjAlMjAlM0NwYXRoJTIwY2xhc3MlM0QlMjJmaWwwJTIyJTIwZCUzRCUyMk01MCUyMDFjMTYlMkMwJTIwMzUlMkMzJTIwNTAlMkMxMSUyMDAlMkMxNyUyMDElMkM2MCUyMC01MCUyQzg5JTIwLTUwJTJDLTI5JTIwLTUwJTJDLTcyJTIwLTUwJTJDLTg5JTIwMTYlMkMtOCUyMDM1JTJDLTExJTIwNTAlMkMtMTF6bTAlMjA4Yy0xNCUyQzAlMjAtMjklMkMzJTIwLTQxJTJDOCUyMDAlMkMxOCUyMDQlMkM1MCUyMDQxJTJDNzQlMjAzOCUyQy0yNCUyMDQxJTJDLTU2JTIwNDIlMkMtNzMlMjAtMTMlMkMtNiUyMC0yOCUyQy05JTIwLTQyJTJDLTl6JTIyJTJGJTNFJTBBJTIwJTIwJTNDcGF0aCUyMGNsYXNzJTNEJTIyZmlsMCUyMiUyMGQlM0QlMjJNNzclMjAyNWMyJTJDMCUyMDElMkMwJTIwMiUyQzFsLTMyJTIwNDFjMCUyQzAlMjAtMjIlMkMtMjYlMjAtMjMlMkMtMjYlMjAyJTJDLTElMjA4JTJDLTUlMjAxMyUyQzBsMTAlMjAxMiUyMDI3JTIwLTI3YzElMkMtMSUyMDIlMkMtMSUyMDMlMkMtMWwwJTIwMHolMjIlMkYlM0UlMEElMjAlM0MlMkZnJTNFJTBBJTNDJTJGc3ZnJTNFJTBBKSBuby1yZXBlYXQgMCAwO2JhY2tncm91bmQtc2l6ZToxMDAlfS5sb2dvOmJlZm9yZXtjb250ZW50OiJcMDBhMCJ9LmxvZ29fX3doaXRle2JhY2tncm91bmQtaW1hZ2U6dXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0MlM0Z4bWwlMjB2ZXJzaW9uJTNEJTIyMS4wJTIyJTIwZW5jb2RpbmclM0QlMjJVVEYtOCUyMiUzRiUzRSUwQSUzQ3N2ZyUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDEwMCUyMDEwMCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTUwJTJDMCUyMEM2NSUyQzAlMjA4My4yJTJDMy42JTIwOTguMSUyQzExLjQlMjBDOTguMSUyQzI4LjUlMjA5OC4zJTJDNzElMjA1MCUyQzEwMCUyMEMxLjclMkM3MSUyMDEuOSUyQzI4LjUlMjAxLjklMkMxMS40JTIwQzE2LjglMkMzLjYlMjAzNSUyQzAlMjA1MCUyQzAlMjB6JTIwTTUwJTJDOC40JTIwQzM2LjUlMkM4LjQlMjAyMiUyQzExLjQlMjAxMC4zJTJDMTYuNiUyMEMxMC42JTJDMzQuMiUyMDEzLjklMkM2Ni40JTIwNTAlMkM5MC4yJTIwQzg2LjElMkM2Ni4zJTIwODkuNCUyQzM0LjIlMjA4OS43JTJDMTYuOCUyMEM3OCUyQzExLjUlMjA2My41JTJDOC40JTIwNTAlMkM4LjQlMjB6JTIwTTc2LjQ0NiUyQzIzLjU3NyUyMEM3OC4zMDIlMkMyNC4wMzglMjA3Ny41NDUlMkMyMy42NjclMjA3OC44JTJDMjQuNSUyMEw0OC4yJTJDNjYuNCUyMEM0OC4yJTJDNjYuNCUyMDI2LjElMkM0MCUyMDI2JTJDNDAlMjBDMjcuNSUyQzM4LjklMjAzMy43JTJDMzQuOCUyMDM4LjMlMkM0MC4yJTIwTDQ3LjklMkM1MS45JTIwTDczLjUlMkMyNSUyMEM3NC4zODglMkMyNC4wMzElMjA3NS4yMTklMkMyMy44NTMlMjA3Ni40NDYlMkMyMy41NzclMjB6JTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSl9LmEtbG9nb3tkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3A7d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtwYWRkaW5nOjEwcHggMCAwO2ZvbnQtc2l6ZToyMHB4O3RleHQtYWxpZ246Y2VudGVyO2JvcmRlcjoxcHggc29saWQgI2NkY2RjZDtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kOiNmZmZ9LmEtbG9nb19fc21hbGx7d2lkdGg6MjRweDtoZWlnaHQ6MjRweDtmb250LXNpemU6MTJweDtwYWRkaW5nOjZweCAwIDB9LnRvb2x0aXB7cG9zaXRpb246cmVsYXRpdmV9LnRvb2x0aXA6YmVmb3Jle2Rpc3BsYXk6bm9uZTtjb250ZW50OmF0dHIoZGF0YS10aXRsZSk7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7bGVmdDo1MCU7d2lkdGg6MTcwcHg7bWFyZ2luOjdweCAwIDAgLTg1cHg7cGFkZGluZzo2cHggMCA1cHg7Zm9udC1zaXplOjEwcHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC13ZWlnaHQ6NTAwO2NvbG9yOiNmZmY7dGV4dC1hbGlnbjpjZW50ZXI7d2hpdGUtc3BhY2U6bm93cmFwO2JvcmRlci1yYWRpdXM6NHB4O2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuOCl9LnRvb2x0aXA6YWZ0ZXJ7ZGlzcGxheTpub25lO2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7dG9wOjEwMCU7bGVmdDo1MCU7bWFyZ2luOjNweCAwIDAgLTRweDtib3JkZXItYm90dG9tOjRweCBzb2xpZCByZ2JhKDAsMCwwLC44KTtib3JkZXItbGVmdDo0cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjRweCBzb2xpZCB0cmFuc3BhcmVudH0udG9vbHRpcDpob3ZlcjphZnRlciwudG9vbHRpcDpob3ZlcjpiZWZvcmV7ZGlzcGxheTpibG9ja30ubWFpbntwb3NpdGlvbjpyZWxhdGl2ZX0uaGVhZHtwYWRkaW5nOjE4cHggMjBweDtjdXJzb3I6bW92ZX0uaGVhZF90aXRsZXtmb250LXNpemU6MTZweDtmb250LXdlaWdodDo3MDA7Y29sb3I6IzM0MzQzNH0uaGVhZF90ZXh0e21hcmdpbjo0cHggMCAwO2ZvbnQtc2l6ZToxMnB4O2NvbG9yOiMzNDM0MzR9LmNvbnRlbnR7Ym9yZGVyLXRvcDoxcHggc29saWQgI2UwZGZkYn0uZm9vdHtwYWRkaW5nOjIwcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2UwZGZkYn0uZm9vdF9hY3Rpb257ZmxvYXQ6cmlnaHR9LmZvb3RfYWN0aW9uX2J0bntmb250LXNpemU6MH0uZm9vdF9hY3Rpb25fYnRuIC5idG4rLmJ0bnttYXJnaW4tbGVmdDoxMHB4fS5lbGVtZW50LXJ1bGV7cGFkZGluZzoyMHB4fS5lbGVtZW50LXJ1bGVfc2xpZGVye21hcmdpbjo1cHggMCA3cHg7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfUBtZWRpYSAobWF4LXdpZHRoOjQwMHB4KXsuZWxlbWVudC1ydWxlX3NsaWRlcntkaXNwbGF5Om5vbmV9fS5lbGVtZW50LXJ1bGVfZXhwYW5kLWxpbmt7Zm9udC1zaXplOjEycHg7bGluZS1oZWlnaHQ6MTVweDtmb250LXdlaWdodDo1MDA7Y3Vyc29yOnBvaW50ZXJ9LmVsZW1lbnQtcnVsZV9leHBhbmQtbGlua190eHR7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO2NvbG9yOiMzNmJhNTM7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2NjZjBkNH0uZWxlbWVudC1ydWxlX2V4cGFuZC1saW5rX2FycntkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3A7d2lkdGg6NXB4O2hlaWdodDo1cHg7bWFyZ2luOjNweCAwIDAgM3B4O2JvcmRlci1ib3R0b206MXB4IHNvbGlkICM5MWE3OTU7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICM5MWE3OTU7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7LW1zLXRyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNpdGlvbjouMnN9LmVsZW1lbnQtcnVsZV9leHBhbmQtbGluazpob3ZlciAuZWxlbWVudC1ydWxlX2V4cGFuZC1saW5rX3R4dHtjb2xvcjojMjU3ZjM5O2JvcmRlci1ib3R0b20tY29sb3I6IzkxZGZhMn0uZWxlbWVudC1ydWxlX2V4cGFuZC1saW5rLmFjdGl2ZSAuZWxlbWVudC1ydWxlX2V4cGFuZC1saW5rX2FycnttYXJnaW4tdG9wOjVweDstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoLTIyNWRlZyk7LW1zLXRyYW5zZm9ybTpyb3RhdGUoLTIyNWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgtMjI1ZGVnKX0uZWxlbWVudC1ydWxlX2Zvcm17aGVpZ2h0OjA7bWFyZ2luOjAgLTIwcHg7dHJhbnNpdGlvbjouMnMgaGVpZ2h0LC4ycyBtYXJnaW4tYm90dG9tO292ZXJmbG93OmhpZGRlbn0uZWxlbWVudC1ydWxlX2Zvcm0ub3BlbntoZWlnaHQ6YXV0bzttYXJnaW4tYm90dG9tOi0yMHB4fUBtZWRpYSAobWF4LXdpZHRoOjQwMHB4KXsuZWxlbWVudC1ydWxlX2Zvcm0ub3BlbntwYWRkaW5nOjIwcHg7cGFkZGluZy10b3A6MH19LmVsZW1lbnQtcnVsZV9mb3JtLWNvbnR7bWFyZ2luOjRweCAwIDA7cGFkZGluZzoyMHB4O2JvcmRlci10b3A6MXB4IHNvbGlkICNlMGRmZGI7YmFja2dyb3VuZDojZjRmNGVmfUBtZWRpYSAobWF4LXdpZHRoOjQwMHB4KXsuZWxlbWVudC1ydWxlX2Zvcm0tY29udHttYXJnaW4tdG9wOjB9fS5lbGVtZW50LXJ1bGVfZmllbGRzZXR7bWFyZ2luOjEwcHggMCAwfS5lbGVtZW50LXJ1bGVfZmllbGRzZXQ6Zmlyc3QtY2hpbGR7bWFyZ2luOjB9LmVsZW1lbnQtcnVsZV9tb3JlLS1tb2JpbGV7ZGlzcGxheTpub25lfUBtZWRpYSAobWF4LXdpZHRoOjQwMHB4KXsuZWxlbWVudC1ydWxlX21vcmUtLW1vYmlsZXtkaXNwbGF5OmJsb2NrfS5lbGVtZW50LXJ1bGVfbW9yZS0tbW9iaWxlIC5lbGVtZW50LXJ1bGVfZXhwYW5kLWxpbmt7ZGlzcGxheTpub25lfS5lbGVtZW50LXJ1bGVfbW9yZS0tbW9iaWxlICNhZGctY2FuY2Vse3dpZHRoOjEwNnB4O3BhZGRpbmc6MTBweCA3cHh9LmVsZW1lbnQtcnVsZV9tb3JlLS1tb2JpbGUgI2FkZy1hY2NlcHR7cGFkZGluZzoxMHB4IDZweH19LmFkZy1zbGlkZXtwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDo1MDBweDtoZWlnaHQ6NDRweDttYXJnaW46YXV0bzstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLDAsMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsMCwwKX0uYWRnLXNsaWRlLWNsdWUtbWF4LC5hZGctc2xpZGUtY2x1ZS1taW57cG9zaXRpb246YWJzb2x1dGU7dG9wOjE0cHg7bGVmdDotMzVweDt3aWR0aDozMHB4O2ZvbnQtc2l6ZToxMnB4O2ZvbnQtd2VpZ2h0OjUwMDtjb2xvcjojOGY5YjkyO2N1cnNvcjpwb2ludGVyfS5hZGctc2xpZGUtY2x1ZS1taW57bGVmdDphdXRvO3JpZ2h0Oi00MHB4O3RleHQtYWxpZ246cmlnaHR9LmFkZy1zbGlkZS1idG5ze2Rpc3BsYXk6bm9uZX0uYWRnLXNsaWRlLWJ0bntwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDozNnB4O2hlaWdodDozNnB4O2JvcmRlcjoycHggc29saWQgI2UyZTJlMjtib3JkZXItcmFkaXVzOjJweH0uYWRnLXNsaWRlLWJ0bjphZnRlcntjb250ZW50OiIiO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6OHB4O3RvcDoxNS4zcHg7d2lkdGg6MThweDtoZWlnaHQ6MnB4O2JhY2tncm91bmQtY29sb3I6IzRlNGU0ZTtib3JkZXItcmFkaXVzOjJweH0uYWRnLXNsaWRlLWJ0bi0tcGx1c3ttYXJnaW4tbGVmdDo5cHh9LmFkZy1zbGlkZS1idG4tLXBsdXM6YmVmb3Jle2NvbnRlbnQ6IiI7cG9zaXRpb246YWJzb2x1dGU7bGVmdDoxNnB4O3RvcDo4cHg7aGVpZ2h0OjE3cHg7d2lkdGg6MnB4O2JhY2tncm91bmQtY29sb3I6IzRlNGU0ZTtib3JkZXItcmFkaXVzOjJweH0udWktc2xpZGVyLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MjJweDt6LWluZGV4OjI7Y3Vyc29yOnBvaW50ZXJ9LnVpLXNsaWRlci1oYW5kbGU6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTt3aWR0aDozMHB4O2hlaWdodDozMHB4O21hcmdpbjotMTVweCAwIDAgLTE1cHg7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4xKTtib3JkZXItcmFkaXVzOjUwJTt0cmFuc2l0aW9uOi4yc30udWktc2xpZGVyLWhhbmRsZTphZnRlcntjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDttYXJnaW46LTEwcHggMCAwIC0xMHB4O2JhY2tncm91bmQ6IzM2YmE1Mztib3JkZXItcmFkaXVzOjUwJX0udWktc2xpZGVyLWhhbmRsZTpob3ZlcjphY3RpdmUsLnVpLXNsaWRlci1oYW5kbGU6aG92ZXI6YmVmb3Jle2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMTUpfS50aWNre3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDo0NHB4O2JvcmRlcjoyMHB4IHNvbGlkICNmZmY7Ym9yZGVyLWxlZnQ6MXB4IHNvbGlkICNmZmY7Ym9yZGVyLXJpZ2h0OjFweCBzb2xpZCAjZmZmfS5zZXR0aW5nc19maWVsZHNldHtwYWRkaW5nOjIwcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2UwZGZkYn0uc2V0dGluZ3NfZmllbGRzZXQ6Zmlyc3QtY2hpbGR7Ym9yZGVyOjB9LnNldHRpbmdzX2ZpZWxkc2V0X2xibHtmbG9hdDpsZWZ0O3dpZHRoOjEyNnB4O21hcmdpbjoxcHggMCAwO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtd2VpZ2h0OjUwMDtjb2xvcjojOGY5YjkyfS5zZXR0aW5nc19maWVsZHNldF9sYmxfX3Bvc3ttYXJnaW4tdG9wOjIxcHh9QG1lZGlhIChtYXgtd2lkdGg6NDAwcHgpey5zZXR0aW5nc19maWVsZHNldF9sYmxfX3Bvc3ttYXJnaW4tdG9wOjB9fUBtZWRpYSAobWF4LXdpZHRoOjQwMHB4KXsuc2V0dGluZ3NfZmllbGRzZXRfbGJse3dpZHRoOmF1dG99fS5zZXR0aW5nc19maWVsZHNldF92YWx7bWFyZ2luOjAgMCAwIDEyNnB4fUBtZWRpYSAobWF4LXdpZHRoOjQwMHB4KXsuc2V0dGluZ3NfZmllbGRzZXRfdmFse21hcmdpbjowfX1AbWVkaWEgKG1heC13aWR0aDo0MDBweCl7LnNldHRpbmdzX2ZpZWxkc2V0e2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotbXMtZmxleGJveDtkaXNwbGF5OmZsZXg7LXdlYmtpdC1ib3gtb3JpZW50OnZlcnRpY2FsOy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWw7LW1zLWZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4LWRpcmVjdGlvbjpjb2x1bW47cGFkZGluZzoxMHB4IDAgMjVweDtib3JkZXItdG9wOjB9fUBtZWRpYSAobWF4LXdpZHRoOjQwMHB4KXsuc2V0dGluZ3NfX2hvcml6b250YWx7ZGlzcGxheTotd2Via2l0LWJveDtkaXNwbGF5Oi1tcy1mbGV4Ym94O2Rpc3BsYXk6ZmxleDstd2Via2l0LWJveC1wYWNrOmp1c3RpZnk7LW1zLWZsZXgtcGFjazpqdXN0aWZ5O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO3BhZGRpbmctbGVmdDoxNXB4O3BhZGRpbmctcmlnaHQ6MTVweH19LmNob2ljZS1zaXple3Bvc2l0aW9uOnJlbGF0aXZlO2ZvbnQtc2l6ZToxNHB4fS5jaG9pY2Utc2l6ZV9maWVsZHttYXJnaW46OHB4IDAgMH1AbWVkaWEgKG1heC13aWR0aDo0MDBweCl7LmNob2ljZS1zaXplX2ZpZWxke21hcmdpbjowfX0uY2hvaWNlLXNpemVfZmllbGQ6Zmlyc3QtY2hpbGR7bWFyZ2luOjB9QG1lZGlhIChtYXgtd2lkdGg6NDAwcHgpey5jaG9pY2Utc2l6ZV9maWVsZDpmaXJzdC1jaGlsZHttYXJnaW4tcmlnaHQ6MTRweH19LmNob2ljZS1zaXplX2xvZ297ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjB9LmNob2ljZS1zaXplX2xvZ28gLmEtbG9nb3ttYXJnaW46NnB4IDAgMH0uY2hvaWNlLXNpemVfbG9nbyAuYS1sb2dvX19zbWFsbHttYXJnaW46MTRweCA4cHggMCAwfUBtZWRpYSAobWF4LXdpZHRoOjQwMHB4KXsuY2hvaWNlLXNpemVfbG9nb3t0b3A6MzBweDtyaWdodDpjYWxjKDMwJSl9fS5jaG9pY2Utc2l6ZV9pbnB1dDpjaGVja2Vkfi5jaG9pY2Utc2l6ZV9sb2dve2Rpc3BsYXk6YmxvY2t9QG1lZGlhIChtYXgtd2lkdGg6NDAwcHgpey5jaG9pY2Utc2l6ZV9ncm91cHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LW1zLWZsZXhib3g7ZGlzcGxheTpmbGV4fX1bY2xhc3NePXMtcG9zaXRpb24tYXJyLV17ZGlzcGxheTpibG9jazt3aWR0aDoxMXB4O2hlaWdodDoxMXB4O2JhY2tncm91bmQ6dXJsKCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIydXRmLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB4bWxucyUzQXhsaW5rJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYxOTk5JTJGeGxpbmslMjIlMEElMjAlMjAlMjAlMjAlMjB3aWR0aCUzRCUyMjQwMCUyMiUyMGhlaWdodCUzRCUyMjIwMCUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDQwMCUyMDIwMCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ2RlZnMlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NnJTIwaWQlM0QlMjJhcnIlMjIlM0UlMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0Nwb2x5Z29uJTIwcG9pbnRzJTNEJTIyMTguOCUyQzg0LjUlMjAxOC44JTJDMzIlMjA4Ni43JTJDMTAwJTIwMTAwJTJDODYuNyUyMDMyJTJDMTguOCUyMDg0LjUlMkMxOC44JTIwODQuNSUyQzAlMjAxOC44JTJDMCUyMDAlMkMwJTIwMCUyQzE4LjglMEElMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAwJTJDODQuNSUyMCUwOSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUyMCUyMCUyMCUyMCUzQyUyRmclM0UlMEElMjAlMjAlMjAlMjAlM0MlMkZkZWZzJTNFJTBBJTBBJTIwJTIwJTIwJTIwJTNDdXNlJTIweGxpbmslM0FocmVmJTNEJTIyJTIzYXJyJTIyJTIwZmlsbCUzRCUyMiUyM2FiYWJhYiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3VzZSUyMHhsaW5rJTNBaHJlZiUzRCUyMiUyM2FyciUyMiUyMGZpbGwlM0QlMjIlMjNhYmFiYWIlMjIlMjB0cmFuc2Zvcm0lM0QlMjJyb3RhdGUoOTAlMjAxMDAlMjAxMDApJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDdXNlJTIweGxpbmslM0FocmVmJTNEJTIyJTIzYXJyJTIyJTIwZmlsbCUzRCUyMiUyM2FiYWJhYiUyMiUyMHRyYW5zZm9ybSUzRCUyMnJvdGF0ZSgxODAlMjAxMDAlMjAxMDApJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDdXNlJTIweGxpbmslM0FocmVmJTNEJTIyJTIzYXJyJTIyJTIwZmlsbCUzRCUyMiUyM2FiYWJhYiUyMiUyMHRyYW5zZm9ybSUzRCUyMnJvdGF0ZSgyNzAlMjAxMDAlMjAxMDApJTIyJTJGJTNFJTBBJTBBJTIwJTIwJTIwJTIwJTNDdXNlJTIweGxpbmslM0FocmVmJTNEJTIyJTIzYXJyJTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyMHglM0QlMjIyMDAlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0N1c2UlMjB4bGluayUzQWhyZWYlM0QlMjIlMjNhcnIlMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTIweSUzRCUyMi0yMDAlMjIlMjB0cmFuc2Zvcm0lM0QlMjJyb3RhdGUoOTAlMjAxMDAlMjAxMDApJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDdXNlJTIweGxpbmslM0FocmVmJTNEJTIyJTIzYXJyJTIyJTIwZmlsbCUzRCUyMiUyM2ZmZiUyMiUyMHglM0QlMjItMjAwJTIyJTIwdHJhbnNmb3JtJTNEJTIycm90YXRlKDE4MCUyMDEwMCUyMDEwMCklMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0N1c2UlMjB4bGluayUzQWhyZWYlM0QlMjIlMjNhcnIlMjIlMjBmaWxsJTNEJTIyJTIzZmZmJTIyJTIweSUzRCUyMjIwMCUyMiUyMHRyYW5zZm9ybSUzRCUyMnJvdGF0ZSgyNzAlMjAxMDAlMjAxMDApJTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBIikgbm8tcmVwZWF0O2JhY2tncm91bmQtc2l6ZTo0NHB4IDIycHh9LnMtcG9zaXRpb24tYXJyLXRvcC1sZWZ0e2JhY2tncm91bmQtcG9zaXRpb246MCAwfS5zLXBvc2l0aW9uLWFyci10b3AtcmlnaHR7YmFja2dyb3VuZC1wb3NpdGlvbjotMTFweCAwfS5zLXBvc2l0aW9uLWFyci1ib3R0b20tbGVmdHtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgLTExcHh9LnMtcG9zaXRpb24tYXJyLWJvdHRvbS1yaWdodHtiYWNrZ3JvdW5kLXBvc2l0aW9uOi0xMXB4IC0xMXB4fS5jaGFuZ2UtcG9zaXRpb257cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO3dpZHRoOjcwcHg7bWFyZ2luOi0zcHggMCAwIC0zcHh9LmNoYW5nZS1wb3NpdGlvbl9pe2Zsb2F0OmxlZnQ7bWFyZ2luOjNweCAwIDAgM3B4fS5jaGFuZ2UtcG9zaXRpb25faW5wdXQ6Y2hlY2tlZCsuY2hhbmdlLXBvc2l0aW9uX2xhYmVse2JvcmRlci1jb2xvcjojMzZiYTUzO2JhY2tncm91bmQ6IzM2YmE1M30uY2hhbmdlLXBvc2l0aW9uX2lucHV0OmNoZWNrZWQrLmNoYW5nZS1wb3NpdGlvbl9sYWJlbCAucy1wb3NpdGlvbi1hcnItdG9wLWxlZnR7YmFja2dyb3VuZC1wb3NpdGlvbjotMjJweCAwfS5jaGFuZ2UtcG9zaXRpb25faW5wdXQ6Y2hlY2tlZCsuY2hhbmdlLXBvc2l0aW9uX2xhYmVsIC5zLXBvc2l0aW9uLWFyci10b3AtcmlnaHR7YmFja2dyb3VuZC1wb3NpdGlvbjotMzNweCAwfS5jaGFuZ2UtcG9zaXRpb25faW5wdXQ6Y2hlY2tlZCsuY2hhbmdlLXBvc2l0aW9uX2xhYmVsIC5zLXBvc2l0aW9uLWFyci1ib3R0b20tbGVmdHtiYWNrZ3JvdW5kLXBvc2l0aW9uOi0yMnB4IC0xMXB4fS5jaGFuZ2UtcG9zaXRpb25faW5wdXQ6Y2hlY2tlZCsuY2hhbmdlLXBvc2l0aW9uX2xhYmVsIC5zLXBvc2l0aW9uLWFyci1ib3R0b20tcmlnaHR7YmFja2dyb3VuZC1wb3NpdGlvbjotMzNweCAtMTFweH0uY2hhbmdlLXBvc2l0aW9uX2lucHV0OmNoZWNrZWR+LmNoYW5nZS1wb3NpdGlvbl92YWx7ZGlzcGxheTpibG9ja30uY2hhbmdlLXBvc2l0aW9uX2xhYmVse2Rpc3BsYXk6YmxvY2s7d2lkdGg6MzJweDtoZWlnaHQ6MzJweDttYXJnaW46MDtwYWRkaW5nOjlweCAwIDAgOXB4O2JvcmRlcjoxcHggc29saWQgI2RmZGVkYjtjdXJzb3I6cG9pbnRlcn0uY2hhbmdlLXBvc2l0aW9uX3ZhbHtkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7dG9wOjI3cHg7bGVmdDo4MnB4O2ZvbnQtc2l6ZToxMnB4O3doaXRlLXNwYWNlOm5vd3JhcH1AbWVkaWEgKG1heC13aWR0aDo0MDBweCl7LmNoYW5nZS1wb3NpdGlvbl92YWx7dG9wOjc0cHg7bGVmdDowfX0ud290LWluZGljYXRvcntkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3B9LndvdC1oaWRle2Rpc3BsYXk6bm9uZX0jV290RGVzY3JpcHRpb25UZXh0e3doaXRlLXNwYWNlOnByZS1saW5lfS5hZGctd290e3dpZHRoOjE4cHg7aGVpZ2h0OjE4cHg7ZGlzcGxheTpibG9jaztib3JkZXI6NXB4IHNvbGlkICMwMDA7Ym9yZGVyLXJhZGl1czo1MCV9LmFkZy13b3QtdW5rbm93bntib3JkZXItY29sb3I6I2NjY30uYWRnLXdvdC1yZWR7Ym9yZGVyLWNvbG9yOiNiNjAwMDB9LmFkZy13b3QtbGlnaHRSZWR7Ym9yZGVyLWNvbG9yOiNmMjE4MDB9LmFkZy13b3QteWVsbG93e2JvcmRlci1jb2xvcjojZmFjMDAwfS5hZGctd290LWxpZ2h0R3JlZW57Ym9yZGVyLWNvbG9yOiM2OWQyMjV9LmFkZy13b3QtZ3JlZW57Ym9yZGVyLWNvbG9yOiMwMGFlMTd9LmFkZy13b3QtY29uZmlkZW5jZXt3aWR0aDo1MnB4O2hlaWdodDoxOHB4O2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5hZGctd290LWNvbmZpZGVuY2UtMHtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzRDZENkQ2JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0Q2RDZENiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtMXtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzRDZENkQ2JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0Q2RDZENiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtMntiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzRDZENkQ2JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0Q2RDZENiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtM3tiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNzE3MTcxJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0Q2RDZENiUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtNHtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNzE3MTcxJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzcxNzE3MSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNENkQ2RDYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5hZGctd290LWNvbmZpZGVuY2UtNXtiYWNrZ3JvdW5kLWltYWdlOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA1MiUyMDE4JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNNS4zNTMlMkM3LjQxMiUyMEw1LjMwNCUyQzcuMzYzJTIwQzcuMTIxJTJDNy4xMjUlMjA4LjUyOSUyQzUuNTg3JTIwOC41MjklMkMzLjcwNiUyMEM4LjUyOSUyQzEuNjU5JTIwNi44NyUyQzAlMjA0LjgyNCUyQzAlMjBDMi43NzclMkMwJTIwMS4xMTglMkMxLjY1OSUyMDEuMTE4JTJDMy43MDYlMjBDMS4xMTglMkM1LjU3MiUyMDIuNTAyJTJDNy4wOTklMjA0LjI5NCUyQzcuMzU4JTIwTDQuMjk0JTJDNy40MTIlMjBDMS4xMTglMkM3LjQxMiUyMDAuMDU5JTJDOS41MjklMjAwLjA1OSUyQzkuNTI5JTIwTDEuMTE4JTJDMTUuODgyJTIwQzEuMTE4JTJDMTYuOTM4JTIwMi40NzUlMkMxNy44MDYlMjA0LjI0NCUyQzE3Ljk2NyUyMEw0LjI5NCUyQzE4JTIwTDUuMzUzJTJDMTglMjBMNS40MDMlMkMxNy45NjclMjBDNy4xNzIlMkMxNy44MDYlMjA4LjUyOSUyQzE2LjkzOCUyMDguNTI5JTJDMTUuODgyJTIwTDkuNTg4JTJDOS41MjklMjBDOS41ODglMkM5LjUyOSUyMDguNTI5JTJDNy40MTIlMjA1LjM1MyUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNS45NDElMkM3LjQxMiUyMEwxNS44OTIlMkM3LjM2MyUyMEMxNy43MDklMkM3LjEyNSUyMDE5LjExOCUyQzUuNTg3JTIwMTkuMTE4JTJDMy43MDYlMjBDMTkuMTE4JTJDMS42NTklMjAxNy40NTglMkMwJTIwMTUuNDEyJTJDMCUyMEMxMy4zNjUlMkMwJTIwMTEuNzA2JTJDMS42NTklMjAxMS43MDYlMkMzLjcwNiUyMEMxMS43MDYlMkM1LjU3MiUyMDEzLjA5JTJDNy4wOTklMjAxNC44ODIlMkM3LjM1OCUyMEwxNC44ODIlMkM3LjQxMiUyMEMxMS43MDYlMkM3LjQxMiUyMDEwLjY0NyUyQzkuNTI5JTIwMTAuNjQ3JTJDOS41MjklMjBMMTEuNzA2JTJDMTUuODgyJTIwQzExLjcwNiUyQzE2LjkzOCUyMDEzLjA2MyUyQzE3LjgwNiUyMDE0LjgzMyUyQzE3Ljk2NyUyMEwxNC44ODIlMkMxOCUyMEwxNS45NDElMkMxOCUyMEwxNS45OTElMkMxNy45NjclMjBDMTcuNzYlMkMxNy44MDYlMjAxOS4xMTglMkMxNi45MzglMjAxOS4xMTglMkMxNS44ODIlMjBMMjAuMTc2JTJDOS41MjklMjBDMjAuMTc2JTJDOS41MjklMjAxOS4xMTglMkM3LjQxMiUyMDE1Ljk0MSUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0yNi41MjklMkM3LjQxMiUyMEwyNi40ODElMkM3LjM2MyUyMEMyOC4yOTglMkM3LjEyNSUyMDI5LjcwNiUyQzUuNTg3JTIwMjkuNzA2JTJDMy43MDYlMjBDMjkuNzA2JTJDMS42NTklMjAyOC4wNDclMkMwJTIwMjYlMkMwJTIwQzIzLjk1MyUyQzAlMjAyMi4yOTQlMkMxLjY1OSUyMDIyLjI5NCUyQzMuNzA2JTIwQzIyLjI5NCUyQzUuNTcyJTIwMjMuNjc4JTJDNy4wOTklMjAyNS40NzElMkM3LjM1OCUyMEwyNS40NzElMkM3LjQxMiUyMEMyMi4yOTQlMkM3LjQxMiUyMDIxLjIzNSUyQzkuNTI5JTIwMjEuMjM1JTJDOS41MjklMjBMMjIuMjk0JTJDMTUuODgyJTIwQzIyLjI5NCUyQzE2LjkzOCUyMDIzLjY1MiUyQzE3LjgwNiUyMDI1LjQyMSUyQzE3Ljk2NyUyMEwyNS40NzElMkMxOCUyMEwyNi41MjklMkMxOCUyMEwyNi41NzklMkMxNy45NjclMjBDMjguMzQ4JTJDMTcuODA2JTIwMjkuNzA2JTJDMTYuOTM4JTIwMjkuNzA2JTJDMTUuODgyJTIwTDMwLjc2NSUyQzkuNTI5JTIwQzMwLjc2NSUyQzkuNTI5JTIwMjkuNzA2JTJDNy40MTIlMjAyNi41MjklMkM3LjQxMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNzE3MTcxJTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMzcuMTE4JTJDNy40MTIlMjBMMzcuMDY5JTJDNy4zNjMlMjBDMzguODg2JTJDNy4xMjUlMjA0MC4yOTQlMkM1LjU4NyUyMDQwLjI5NCUyQzMuNzA2JTIwQzQwLjI5NCUyQzEuNjU5JTIwMzguNjM1JTJDMCUyMDM2LjU4OCUyQzAlMjBDMzQuNTQyJTJDMCUyMDMyLjg4MiUyQzEuNjU5JTIwMzIuODgyJTJDMy43MDYlMjBDMzIuODgyJTJDNS41NzIlMjAzNC4yNjYlMkM3LjA5OSUyMDM2LjA1OSUyQzcuMzU4JTIwTDM2LjA1OSUyQzcuNDEyJTIwQzMyLjg4MiUyQzcuNDEyJTIwMzEuODI0JTJDOS41MjklMjAzMS44MjQlMkM5LjUyOSUyMEwzMi44ODIlMkMxNS44ODIlMjBDMzIuODgyJTJDMTYuOTM4JTIwMzQuMjQlMkMxNy44MDYlMjAzNi4wMDklMkMxNy45NjclMjBMMzYuMDU5JTJDMTglMjBMMzcuMTE4JTJDMTglMjBMMzcuMTY3JTJDMTcuOTY3JTIwQzM4LjkzNyUyQzE3LjgwNiUyMDQwLjI5NCUyQzE2LjkzOCUyMDQwLjI5NCUyQzE1Ljg4MiUyMEw0MS4zNTMlMkM5LjUyOSUyMEM0MS4zNTMlMkM5LjUyOSUyMDQwLjI5NCUyQzcuNDEyJTIwMzcuMTE4JTJDNy40MTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzcxNzE3MSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTQ3LjcwNiUyQzcuNDEyJTIwTDQ3LjY1NyUyQzcuMzYzJTIwQzQ5LjQ3NCUyQzcuMTI1JTIwNTAuODgyJTJDNS41ODclMjA1MC44ODIlMkMzLjcwNiUyMEM1MC44ODIlMkMxLjY1OSUyMDQ5LjIyMyUyQzAlMjA0Ny4xNzYlMkMwJTIwQzQ1LjEzJTJDMCUyMDQzLjQ3MSUyQzEuNjU5JTIwNDMuNDcxJTJDMy43MDYlMjBDNDMuNDcxJTJDNS41NzIlMjA0NC44NTQlMkM3LjA5OSUyMDQ2LjY0NyUyQzcuMzU4JTIwTDQ2LjY0NyUyQzcuNDEyJTIwQzQzLjQ3MSUyQzcuNDEyJTIwNDIuNDEyJTJDOS41MjklMjA0Mi40MTIlMkM5LjUyOSUyMEw0My40NzElMkMxNS44ODIlMjBDNDMuNDcxJTJDMTYuOTM4JTIwNDQuODI4JTJDMTcuODA2JTIwNDYuNTk3JTJDMTcuOTY3JTIwTDQ2LjY0NyUyQzE4JTIwTDQ3LjcwNiUyQzE4JTIwTDQ3Ljc1NiUyQzE3Ljk2NyUyMEM0OS41MjUlMkMxNy44MDYlMjA1MC44ODIlMkMxNi45MzglMjA1MC44ODIlMkMxNS44ODIlMjBMNTEuOTQxJTJDOS41MjklMjBDNTEuOTQxJTJDOS41MjklMjA1MC44ODIlMkM3LjQxMiUyMDQ3LjcwNiUyQzcuNDEyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM3MTcxNzElMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5jb25maWRlbmNlLWluZGljYXRpb24sLndvdC1pbmRpY2F0b3J7dGV4dC1kZWNvcmF0aW9uOm5vbmU7dmVydGljYWwtYWxpZ246bWlkZGxlfS5jb25maWRlbmNlLWluZGljYXRpb246aG92ZXIsLndvdC1pbmRpY2F0b3I6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmNvbmZpZGVuY2UtaW5kaWNhdGlvbntkaXNwbGF5OmlubGluZS1ibG9ja30ud290LWxvZ297ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO3dpZHRoOjMxcHg7aGVpZ2h0OjEycHg7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCUyMHZlcnNpb24lM0QlMjIxLjAlMjIlMjBlbmNvZGluZyUzRCUyMlVURi04JTIyJTNGJTNFJTBBJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMzglMjAxNSUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTIxLjkxJTJDMS4wODMlMjBDMTguMDA4JTJDMS4wODMlMjAxNC44NDYlMkM0LjA3JTIwMTQuODQ2JTJDNy43NTglMjBDMTQuODQ2JTJDMTEuNDQ1JTIwMTguMDA4JTJDMTQuNDMyJTIwMjEuOTElMkMxNC40MzIlMjBDMjUuODEzJTJDMTQuNDMyJTIwMjguOTc3JTJDMTEuNDQ1JTIwMjguOTc3JTJDNy43NTglMjBDMjguOTc4JTJDNC4wNyUyMDI1LjgxMyUyQzEuMDgzJTIwMjEuOTElMkMxLjA4MyUyMHolMjBNMjEuNzcxJTJDMTEuOSUyMEMxOS41JTJDMTEuOSUyMDE3LjY1NyUyQzEwLjA1NiUyMDE3LjY1NyUyQzcuNzgzJTIwQzE3LjY1NyUyQzUuNTA4JTIwMTkuNTAxJTJDMy42NjQlMjAyMS43NzElMkMzLjY2NCUyMEMyNC4wNDUlMkMzLjY2NCUyMDI1Ljg4NiUyQzUuNTA4JTIwMjUuODg2JTJDNy43ODMlMjBDMjUuODg2JTJDMTAuMDU3JTIwMjQuMDQ1JTJDMTEuOSUyMDIxLjc3MSUyQzExLjklMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzc0QjAzRSUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTE2Ljc1MSUyQzAuNjQyJTIwTDE3LjAzMSUyQzAlMjBMMTQuMDYzJTJDMCUyMEwxMS4yNyUyQzglMjBMOC42NDglMkMwJTIwTDguMjcyJTJDMCUyMEw1LjY1JTJDOCUyMEwzJTJDMCUyMEwwLjAzMSUyQzAlMjBMNC45JTJDMTMuNDg2JTIwQzQuOSUyQzEzLjQ4NiUyMDUuMDc4JTJDMTMuODYlMjA1LjI3NSUyQzEzLjg2JTIwQzUuNDUxJTJDMTMuODYlMjA1LjY0OSUyQzEzLjQ4NiUyMDUuNjQ5JTJDMTMuNDg2JTIwTDguNDQ1JTJDNi40MDYlMjBMMTEuMjY5JTJDMTMuNDg2JTIwQzExLjI2OSUyQzEzLjQ4NiUyMDExLjQ1NSUyQzEzLjg2JTIwMTEuNjQzJTJDMTMuODYlMjBDMTEuODI5JTJDMTMuODYlMjAxMi4wMTglMkMxMy40ODYlMjAxMi4wMTglMkMxMy40ODYlMjBMMTMuNjE0JTJDOS4wNjclMjBDMTMuNDQ1JTJDOC40MzMlMjAxMy4zNDUlMkM3Ljc3MyUyMDEzLjM0NSUyQzcuMDg5JTIwQzEzLjM0NiUyQzQuNDUzJTIwMTQuNjg2JTJDMi4xMTglMjAxNi43NTElMkMwLjY0MiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzRUUzNDI4JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMjcuMDMxJTJDMCUyMEwyNy4wMzElMkMwLjYxMyUyMEMyNy45NDQlMkMxLjI1OCUyMDI4LjcxNSUyQzIuMDY3JTIwMjkuMjk1JTJDMyUyMEwzMS4wMzElMkMzJTIwTDMxLjAzMSUyQzE0JTIwTDM0LjAzMSUyQzE0JTIwTDM0LjAzMSUyQzMlMjBMMzguMDMxJTJDMyUyMEwzOC4wMzElMkMwJTIwTDI3LjAzMSUyQzAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0YwODYxNSUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSkgbm8tcmVwZWF0IDAgMC9jb3ZlcjttYXJnaW4tdG9wOjNweH0ubWVudS1oZWFke3BhZGRpbmc6MThweCAyMHB4O2N1cnNvcjptb3ZlO3RvdWNoLWFjdGlvbjpub25lOy1tcy10b3VjaC1hY3Rpb246bm9uZX0ubWVudS1oZWFkX3RpdGxle2ZvbnQtc2l6ZToxNnB4O2ZvbnQtd2VpZ2h0OjcwMDtjb2xvcjojMzQzNDM0fS5tZW51LWhlYWRfbmFtZXtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjp0b3A7dGV4dC1vdmVyZmxvdzplbGxpcHNpcztvdmVyZmxvdzpoaWRkZW47d2hpdGUtc3BhY2U6bm93cmFwO21heC13aWR0aDoyMzBweDtsaW5lLWhlaWdodDoyNnB4fS5tZW51LWhlYWRfdGV4dHttYXJnaW46NHB4IDEwcHggMCAwO2ZvbnQtc2l6ZToxMnB4O2NvbG9yOiMzNDM0MzR9Lm1lbnUtZmlsdGVye3dpZHRoOjEwMCU7ZGlzcGxheTp0YWJsZTtwYWRkaW5nOjIwcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2UwZGZkYn0ubWVudS1maWx0ZXJfbGJse2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NTAwO2NvbG9yOiM4ZjliOTJ9Lm1lbnUtZmlsdGVyX3ZhbHtkaXNwbGF5OnRhYmxlLWNlbGw7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tZW51LWZpbHRlcl9sYWJlbHtwb3NpdGlvbjpyZWxhdGl2ZTtmbG9hdDpyaWdodDt3aWR0aDo0M3B4O2hlaWdodDoyMnB4O21hcmdpbjowO2JvcmRlci1yYWRpdXM6NHB4O2JhY2tncm91bmQ6I2U4NTAzNztjdXJzb3I6cG9pbnRlcjtvdmVyZmxvdzpoaWRkZW59Lm1lbnUtZmlsdGVyX2xhYmVsOmhvdmVye2JhY2tncm91bmQ6I2VkNzg2NX0ubWVudS1maWx0ZXJfbGFiZWw6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7dG9wOjdweDtsZWZ0Oi0xNHB4O3dpZHRoOjEwcHg7aGVpZ2h0OjVweDtib3JkZXItYm90dG9tOjJweCBzb2xpZCAjZmZmO2JvcmRlci1sZWZ0OjJweCBzb2xpZCAjZmZmOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpOy1tcy10cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5tZW51LWZpbHRlcl9sYWJlbDphZnRlcntjb250ZW50OicrJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6OXB4O3JpZ2h0Oi0zcHg7d2lkdGg6MTNweDtoZWlnaHQ6MjBweDtmb250LXNpemU6MjBweDtsaW5lLWhlaWdodDowO2ZvbnQtd2VpZ2h0OjQwMDtjb2xvcjojZmZmOy13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpOy1tcy10cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfS5tZW51LWZpbHRlcl9sYWJlbC5hbmltYXRlLC5tZW51LWZpbHRlcl9sYWJlbC5hbmltYXRlIC5tZW51LWZpbHRlcl9oYW5kbGUsLm1lbnUtZmlsdGVyX2xhYmVsLmFuaW1hdGU6YWZ0ZXIsLm1lbnUtZmlsdGVyX2xhYmVsLmFuaW1hdGU6YmVmb3Jle3RyYW5zaXRpb246LjJzfS5tZW51LWZpbHRlcl9oYW5kbGV7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MjBweDtoZWlnaHQ6MjBweDt0b3A6MXB4O2xlZnQ6MXB4O2JvcmRlci1yYWRpdXM6NHB4O2JhY2tncm91bmQ6I2ZmZn0ubWVudS1maWx0ZXJfaW5wdXQ6Y2hlY2tlZCsubWVudS1maWx0ZXJfbGFiZWx7YmFja2dyb3VuZDojMzZiYTUzfS5tZW51LWZpbHRlcl9pbnB1dDpjaGVja2VkKy5tZW51LWZpbHRlcl9sYWJlbDpob3ZlcntiYWNrZ3JvdW5kOiM1NWNlNzB9Lm1lbnUtZmlsdGVyX2lucHV0OmNoZWNrZWQrLm1lbnUtZmlsdGVyX2xhYmVsOmJlZm9yZXtsZWZ0OjdweH0ubWVudS1maWx0ZXJfaW5wdXQ6Y2hlY2tlZCsubWVudS1maWx0ZXJfbGFiZWw6YWZ0ZXJ7cmlnaHQ6LTI0cHh9Lm1lbnUtZmlsdGVyX2lucHV0OmNoZWNrZWQrLm1lbnUtZmlsdGVyX2xhYmVsIC5tZW51LWZpbHRlcl9oYW5kbGV7bGVmdDoyMnB4fVtjbGFzcyo9IiBpLW1lbnUtIl0sW2NsYXNzXj1pLW1lbnUtXXtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7d2lkdGg6MjRweDtoZWlnaHQ6MjRweH0uaS1tZW51LXRpbWV7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCUyMHZlcnNpb24lM0QlMjIxLjAlMjIlMjBlbmNvZGluZyUzRCUyMlVURi04JTIyJTNGJTNFJTBBJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjQlMjAyNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTEzJTJDMTMuNzExJTIwTDE2LjY0NSUyQzE3LjM1NSUyMEwxNS4yMzElMkMxOC43NyUyMEwxMS4yOTMlMkMxNC44MzIlMjBMMTElMkMxNCUyMEwxMSUyQzE0JTIwTDExJTJDNyUyMEwxMyUyQzclMjBMMTMlMkMxMy43MTElMjB6JTIwTTEzJTJDMy4wNSUyMEwxMyUyQzIlMjBMMTUlMkMyJTIwTDE1JTJDMCUyMEw5JTJDMCUyMEw5JTJDMiUyMEwxMSUyQzIlMjBMMTElMkMzLjA1JTIwQzUuNjclMkMzLjU1NSUyMDEuNSUyQzguMDM4JTIwMS41JTJDMTMuNSUyMEMxLjUlMkMxOS4yOTklMjA2LjIwMSUyQzI0JTIwMTIlMkMyNCUyMEMxNy43OTklMkMyNCUyMDIyLjUlMkMxOS4yOTklMjAyMi41JTJDMTMuNSUyMEMyMi41JTJDOC4wMzglMjAxOC4zMyUyQzMuNTU1JTIwMTMlMkMzLjA1JTIweiUyME0xMiUyQzIyJTIwQzcuMzEzJTJDMjIlMjAzLjUlMkMxOC4xODclMjAzLjUlMkMxMy41JTIwQzMuNSUyQzguODEzJTIwNy4zMTMlMkM1JTIwMTIlMkM1JTIwQzE2LjY4NyUyQzUlMjAyMC41JTJDOC44MTMlMjAyMC41JTJDMTMuNSUyMEMyMC41JTJDMTguMTg3JTIwMTYuNjg3JTJDMjIlMjAxMiUyQzIyJTIweiUyMiUyMGZpbGwlM0QlMjIlMjNCNEMxQjYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5pLW1lbnUtdGltZS1oe2JhY2tncm91bmQ6dXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0MlM0Z4bWwlMjB2ZXJzaW9uJTNEJTIyMS4wJTIyJTIwZW5jb2RpbmclM0QlMjJVVEYtOCUyMiUzRiUzRSUwQSUzQ3N2ZyUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDI0JTIwMjQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xMyUyQzEzLjcxMSUyMEwxNi42NDUlMkMxNy4zNTUlMjBMMTUuMjMxJTJDMTguNzclMjBMMTEuMjkzJTJDMTQuODMyJTIwTDExJTJDMTQlMjBMMTElMkMxNCUyMEwxMSUyQzclMjBMMTMlMkM3JTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0RkJCNTQlMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xMyUyQzMuMDUlMjBMMTMlMkMyJTIwTDE1JTJDMiUyMEwxNSUyQzAlMjBMOSUyQzAlMjBMOSUyQzIlMjBMMTElMkMyJTIwTDExJTJDMy4wNSUyMEM1LjY3JTJDMy41NTUlMjAxLjUlMkM4LjAzOCUyMDEuNSUyQzEzLjUlMjBDMS41JTJDMTkuMjk5JTIwNi4yMDElMkMyNCUyMDEyJTJDMjQlMjBDMTcuNzk5JTJDMjQlMjAyMi41JTJDMTkuMjk5JTIwMjIuNSUyQzEzLjUlMjBDMjIuNSUyQzguMDM4JTIwMTguMzMlMkMzLjU1NSUyMDEzJTJDMy4wNSUyMHolMjBNMTIlMkMyMiUyMEM3LjMxMyUyQzIyJTIwMy41JTJDMTguMTg3JTIwMy41JTJDMTMuNSUyMEMzLjUlMkM4LjgxMyUyMDcuMzEzJTJDNSUyMDEyJTJDNSUyMEMxNi42ODclMkM1JTIwMjAuNSUyQzguODEzJTIwMjAuNSUyQzEzLjUlMjBDMjAuNSUyQzE4LjE4NyUyMDE2LjY4NyUyQzIyJTIwMTIlMkMyMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNTU2MjU3JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBKX0uaS1tZW51LXNlbGVjdHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTAuNjY3JTJDMjEuMDY3JTIwQzUuOTc3JTJDMjEuMDY3JTIwMi4wOTYlMkMyMS4wNjclMjAxLjYlMkMyMS4wNjclMjBDMCUyQzIxLjA2NyUyMDAlMkMxOS40NjclMjAwJTJDMTkuNDY3JTIwTDAlMkMyLjQlMjBDMCUyQzIuNCUyMDAlMkMwLjglMjAxLjYlMkMwLjglMjBDMi42NjclMkMwLjglMjAyMC44JTJDMC44JTIwMjEuODY3JTJDMC44JTIwQzIzLjQ2NyUyQzAuOCUyMDIzLjQ2NyUyQzIuNCUyMDIzLjQ2NyUyQzIuNCUyMEwyMy40NjclMkMxMy4wNjclMjBMMjEuMzMzJTJDMTIlMjBMMjEuMzMzJTJDMi45MzMlMjBMMi4xMzMlMkMyLjkzMyUyMEwyLjEzMyUyQzE4LjkzMyUyMEwxMC42NjclMkMxOC45MzMlMjBMMTAuNjY3JTJDMjEuMDY3JTIweiUyME0xNi41MzMlMkMxOS40NjclMjBMMTkuMDc3JTJDMjIuOTQxJTIwTDIxLjU2NSUyQzIxLjI1NCUyMEwxOS4wNDIlMkMxNy43MTUlMjBMMjQlMkMxNS4xOTklMjBMMTIuOCUyQzExLjQ2NyUyMEwxMi44JTJDMjMuMiUyMEwxNi41MzMlMkMxOS40NjclMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0I0QzFCNiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSl9LmktbWVudS1zZWxlY3QtaHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTAuNjY3JTJDMjEuMDY3JTIwQzUuOTc3JTJDMjEuMDY3JTIwMi4wOTYlMkMyMS4wNjclMjAxLjYlMkMyMS4wNjclMjBDMCUyQzIxLjA2NyUyMDAlMkMxOS40NjclMjAwJTJDMTkuNDY3JTIwTDAlMkMyLjQlMjBDMCUyQzIuNCUyMDAlMkMwLjglMjAxLjYlMkMwLjglMjBDMi42NjclMkMwLjglMjAyMC44JTJDMC44JTIwMjEuODY3JTJDMC44JTIwQzIzLjQ2NyUyQzAuOCUyMDIzLjQ2NyUyQzIuNCUyMDIzLjQ2NyUyQzIuNCUyMEwyMy40NjclMkMxMy4wNjclMjBMMjEuMzMzJTJDMTIlMjBMMjEuMzMzJTJDMi45MzMlMjBMMi4xMzMlMkMyLjkzMyUyMEwyLjEzMyUyQzE4LjkzMyUyMEwxMC42NjclMkMxOC45MzMlMjBMMTAuNjY3JTJDMjEuMDY3JTIweiUyMiUyMGZpbGwlM0QlMjIlMjM1NTYyNTclMjIlMkYlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xNi41MzMlMkMxOS40NjclMjBMMTkuMDc3JTJDMjIuOTQxJTIwTDIxLjU2NSUyQzIxLjI1NCUyMEwxOS4wNDIlMkMxNy43MTUlMjBMMjQlMkMxNS4xOTklMjBMMTIuOCUyQzExLjQ2NyUyMEwxMi44JTJDMjMuMiUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNEZCQjU0JTIyJTJGJTNFJTBBJTNDJTJGc3ZnJTNFJTBBKX0uaS1tZW51LWNvbXBsYWludHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMjMuNTI2JTJDMTAuMzg5JTIwQzIzLjUyMSUyQzEwLjM3OCUyMDIzLjUxNSUyQzEwLjM2NiUyMDIzLjUxJTJDMTAuMzU0JTIwQzIzLjc2MSUyQzEwLjA0MSUyMDI0JTJDOS41OTYlMjAyNCUyQzklMjBDMjQlMkM4LjQ1MSUyMDIzLjc5OCUyQzguMDQlMjAyMy41NDIlMkM3LjUyJTIwQzIzLjU0MiUyQzcuNTE5JTIwMjMuNTQxJTJDNy41MTklMjAyMy41NCUyQzcuNTE3JTIwQzI0LjAzOSUyQzYuODE1JTIwMjQuMTY1JTJDNS45NzYlMjAyMy44MzglMkM1LjIxMyUyMEMyMy43MjklMkM0Ljk1OCUyMDIzLjU4MyUyQzQuNjE2JTIwMjIuMjI5JTJDMy4yMiUyMEMyMi4xMzglMkMyLjkwOCUyMDIyJTJDMi41MjklMjAyMS43ODklMkMyLjEwNiUyMEMyMS4wNjQlMkMwLjY1NiUyMDE5LjE0MiUyQzAuMTcyJTIwMTguMzUlMkMwLjAzMSUyMEwxOC4xNzUlMkMwJTIwTDE3Ljk5OCUyQzAlMjBMMTIuODA0JTJDMC4wMDQlMjBMMTIuNzM2JTJDMC4wMDQlMjBMMTIuNjY5JTJDMC4wMDglMjBDOS43OTglMkMwLjIwNCUyMDguMTgyJTJDMC43MjclMjA3LjI2OSUyQzEuMjY5JTIwTDclMkMxJTIwQzclMkMxJTIwMyUyQzElMjAyJTJDMSUyMEMxJTJDMSUyMDElMkMyJTIwMSUyQzIlMjBMLTAlMkMxMiUyMEMtMCUyQzEyJTIwLTAlMkMxMyUyMDElMkMxMyUyMEMyJTJDMTMlMjA3JTJDMTMlMjA3JTJDMTMlMjBMNy40MTYlMkMxMi4xNjglMjBDNy43MjYlMkMxMi40ODMlMjA4LjE2NyUyQzEzLjExMyUyMDguMzI0JTJDMTMuNDMyJTIwQzguNDU5JTJDMTMuODU0JTIwOC43NjIlMkMxNC40NjUlMjA5LjQ2OCUyQzE1LjgxNiUyMEM5LjU3OCUyQzE2LjAyNyUyMDkuNjc1JTJDMTYuMjEyJTIwOS43NDIlMkMxNi4zNDQlMjBDMTAuMTYzJTJDMTcuMTczJTIwMTAuODI4JTJDMTcuNjYyJTIwMTEuMjY3JTJDMTcuOTg2JTIwQzExLjMyMSUyQzE4LjAyNSUyMDExLjM4OCUyQzE4LjA3NSUyMDExLjQzNyUyQzE4LjExMiUyMEMxMS41MTMlMkMxOC4yNCUyMDExLjYzOCUyQzE4LjQ4OCUyMDExLjcyNSUyQzE4LjY2MiUyMEMxMS45MTMlMkMxOS4wMzUlMjAxMi4xMjUlMkMxOS40NTUlMjAxMi4zODklMkMxOS44NjglMjBDMTIuNTM3JTJDMjAuMTc2JTIwMTIuNzc4JTJDMjEuMjYlMjAxMi44OTklMkMyMi4xNjclMjBMMTIuOTg4JTJDMjIuODM4JTIwTDEzLjQ2NiUyQzIzLjMxOCUyMEMxMy44ODQlMkMyMy43MzYlMjAxNC40ODMlMkMyMy45NzclMjAxNS4xMSUyQzIzLjk3NyUyMEMxNS43NTYlMkMyMy45NzclMjAxNi4zOTIlMkMyMy43MzUlMjAxNy4wMDElMkMyMy4yNTYlMjBDMTguNTIxJTJDMjIuMDYlMjAxOC44NDQlMkMxOC4zNTElMjAxOC4zNjElMkMxNy4wMzclMjBDMTguMTc0JTJDMTYuNTMlMjAxNy44NDglMkMxNi4wMzIlMjAxNy41MDMlMkMxNS41MDUlMjBDMTcuNDE0JTJDMTUuMzY5JTIwMTcuMjk1JTJDMTUuMTg2JTIwMTcuMTc4JTJDMTQuOTk5JTIwQzE3LjMyNyUyQzE1LjAwNSUyMDE3LjU5OCUyQzE1LjAxOSUyMDE3LjgyNCUyQzE1LjAzMSUyMEMxOC40NjElMkMxNS4wNjYlMjAxOS4yNTQlMkMxNS4xMSUyMDE5LjkzOCUyQzE1LjExJTIwQzIwLjc4NiUyQzE1LjExJTIwMjEuNDIlMkMxNS4wNTElMjAyMS45NTklMkMxNC43NTclMjBDMjIuNTY3JTJDMTQuNDI0JTIwMjQuMTg0JTJDMTMuNTQyJTIwMjMuOTg4JTJDMTEuNzgxJTIwQzIzLjkzNiUyQzExLjMxNCUyMDIzLjc1NSUyQzEwLjkwNiUyMDIzLjUyNiUyQzEwLjM4OSUyMHolMjBNMjEuNDE2JTJDNy42MTQlMjBDMjEuNDYlMkM3LjkyMyUyMDIyJTJDOC44MjMlMjAyMiUyQzklMjBDMjIlMkM5LjE3NyUyMDIxLjQyMiUyQzkuNDYlMjAyMS4yODklMkM5Ljg1OCUyMEMyMS4xNTYlMkMxMC4yNTUlMjAyMS45NTYlMkMxMS42MDIlMjAyMiUyQzEyJTIwQzIyLjA0NCUyQzEyLjM5OCUyMDIxLjQ4NiUyQzEyLjczNCUyMDIxJTJDMTMlMjBDMjAuODUxJTJDMTMuMDgyJTIwMjAuNDQxJTJDMTMuMTA5JTIwMTkuOTM4JTJDMTMuMTA5JTIwQzE4LjkxNCUyQzEzLjEwOSUyMDE3LjUlMkMxMi45OTYlMjAxNy4wOTUlMkMxMi45OTYlMjBDMTcuMDUlMkMxMi45OTYlMjAxNy4wMTglMkMxMi45OTclMjAxNyUyQzEzJTIwQzE2LjczNSUyQzEzLjA0NCUyMDE1LjAzJTJDMTMuMjY0JTIwMTQuODIlMkMxNC4yMjIlMjBDMTQuNjElMkMxNS4xODIlMjAxNi4xNzQlMkMxNi44ODUlMjAxNi40ODQlMkMxNy43MjYlMjBDMTYuNzkzJTJDMTguNTY2JTIwMTYuMzgzJTJDMjEuMTk2JTIwMTUuNzY1JTJDMjEuNjgzJTIwQzE1LjQ2OSUyQzIxLjkxNSUyMDE1LjI1NCUyQzIxLjk3NiUyMDE1LjExJTJDMjEuOTc2JTIwQzE0Ljk1MyUyQzIxLjk3NiUyMDE0Ljg4MSUyQzIxLjkwMyUyMDE0Ljg4MSUyQzIxLjkwMyUyMEMxNC44ODElMkMyMS45MDMlMjAxNC41NzIlMkMxOS41NTklMjAxNC4wODYlMkMxOC44MDglMjBDMTMuNiUyQzE4LjA1NiUyMDEzLjI0NyUyQzE3LjA4MyUyMDEyLjg5NCUyQzE2LjcyOSUyMEMxMi41NCUyQzE2LjM3NSUyMDExLjgzMyUyQzE2LjA0NCUyMDExLjUyNCUyQzE1LjQzNiUyMEMxMS4yMTUlMkMxNC44MjglMjAxMC4zMDglMkMxMy4xNDQlMjAxMC4yMiUyQzEyLjc5JTIwQzEwLjEzMiUyQzEyLjQzNyUyMDguOTc3JTJDMTAuNTM4JTIwOC4wNDklMkMxMC4xOTMlMjBMOCUyQzMuMzA4JTIwTDglMkMzLjIwNSUyMEM4LjAwNyUyQzMuMTk3JTIwOC44MTIlMkMyLjI3NyUyMDEyLjgwNiUyQzIuMDA0JTIwTDE4JTJDMiUyMEMxOCUyQzIlMjAxOS42NDYlMkMyLjI5MyUyMDIwJTJDMyUyMEMyMC4zNTQlMkMzLjcwOCUyMDIwLjQwMyUyQzQuMjE0JTIwMjAuNDAzJTJDNC4yMTQlMjBDMjAuNDAzJTJDNC4yMTQlMjAyMS44NjglMkM1LjY5MSUyMDIyJTJDNiUyMEMyMi4xMzIlMkM2LjMxJTIwMjEuNTUyJTJDNi42OTElMjAyMS41NTIlMkM2LjY5MSUyMEMyMS41NTIlMkM2LjY5MSUyMDIxLjM3MiUyQzcuMzA0JTIwMjEuNDE2JTJDNy42MTQlMjB6JTIyJTIwZmlsbCUzRCUyMiUyM0I0QzFCNiUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSl9LmktbWVudS1jb21wbGFpbnQtaHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTglMkMyJTIwQzE4JTJDMiUyMDE5LjY0NiUyQzIuMjkyJTIwMjAlMkMzJTIwQzIwLjM1NCUyQzMuNzA3JTIwMjAuNDAzJTJDNC4yMTQlMjAyMC40MDMlMkM0LjIxNCUyMEMyMC40MDMlMkM0LjIxNCUyMDIxLjg2OCUyQzUuNjklMjAyMiUyQzYlMjBDMjIuMTMyJTJDNi4zMDklMjAyMS41NTIlMkM2LjY5MSUyMDIxLjU1MiUyQzYuNjkxJTIwQzIxLjU1MiUyQzYuNjkxJTIwMjEuMzcyJTJDNy4zMDQlMjAyMS40MTYlMkM3LjYxMyUyMEMyMS40NiUyQzcuOTIzJTIwMjIlMkM4LjgyMyUyMDIyJTJDOSUyMEMyMiUyQzkuMTc3JTIwMjEuNDIyJTJDOS40NTklMjAyMS4yOSUyQzkuODU3JTIwQzIxLjE1NiUyQzEwLjI1NSUyMDIxLjk1NiUyQzExLjYwMiUyMDIyJTJDMTIlMjBDMjIuMDQ0JTJDMTIuMzk4JTIwMjEuNDg2JTJDMTIuNzM0JTIwMjElMkMxMyUyMEMyMC44NTElMkMxMy4wODIlMjAyMC40NDElMkMxMy4xMDglMjAxOS45MzglMkMxMy4xMDglMjBDMTguOTE0JTJDMTMuMTA4JTIwMTcuNSUyQzEyLjk5NSUyMDE3LjA5NSUyQzEyLjk5NSUyMEMxNy4wNTElMkMxMi45OTUlMjAxNy4wMTklMkMxMi45OTclMjAxNyUyQzEzJTIwQzE2LjczNSUyQzEzLjA0NCUyMDE1LjAzMSUyQzEzLjI2MyUyMDE0LjgyMSUyQzE0LjIyMiUyMEMxNC42MTElMkMxNS4xODElMjAxNi4xNzQlMkMxNi44ODUlMjAxNi40ODQlMkMxNy43MjYlMjBDMTYuNzkzJTJDMTguNTY2JTIwMTYuMzg0JTJDMjEuMTk2JTIwMTUuNzY1JTJDMjEuNjgyJTIwQzE1LjQ3JTJDMjEuOTE1JTIwMTUuMjU1JTJDMjEuOTc2JTIwMTUuMTExJTJDMjEuOTc2JTIwQzE0Ljk1NCUyQzIxLjk3NiUyMDE0Ljg4MiUyQzIxLjkwMyUyMDE0Ljg4MiUyQzIxLjkwMyUyMEMxNC44ODIlMkMyMS45MDMlMjAxNC41NzIlMkMxOS41NTklMjAxNC4wODclMkMxOC44MDclMjBDMTMuNjAxJTJDMTguMDU2JTIwMTMuMjQ3JTJDMTcuMDgzJTIwMTIuODk0JTJDMTYuNzI5JTIwQzEyLjU0MSUyQzE2LjM3NSUyMDExLjgzMyUyQzE2LjA0MyUyMDExLjUyNCUyQzE1LjQzNSUyMEMxMS4yMTUlMkMxNC44MjclMjAxMC4zMDglMkMxMy4xNDQlMjAxMC4yMiUyQzEyLjc5JTIwQzEwLjEzMiUyQzEyLjQzNyUyMDguOTI4JTJDMTAuNTM5JTIwOCUyQzEwLjE5MyUyMEw4JTJDMy4yMSUyMEM4JTJDMy4yMSUyMDguNzk0JTJDMi4yNzclMjAxMi44MDYlMkMyLjAwMyUyMEwxOCUyQzIlMjBNMTguMTc2JTJDLTAlMjBMMTcuOTk5JTJDLTAlMjBMMTIuODA0JTJDMC4wMDMlMjBMMTIuNzM3JTJDMC4wMDMlMjBMMTIuNjY5JTJDMC4wMDglMjBDOC42NjElMkMwLjI4MSUyMDcuMDkyJTJDMS4xOSUyMDYuNDglMkMxLjkwNSUyMEw1Ljk5NCUyQzIuNDczJTIwTDYlMkMzLjIyJTIwTDYuMDUlMkMxMC4yMDglMjBMNi4wNiUyQzExLjU4NyUyMEw3LjI3MyUyQzEyLjAzOSUyMEM3LjU3JTJDMTIuMjYyJTIwOC4xNDElMkMxMy4wNiUyMDguMzI0JTJDMTMuNDMyJTIwQzguNDYlMkMxMy44NTQlMjA4Ljc2MyUyQzE0LjQ2NSUyMDkuNDY5JTJDMTUuODE2JTIwQzkuNTc5JTJDMTYuMDI3JTIwOS42NzUlMkMxNi4yMTIlMjA5Ljc0MiUyQzE2LjM0NCUyMEMxMC4xNjMlMkMxNy4xNzMlMjAxMC44MjglMkMxNy42NjIlMjAxMS4yNjclMkMxNy45ODYlMjBDMTEuMzIxJTJDMTguMDI1JTIwMTEuMzg4JTJDMTguMDc1JTIwMTEuNDM3JTJDMTguMTEyJTIwQzExLjUxMyUyQzE4LjI0JTIwMTEuNjM4JTJDMTguNDg4JTIwMTEuNzI2JTJDMTguNjYyJTIwQzExLjkxMyUyQzE5LjAzNSUyMDEyLjEyNiUyQzE5LjQ1NiUyMDEyLjM4OSUyQzE5Ljg2OCUyMEMxMi41MzclMkMyMC4xNzYlMjAxMi43NzglMkMyMS4yNiUyMDEyLjg5OSUyQzIyLjE2OCUyMEwxMi45ODglMkMyMi44MzglMjBMMTMuNDY2JTJDMjMuMzE4JTIwQzEzLjg4NCUyQzIzLjczNyUyMDE0LjQ4NCUyQzIzLjk3NyUyMDE1LjExMSUyQzIzLjk3NyUyMEMxNS43NTclMkMyMy45NzclMjAxNi4zOTIlMkMyMy43MzUlMjAxNy4wMDElMkMyMy4yNTclMjBDMTguNTIxJTJDMjIuMDYxJTIwMTguODQ0JTJDMTguMzUyJTIwMTguMzYxJTJDMTcuMDM4JTIwQzE4LjE3NCUyQzE2LjUzMSUyMDE3Ljg0OSUyQzE2LjAzMyUyMDE3LjUwMyUyQzE1LjUwNiUyMEMxNy40MTQlMkMxNS4zNjklMjAxNy4yOTUlMkMxNS4xODYlMjAxNy4xNzglMkMxNC45OTklMjBDMTcuMzI3JTJDMTUuMDA1JTIwMTcuNTk4JTJDMTUuMDIlMjAxNy44MjQlMkMxNS4wMzIlMjBDMTguNDYxJTJDMTUuMDY3JTIwMTkuMjU0JTJDMTUuMTElMjAxOS45MzglMkMxNS4xMSUyMEMyMC43ODYlMkMxNS4xMSUyMDIxLjQyJTJDMTUuMDUxJTIwMjEuOTU5JTJDMTQuNzU3JTIwQzIyLjU2OCUyQzE0LjQyNCUyMDI0LjE4NCUyQzEzLjU0MiUyMDIzLjk4OCUyQzExLjc4MSUyMEMyMy45MzclMkMxMS4zMTYlMjAyMy43NTYlMkMxMC45MDglMjAyMy41MjclMkMxMC4zOTElMjBDMjMuNTIxJTJDMTAuMzglMjAyMy41MTYlMkMxMC4zNjglMjAyMy41MSUyQzEwLjM1NSUyMEMyMy43NjElMkMxMC4wNDElMjAyNCUyQzkuNTk2JTIwMjQlMkM5JTIwQzI0JTJDOC40NTElMjAyMy43OTglMkM4LjA0JTIwMjMuNTQyJTJDNy41MiUyMEMyMy41NDIlMkM3LjUxOSUyMDIzLjU0MSUyQzcuNTE4JTIwMjMuNTQxJTJDNy41MTclMjBDMjQuMDQlMkM2LjgxNSUyMDI0LjE2NiUyQzUuOTc2JTIwMjMuODM5JTJDNS4yMTMlMjBDMjMuNzI5JTJDNC45NTglMjAyMy41ODMlMkM0LjYxNiUyMDIyLjIyOSUyQzMuMjIlMjBDMjIuMTM4JTJDMi45MDglMjAyMiUyQzIuNTI4JTIwMjEuNzg5JTJDMi4xMDYlMjBDMjEuMDY1JTJDMC42NTYlMjAxOS4xNDIlMkMwLjE3MSUyMDE4LjM1JTJDMC4wMzElMjBMMTguMTc2JTJDLTAlMjBMMTguMTc2JTJDLTAlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzU1NjI1NyUyMiUyRiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTElMkMxMyUyMEMyJTJDMTMlMjA3JTJDMTMlMjA3JTJDMTMlMjBDNyUyQzEzJTIwOCUyQzEzJTIwOCUyQzExJTIwQzglMkM5JTIwOCUyQzMlMjA4JTJDMiUyMEM4JTJDMSUyMDclMkMxJTIwNyUyQzElMjBDNyUyQzElMjAzJTJDMSUyMDIlMkMxJTIwQzElMkMxJTIwMSUyQzIlMjAxJTJDMiUyMEwwJTJDMTIlMjBDMCUyQzEyJTIwMCUyQzEzJTIwMSUyQzEzJTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0RkJCNTQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5pLW1lbnUtcmVwb3J0e2JhY2tncm91bmQ6dXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0MlM0Z4bWwlMjB2ZXJzaW9uJTNEJTIyMS4wJTIyJTIwZW5jb2RpbmclM0QlMjJVVEYtOCUyMiUzRiUzRSUwQSUzQ3N2ZyUyMHZlcnNpb24lM0QlMjIxLjElMjIlMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDI0JTIwMjQlMjIlM0UlMEElMjAlMjAlMjAlMjAlM0NwYXRoJTIwZCUzRCUyMk0xMi4wMTglMkMtMC4wMDMlMjBDOC41MTIlMkMtMC4wMDMlMjA0LjI4MiUyQzEuMTMyJTIwMC44JTJDMy4wMjklMjBDMC44JTJDNy4xMjclMjAwLjczNCUyQzE3LjAyNSUyMDEyJTJDMjQlMjBDMjMuMjY2JTJDMTcuMDI1JTIwMjMuMjM3JTJDNy4xNzElMjAyMy4yMzclMkMzLjA3NCUyMEMxOS43NTUlMkMxLjE3NiUyMDE1LjUyNSUyQy0wLjAwMyUyMDEyLjAxOCUyQy0wLjAwMyUyMHolMjBNMTIlMkMyMS4zOTElMjBDMy42NjYlMkMxNS4wMzglMjAzLjA1MSUyQzcuNzUlMjAzLjA1MSUyQzQuMjk5JTIwQzUuODU0JTJDMi43MDIlMjA5LjEwNiUyQzIuMDg3JTIwMTIlMkMyLjA4NyUyMEMxNC44OTUlMkMyLjA4NyUyMDE4LjE4OCUyQzIuNzM5JTIwMjAuOTkxJTJDNC4zMzclMjBDMjAuOTkxJTJDNy43ODclMjAyMC4zNjIlMkMxNS4wMzglMjAxMiUyQzIxLjM5MSUyMHolMjBNMTMuNTY1JTJDOS4zOTElMjBMMTAuNDM1JTJDOS4zOTElMjBMMTAuNDM1JTJDMTcuMjE3JTIwTDEzLjU2NSUyQzE3LjIxNyUyMEwxMy41NjUlMkM5LjM5MSUyMHolMjBNMTIlMkM3LjMwNCUyMEMxMy4yNzglMkM3LjMwNCUyMDEzLjkwOSUyQzYuODE0JTIwMTMuOTA5JTJDNS43NjIlMjBDMTMuOTA5JTJDNS4yMzYlMjAxMy43NTYlMkM0LjgzOSUyMDEzLjQ1JTJDNC41NyUyMEMxMy4xNDQlMkM0LjMwMSUyMDEyLjY1OCUyQzQuMTY3JTIwMTEuOTkyJTJDNC4xNjclMjBDMTEuMzI1JTJDNC4xNjclMjAxMC44NDIlMkM0LjI5OCUyMDEwLjU0MyUyQzQuNTYxJTIwQzEwLjI0MyUyQzQuODI0JTIwMTAuMDk0JTJDNS4yMjQlMjAxMC4wOTQlMkM1Ljc2MyUyMEMxMC4wOTMlMkM2LjgxNCUyMDEwLjczNCUyQzcuMzA0JTIwMTIlMkM3LjMwNCUyMEwxMiUyQzcuMzA0JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNCNEMxQjYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5pLW1lbnUtcmVwb3J0LWh7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQyUzRnhtbCUyMHZlcnNpb24lM0QlMjIxLjAlMjIlMjBlbmNvZGluZyUzRCUyMlVURi04JTIyJTNGJTNFJTBBJTNDc3ZnJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMjQlMjAyNCUyMiUzRSUwQSUyMCUyMCUyMCUyMCUzQ3BhdGglMjBkJTNEJTIyTTEyLjAyNyUyQzAuMDA0JTIwQzguNTIlMkMwLjAwNCUyMDQuMjklMkMxLjEzOSUyMDAuODA4JTJDMy4wMzclMjBDMC44MDglMkM3LjEzNSUyMDAuNzQyJTJDMTcuMDMzJTIwMTIuMDA4JTJDMjQuMDA4JTIwQzIzLjI3NCUyQzE3LjAzMyUyMDIzLjI0NSUyQzcuMTc5JTIwMjMuMjQ1JTJDMy4wODElMjBDMTkuNzYzJTJDMS4xODQlMjAxNS41MzMlMkMwLjAwNCUyMDEyLjAyNyUyQzAuMDA0JTIweiUyME0xMi4wMDglMkMyMS4zOTklMjBDMy42NzQlMkMxNS4wNDUlMjAzLjA1OSUyQzcuNzU3JTIwMy4wNTklMkM0LjMwNyUyMEM1Ljg2MiUyQzIuNzA5JTIwOS4xMTQlMkMyLjA5NSUyMDEyLjAwOCUyQzIuMDk1JTIwQzE0LjkwMyUyQzIuMDk1JTIwMTguMTk2JTJDMi43NDYlMjAyMSUyQzQuMzQ0JTIwQzIxJTJDNy43OTQlMjAyMC4zNyUyQzE1LjA0NSUyMDEyLjAwOCUyQzIxLjM5OSUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNTU2MjU3JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTMuNTc0JTJDOS4zOTklMjBMMTAuNDQzJTJDOS4zOTklMjBMMTAuNDQzJTJDMTcuMjI1JTIwTDEzLjU3NCUyQzE3LjIyNSUyMEwxMy41NzQlMkM5LjM5OSUyMHolMjBNMTIuMDA4JTJDNy4zMTIlMjBDMTMuMjg2JTJDNy4zMTIlMjAxMy45MTclMkM2LjgyMiUyMDEzLjkxNyUyQzUuNzclMjBDMTMuOTE3JTJDNS4yNDQlMjAxMy43NjQlMkM0Ljg0NiUyMDEzLjQ1OCUyQzQuNTc4JTIwQzEzLjE1MyUyQzQuMzA5JTIwMTIuNjY2JTJDNC4xNzQlMjAxMiUyQzQuMTc0JTIwQzExLjMzNCUyQzQuMTc0JTIwMTAuODUxJTJDNC4zMDUlMjAxMC41NTElMkM0LjU2OCUyMEMxMC4yNTIlMkM0LjgzMSUyMDEwLjEwMiUyQzUuMjMxJTIwMTAuMTAyJTJDNS43NyUyMEMxMC4xMDElMkM2LjgyMSUyMDEwLjc0MyUyQzcuMzEyJTIwMTIuMDA4JTJDNy4zMTIlMjBMMTIuMDA4JTJDNy4zMTIlMjB6JTIyJTIwZmlsbCUzRCUyMiUyMzRGQkI1NCUyMiUyRiUzRSUwQSUzQyUyRnN2ZyUzRSUwQSl9LmktbWVudS1zZXR0aW5nc3tiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMjQlMkMxMCUyMEwyMC43NSUyQzguMzc1JTIwTDIxLjg5OSUyQzQuOTI5JTIwTDE5LjA3JTJDMi4xMDElMjBMMTUuNjI0JTJDMy4yNDklMjBMMTQlMkMwJTIwTDEwJTJDMCUyMEw4LjM3NSUyQzMuMjUlMjBMNC45MjklMkMyLjEwMSUyMEwyLjEwMSUyQzQuOTI5JTIwTDMuMjQ5JTJDOC4zNzUlMjBMMCUyQzEwJTIwTDAlMkMxNCUyMEwzLjI1JTJDMTUuNjI1JTIwTDIuMTAxJTJDMTkuMDcyJTIwTDQuOTMlMkMyMS44OTklMjBMOC4zNzYlMkMyMC43NTElMjBMMTAlMkMyNCUyMEwxNCUyQzI0JTIwTDE1LjYyNSUyQzIwLjc1JTIwTDE5LjA3MSUyQzIxLjg5OSUyMEwyMS44OTklMkMxOS4wNzElMjBMMjAuNzUxJTJDMTUuNjI1JTIwTDI0JTJDMTQlMjBMMjQlMkMxMCUyMHolMjBNMjIlMkMxMyUyMEwxOC41NjMlMkMxNC43MTklMjBMMTkuNzc4JTJDMTguMzY0JTIwTDE4LjM2NCUyQzE5Ljc3OCUyMEwxNC43MTklMkMxOC41NjMlMjBMMTMlMkMyMiUyMEwxMSUyQzIyJTIwTDkuMjgxJTJDMTguNTYzJTIwTDUuNjM2JTJDMTkuNzc4JTIwTDQuMjIxJTJDMTguMzY0JTIwTDUuNDM3JTJDMTQuNzE5JTIwTDIlMkMxMyUyMEwyJTJDMTElMjBMNS40MzclMkM5LjI4MSUyMEw0LjIyMSUyQzUuNjM2JTIwTDUuNjM2JTJDNC4yMjElMjBMOS4yODElMkM1LjQzNyUyMEwxMSUyQzIlMjBMMTMlMkMyJTIwTDE0LjcxOSUyQzUuNDM3JTIwTDE4LjM2NCUyQzQuMjIxJTIwTDE5Ljc3OCUyQzUuNjM2JTIwTDE4LjU2MyUyQzkuMjgxJTIwTDIyJTJDMTElMjBMMjIlMkMxMyUyMHolMjBNMTIlMkM3Ljk3JTIwQzkuNzc0JTJDNy45NyUyMDcuOTclMkM5Ljc3NCUyMDcuOTclMkMxMiUyMEM3Ljk3JTJDMTQuMjI2JTIwOS43NzQlMkMxNi4wMjklMjAxMiUyQzE2LjAyOSUyMEMxNC4yMjYlMkMxNi4wMjklMjAxNi4wMjklMkMxNC4yMjYlMjAxNi4wMjklMkMxMiUyMEMxNi4wMjklMkM5Ljc3NCUyMDE0LjIyNiUyQzcuOTclMjAxMiUyQzcuOTclMjB6JTIwTTEyJTJDMTMuOTI5JTIwQzEwLjkzNCUyQzEzLjkyOSUyMDEwLjA3MSUyQzEzLjA2NiUyMDEwLjA3MSUyQzEyJTIwQzEwLjA3MSUyQzEwLjkzNCUyMDEwLjkzNCUyQzEwLjA3MSUyMDEyJTJDMTAuMDcxJTIwQzEzLjA2NiUyQzEwLjA3MSUyMDEzLjkyOSUyQzEwLjkzNCUyMDEzLjkyOSUyQzEyJTIwQzEzLjkyOSUyQzEzLjA2NiUyMDEzLjA2NiUyQzEzLjkyOSUyMDEyJTJDMTMuOTI5JTIweiUyMiUyMGZpbGwlM0QlMjIlMjNCNEMxQjYlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5pLW1lbnUtc2V0dGluZ3MtaHtiYWNrZ3JvdW5kOnVybChkYXRhOmltYWdlL3N2Zyt4bWwsJTNDJTNGeG1sJTIwdmVyc2lvbiUzRCUyMjEuMCUyMiUyMGVuY29kaW5nJTNEJTIyVVRGLTglMjIlM0YlM0UlMEElM0NzdmclMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweG1sbnMlM0QlMjJodHRwJTNBJTJGJTJGd3d3LnczLm9yZyUyRjIwMDAlMkZzdmclMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjAyNCUyMDI0JTIyJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMjQlMkMxMCUyMEwyMC43NSUyQzguMzc1JTIwTDIxLjg5OSUyQzQuOTI5JTIwTDE5LjA3JTJDMi4xMDElMjBMMTUuNjI0JTJDMy4yNDklMjBMMTQlMkMwJTIwTDEwJTJDMCUyMEw4LjM3NSUyQzMuMjUlMjBMNC45MjklMkMyLjEwMSUyMEwyLjEwMSUyQzQuOTI5JTIwTDMuMjQ5JTJDOC4zNzUlMjBMMCUyQzEwJTIwTDAlMkMxNCUyMEwzLjI1JTJDMTUuNjI1JTIwTDIuMTAxJTJDMTkuMDcyJTIwTDQuOTMlMkMyMS44OTklMjBMOC4zNzYlMkMyMC43NTElMjBMMTAlMkMyNCUyMEwxNCUyQzI0JTIwTDE1LjYyNSUyQzIwLjc1JTIwTDE5LjA3MSUyQzIxLjg5OSUyMEwyMS44OTklMkMxOS4wNzElMjBMMjAuNzUxJTJDMTUuNjI1JTIwTDI0JTJDMTQlMjBMMjQlMkMxMCUyMHolMjBNMjIlMkMxMyUyMEwxOC41NjMlMkMxNC43MTklMjBMMTkuNzc4JTJDMTguMzY0JTIwTDE4LjM2NCUyQzE5Ljc3OCUyMEwxNC43MTklMkMxOC41NjMlMjBMMTMlMkMyMiUyMEwxMSUyQzIyJTIwTDkuMjgxJTJDMTguNTYzJTIwTDUuNjM2JTJDMTkuNzc4JTIwTDQuMjIxJTJDMTguMzY0JTIwTDUuNDM3JTJDMTQuNzE5JTIwTDIlMkMxMyUyMEwyJTJDMTElMjBMNS40MzclMkM5LjI4MSUyMEw0LjIyMSUyQzUuNjM2JTIwTDUuNjM2JTJDNC4yMjElMjBMOS4yODElMkM1LjQzNyUyMEwxMSUyQzIlMjBMMTMlMkMyJTIwTDE0LjcxOSUyQzUuNDM3JTIwTDE4LjM2NCUyQzQuMjIxJTIwTDE5Ljc3OCUyQzUuNjM2JTIwTDE4LjU2MyUyQzkuMjgxJTIwTDIyJTJDMTElMjBMMjIlMkMxMyUyMHolMjIlMjBmaWxsJTNEJTIyJTIzNTU2MjU3JTIyJTJGJTNFJTBBJTIwJTIwJTIwJTIwJTNDcGF0aCUyMGQlM0QlMjJNMTIlMkM3Ljk3JTIwQzkuNzc0JTJDNy45NyUyMDcuOTclMkM5Ljc3NCUyMDcuOTclMkMxMiUyMEM3Ljk3JTJDMTQuMjI2JTIwOS43NzQlMkMxNi4wMjklMjAxMiUyQzE2LjAyOSUyMEMxNC4yMjYlMkMxNi4wMjklMjAxNi4wMjklMkMxNC4yMjYlMjAxNi4wMjklMkMxMiUyMEMxNi4wMjklMkM5Ljc3NCUyMDE0LjIyNiUyQzcuOTclMjAxMiUyQzcuOTclMjB6JTIwTTEyJTJDMTMuOTI5JTIwQzEwLjkzNCUyQzEzLjkyOSUyMDEwLjA3MSUyQzEzLjA2NiUyMDEwLjA3MSUyQzEyJTIwQzEwLjA3MSUyQzEwLjkzNCUyMDEwLjkzNCUyQzEwLjA3MSUyMDEyJTJDMTAuMDcxJTIwQzEzLjA2NiUyQzEwLjA3MSUyMDEzLjkyOSUyQzEwLjkzNCUyMDEzLjkyOSUyQzEyJTIwQzEzLjkyOSUyQzEzLjA2NiUyMDEzLjA2NiUyQzEzLjkyOSUyMDEyJTJDMTMuOTI5JTIweiUyMiUyMGZpbGwlM0QlMjIlMjM0RkJCNTQlMjIlMkYlM0UlMEElM0MlMkZzdmclM0UlMEEpfS5tZW51e3BhZGRpbmc6MTFweCAwO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtd2VpZ2h0OjUwMDtjb2xvcjojOGY5YjkyO2JvcmRlci10b3A6MXB4IHNvbGlkICNlMGRmZGJ9Lm1lbnVfaXtkaXNwbGF5OnRhYmxlO3dpZHRoOjEwMCU7cGFkZGluZzo4cHggMjBweDtjdXJzb3I6cG9pbnRlcn0ubWVudV9pOmhvdmVye2JhY2tncm91bmQ6I2VlZjdmMTtjb2xvcjojMzMzfS5tZW51X2k6aG92ZXIgLm1lbnVfaWNvX3N7ZGlzcGxheTpub25lfS5tZW51X2k6aG92ZXIgLm1lbnVfaWNvX2h7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wfS5tZW51X2ljb3tkaXNwbGF5OnRhYmxlLWNlbGw7dmVydGljYWwtYWxpZ246bWlkZGxlO3dpZHRoOjI0cHh9Lm1lbnVfaWNvX2h7ZGlzcGxheTpub25lfS5tZW51X25hbWV7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtwYWRkaW5nOjAgMCAwIDEwcHh9LmNmLW1peDphZnRlciwuY2YtbWl4OmJlZm9yZSwuY2Y6YWZ0ZXIsLmNmOmJlZm9yZSwuY2xlYXJmaXg6YWZ0ZXIsLmNsZWFyZml4OmJlZm9yZSwuZm9vdDphZnRlciwuZm9vdDpiZWZvcmUsLm1lbnUtZmlsdGVyOmFmdGVyLC5tZW51LWZpbHRlcjpiZWZvcmV7ZGlzcGxheTp0YWJsZTtjb250ZW50OiIifS5jZi1taXg6YWZ0ZXIsLmNmOmFmdGVyLC5jbGVhcmZpeDphZnRlciwuZm9vdDphZnRlciwubWVudS1maWx0ZXI6YWZ0ZXJ7Y2xlYXI6Ym90aH0uY2VudGVyLWJsb2Nre2Rpc3BsYXk6YmxvY2s7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0b30ucHVsbC1yaWdodHtmbG9hdDpyaWdodCFpbXBvcnRhbnR9LnB1bGwtbGVmdHtmbG9hdDpsZWZ0IWltcG9ydGFudH0uaGlkZXtkaXNwbGF5Om5vbmV9LnNob3d7ZGlzcGxheTpibG9ja30uaW52aXNpYmxle3Zpc2liaWxpdHk6aGlkZGVufS50ZXh0LWhpZGV7Zm9udDowLzAgYTtjb2xvcjp0cmFuc3BhcmVudDt0ZXh0LXNoYWRvdzpub25lO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyOjB9LmhpZGRlbntkaXNwbGF5Om5vbmUhaW1wb3J0YW50O3Zpc2liaWxpdHk6aGlkZGVuIWltcG9ydGFudH0=",

"selectorMenu.html": "PGRpdiBjbGFzcz0ibWFpbiBzZ19pZ25vcmUiPgogICAgPGRpdiBjbGFzcz0iY2xvc2UgYWRnLWNsb3NlIiBpZD0iY2xvc2UtYnV0dG9uIj48L2Rpdj4KICAgIDxkaXYgY2xhc3M9ImhlYWQiIGlkPSJkcmFnLWhhbmRsZSI+CiAgICAgICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfc2VsZWN0X2VsZW1lbnQiIGNsYXNzPSJoZWFkX3RpdGxlIj48L2Rpdj4KICAgICAgICA8ZGl2IGkxOG49ImFzc2lzdGFudF9zZWxlY3RfZWxlbWVudF9leHQiIGNsYXNzPSJoZWFkX3RleHQiPjwvZGl2PgogICAgICAgIDwvZGl2PgogICAgPGRpdiBjbGFzcz0iZm9vdCI+CiAgICAgICAgPGJ1dHRvbiBpMThuPSJhc3Npc3RhbnRfc2VsZWN0X2VsZW1lbnRfY2FuY2VsIiB0eXBlPSJidXR0b24iIGNsYXNzPSJidG4gYnRuLWRlZmF1bHQiIGlkPSJjYW5jZWwtc2VsZWN0LW1vZGUiPjwvYnV0dG9uPgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+",

"sliderMenu.html": "PGRpdiBjbGFzcz0ibWFpbiI+CiAgICA8ZGl2IGNsYXNzPSJjbG9zZSBhZGctY2xvc2UiPjwvZGl2PgogICAgPGRpdiBjbGFzcz0iaGVhZCBoZWFkLS1zbGlkZXIiPgogICAgICAgIDxkaXYgY2xhc3M9ImhlYWRfaW4gaGVhZF9pbi0tc2xpZGVyIj4KICAgICAgICAgICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfYmxvY2tfZWxlbWVudCIgY2xhc3M9ImhlYWRfdGl0bGUgaGVhZF90aXRsZS0tc2xpZGVyIiBpZD0iaGVhZF90aXRsZSI+PC9kaXY+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImVsZW1lbnQtcnVsZV9tb3JlIGVsZW1lbnQtcnVsZV9tb3JlLS1tb2JpbGUiPgogICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImVsZW1lbnQtcnVsZV9leHBhbmQtbGluayIgaWQ9IkV4dGVuZGVkU2V0dGluZ3NUZXh0Ij48L3NwYW4+CiAgICAgICAgICAgICAgICA8YnV0dG9uIGkxOG49ImFzc2lzdGFudF9ibG9jayIgdHlwZT0iYnV0dG9uIiBjbGFzcz0iYnRuIGJ0bi1jYW5jZWwiIGlkPSJhZGctYWNjZXB0Ij48L2J1dHRvbj4KICAgICAgICAgICAgICAgIDxidXR0b24gaTE4bj0iYXNzaXN0YW50X2Fub3RoZXJfZWxlbWVudCIgdHlwZT0iYnV0dG9uIiBjbGFzcz0iYnRuIGJ0bi1kZWZhdWx0IiBpZD0iYWRnLWNhbmNlbCI+PC9idXR0b24+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgICAgIDxkaXYgY2xhc3M9ImFkZy1zbGlkZS1idG5zIj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iYWRnLXNsaWRlLWJ0biBhZGctc2xpZGUtYnRuLS1taW51cyI+PC9kaXY+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImFkZy1zbGlkZS1idG4gYWRnLXNsaWRlLWJ0bi0tcGx1cyI+PC9kaXY+CiAgICAgICAgPC9kaXY+CiAgICAgICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfYmxvY2tfZWxlbWVudF9leHBsYWluIiBjbGFzcz0iaGVhZF90ZXh0IGhlYWRfdGV4dC0tbW9iaWxlLWgiIGlkPSJoZWFkX3RleHQiPjwvZGl2PgogICAgPC9kaXY+CiAgICA8ZGl2IGNsYXNzPSJjb250ZW50IiBpZD0ic2xpZGVyLWFyZWEiPgogICAgICAgIDxkaXYgY2xhc3M9ImVsZW1lbnQtcnVsZSBlbGVtZW50LXJ1bGUtLXNsaWRlciI+CiAgICAgICAgICAgIDxkaXYgaTE4bj0iYXNzaXN0YW50X3NsaWRlcl9leHBsYWluIiBjbGFzcz0iZWxlbWVudC1ydWxlX3RleHQgZWxlbWVudC1ydWxlX3RleHQtLXNsaWRlciI+PC9kaXY+CiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImVsZW1lbnQtcnVsZV9zbGlkZXIiPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYWRnLXNsaWRlIiBpZD0ic2xpZGVyIj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGkxOG49ImFzc2lzdGFudF9zbGlkZXJfbWF4IiBjbGFzcz0iYWRnLXNsaWRlLWNsdWUtbWF4Ij48L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGkxOG49ImFzc2lzdGFudF9zbGlkZXJfbWluIiBjbGFzcz0iYWRnLXNsaWRlLWNsdWUtbWluIj48L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iZWxlbWVudC1ydWxlX21vcmUiPgogICAgICAgICAgICAgICAgCQkJPHNwYW4gY2xhc3M9ImVsZW1lbnQtcnVsZV9leHBhbmQtbGluayIgaWQ9IkV4dGVuZGVkU2V0dGluZ3NUZXh0Ij4KCQkJCQkJCTxzcGFuIGkxOG49ImFzc2lzdGFudF9leHRlbmRlZF9zZXR0aW5ncyIgY2xhc3M9ImVsZW1lbnQtcnVsZV9leHBhbmQtbGlua190eHQiPjwvc3Bhbj4KCQkJCQkJPHNwYW4gY2xhc3M9ImVsZW1lbnQtcnVsZV9leHBhbmQtbGlua19hcnIiPjwvc3Bhbj4KCQkJCQkJPC9zcGFuPgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iZWxlbWVudC1ydWxlX2Zvcm0iIGlkPSJhZHYtc2V0dGluZ3MiPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZWxlbWVudC1ydWxlX2Zvcm0tY29udCI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iZWxlbWVudC1ydWxlX2ZpZWxkc2V0IiBpZD0ib25lLWRvbWFpbi1jaGVja2JveC1ibG9jayI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz0iZm9ybS11aS1jb250cm9sIiBpZD0ib25lLWRvbWFpbi1jaGVja2JveCIgdHlwZT0iY2hlY2tib3giLz4KICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj0ib25lLWRvbWFpbi1jaGVja2JveCIgY2xhc3M9ImZvcm0tdWkiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaTE4bj0iYXNzaXN0YW50X2FwcGx5X3J1bGVfdG9fYWxsX3NpdGVzIiBjbGFzcz0iZm9ybS11aS10eHQiPjwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSJkaXNwbGF5OiBub25lOyIgY2xhc3M9ImVsZW1lbnQtcnVsZV9maWVsZHNldCIgaWQ9ImJsb2NrLWJ5LXVybC1jaGVja2JveC1ibG9jayI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz0iZm9ybS11aS1jb250cm9sIiBpZD0iYmxvY2stYnktdXJsLWNoZWNrYm94IiB0eXBlPSJjaGVja2JveCIvPgogICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPSJibG9jay1ieS11cmwtY2hlY2tib3giIGNsYXNzPSJmb3JtLXVpIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGkxOG49ImFzc2lzdGFudF9ibG9ja19ieV9yZWZlcmVuY2UiIGNsYXNzPSJmb3JtLXVpLXR4dCI+PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9ImRpc3BsYXk6IG5vbmU7IiBjbGFzcz0iZWxlbWVudC1ydWxlX2ZpZWxkc2V0IiBpZD0iYmxvY2stc2ltaWxhci1jaGVja2JveC1ibG9jayI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz0iZm9ybS11aS1jb250cm9sIiBpZD0iYmxvY2stc2ltaWxhci1jaGVja2JveCIgdHlwZT0iY2hlY2tib3giLz4KICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGZvcj0iYmxvY2stc2ltaWxhci1jaGVja2JveCIgY2xhc3M9ImZvcm0tdWkiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gaTE4bj0iYXNzaXN0YW50X2Jsb2NrX3NpbWlsYXIiIGNsYXNzPSJmb3JtLXVpLXR4dCI+PC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImVsZW1lbnQtcnVsZV9maWVsZHNldCI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz0iZm9ybS1jb250cm9sIiBpZD0iZmlsdGVyLXJ1bGUiIHR5cGU9InRleHQiLz4KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2Rpdj4KICAgIDwvZGl2PgogICAgPGRpdiBjbGFzcz0iZm9vdCBmb290LS1zbGlkZXIiPgogICAgICAgIDxidXR0b24gaTE4bj0iYXNzaXN0YW50X2Fub3RoZXJfZWxlbWVudCIgdHlwZT0iYnV0dG9uIiBjbGFzcz0iYnRuIGJ0bi1kZWZhdWx0IGJ0bi1hbm90aGVyLWVsIiBpZD0iYWRnLWNhbmNlbCI+PC9idXR0b24+CiAgICAgICAgPGRpdiBjbGFzcz0iZm9vdF9hY3Rpb24iPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb290X2FjdGlvbl9idG4iPgogICAgICAgICAgICAgICAgPGJ1dHRvbiBpMThuPSJhc3Npc3RhbnRfcHJldmlldyIgdHlwZT0iYnV0dG9uIiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBpZD0iYWRnLXByZXZpZXciPjwvYnV0dG9uPgogICAgICAgICAgICAgICAgPGJ1dHRvbiBpMThuPSJhc3Npc3RhbnRfYmxvY2siIHR5cGU9ImJ1dHRvbiIgY2xhc3M9ImJ0biBidG4tY2FuY2VsIiBpZD0iYWRnLWFjY2VwdCI+PC9idXR0b24+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+CjwvZGl2Pgo=",

"blockPreview.html": "PGRpdiBjbGFzcz0ibWFpbiI+CjxkaXYgY2xhc3M9ImNsb3NlIj48L2Rpdj4KCjxkaXYgY2xhc3M9ImhlYWQiPgogICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfcHJldmlld19oZWFkZXIiIGNsYXNzPSJoZWFkX3RpdGxlIj4KICAgIDwvZGl2PgogICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfcHJldmlld19oZWFkZXJfaW5mbyIgY2xhc3M9ImhlYWRfdGV4dCI+CiAgICA8L2Rpdj4KPC9kaXY+Cgo8ZGl2IGNsYXNzPSJmb290Ij4KICAgIDxidXR0b24gaTE4bj0iYXNzaXN0YW50X2Fub3RoZXJfZWxlbWVudCIgY2xhc3M9ImJ0biBidG4tZGVmYXVsdCIgaWQ9InNlbGVjdC1hbm90aGVyLWVsZW1lbnQiIHR5cGU9ImJ1dHRvbiI+PC9idXR0b24+CgogICAgPGRpdiBjbGFzcz0iZm9vdF9hY3Rpb24iPgogICAgICAgIDxkaXYgY2xhc3M9ImZvb3RfYWN0aW9uX2J0biI+CiAgICAgICAgICAgIDxidXR0b24gaTE4bj0iYXNzaXN0YW50X3ByZXZpZXdfZW5kIiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiBpZD0iZW5kLXByZXZpZXciIHR5cGU9ImJ1dHRvbiI+PC9idXR0b24+CiAgICAgICAgICAgIDxidXR0b24gaTE4bj0iYXNzaXN0YW50X2Jsb2NrIiBjbGFzcz0iYnRuIGJ0bi1jYW5jZWwiIGlkPSJibG9jay1lbGVtZW50IiB0eXBlPSJidXR0b24iPjwvYnV0dG9uPgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+CjwvZGl2Pgo8L2Rpdj4=",

"settingsMenu.html": "PGRpdiBjbGFzcz0ibWFpbiI+CiAgICA8ZGl2IGNsYXNzPSJjbG9zZSI+PC9kaXY+CgogICAgPGRpdiBjbGFzcz0iaGVhZCI+CiAgICAgICAgPGRpdiBpMThuPSJhc3Npc3RhbnRfc2V0dGluZ3MiIGNsYXNzPSJoZWFkX3RpdGxlIj4KICAgICAgICA8L2Rpdj4KICAgICAgICA8ZGl2IGkxOG49InNldHRpbmdzX2Nob29zZV9zaXplX2FuZF9wb3NpdGlvbiIgY2xhc3M9ImhlYWRfdGV4dCBoZWFkX3RleHQtLW1vYmlsZS1oIj4KICAgICAgICA8L2Rpdj4KICAgIDwvZGl2PgoKICAgIDxkaXYgY2xhc3M9ImNvbnRlbnQiPgogICAgICAgIDxkaXYgY2xhc3M9InNldHRpbmdzIHNldHRpbmdzX19ob3Jpem9udGFsIj4KCiAgICAgICAgICAgIDxkaXYgY2xhc3M9InNldHRpbmdzX2ZpZWxkc2V0Ij4KICAgICAgICAgICAgICAgIDxkaXYgaTE4bj0ic2V0dGluZ3NfaWNvbl9zaXplIiBjbGFzcz0ic2V0dGluZ3NfZmllbGRzZXRfbGJsIj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2V0dGluZ3NfZmllbGRzZXRfdmFsIj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaG9pY2Utc2l6ZSI+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNob2ljZS1zaXplX2dyb3VwIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNob2ljZS1zaXplX2ZpZWxkIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9ImNob2ljZS1zaXplX2lucHV0IGZvcm0tdWktY29udHJvbCIgaWQ9InNpemUtc21hbGwiIHR5cGU9InJhZGlvIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPSJyYWRpbyI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJmb3JtLXVpIiBmb3I9InNpemUtc21hbGwiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGkxOG49InNldHRpbmdzX3NtYWxsIiBjbGFzcz0iZm9ybS11aS10eHQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImNob2ljZS1zaXplX2xvZ28iPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJhLWxvZ28gYS1sb2dvX19zbWFsbCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJsb2dvIj48L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaG9pY2Utc2l6ZV9maWVsZCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPSJjaG9pY2Utc2l6ZV9pbnB1dCBmb3JtLXVpLWNvbnRyb2wiIGlkPSJzaXplLWJpZyIgdHlwZT0icmFkaW8iCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9InJhZGlvIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImZvcm0tdWkiIGZvcj0ic2l6ZS1iaWciPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGkxOG49InNldHRpbmdzX2JpZyIgY2xhc3M9ImZvcm0tdWktdHh0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJjaG9pY2Utc2l6ZV9sb2dvIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0iYS1sb2dvIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9ImxvZ28iPjwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgoKICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2V0dGluZ3NfZmllbGRzZXQiPgogICAgICAgICAgICAgICAgPGRpdiBpMThuPSJzZXR0aW5nc19wb3NpdGlvbiIgY2xhc3M9InNldHRpbmdzX2ZpZWxkc2V0X2xibCBzZXR0aW5nc19maWVsZHNldF9sYmxfX3BvcyI+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InNldHRpbmdzX2ZpZWxkc2V0X3ZhbCI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hhbmdlLXBvc2l0aW9uIj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hhbmdlLXBvc2l0aW9uX2kiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9InJhZGlvIiBuYW1lPSJwb3NpdGlvbiIgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9pbnB1dCIgaWQ9InBvc2l0aW9uLXRvcC1sZWZ0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0iY2hhbmdlLXBvc2l0aW9uX2xhYmVsIiBmb3I9InBvc2l0aW9uLXRvcC1sZWZ0Ij4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz0icy1wb3NpdGlvbi1hcnItdG9wLWxlZnQiPjwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpMThuPSJzZXR0aW5nc19sZWZ0X3RvcCIgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl92YWwiPjwvZGl2PgogICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hhbmdlLXBvc2l0aW9uX2kiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9InJhZGlvIiBuYW1lPSJwb3NpdGlvbiIgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9pbnB1dCIgaWQ9InBvc2l0aW9uLXRvcC1yaWdodCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9sYWJlbCIgZm9yPSJwb3NpdGlvbi10b3AtcmlnaHQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzLXBvc2l0aW9uLWFyci10b3AtcmlnaHQiPjwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpMThuPSJzZXR0aW5nc19yaWdodF90b3AiIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25fdmFsIj48L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9pIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJyYWRpbyIgbmFtZT0icG9zaXRpb24iIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25faW5wdXQiIGlkPSJwb3NpdGlvbi1ib3R0b20tbGVmdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9sYWJlbCIgZm9yPSJwb3NpdGlvbi1ib3R0b20tbGVmdCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9InMtcG9zaXRpb24tYXJyLWJvdHRvbS1sZWZ0Ij48L3NwYW4+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgaTE4bj0ic2V0dGluZ3NfbGVmdF9ib3R0b20iIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25fdmFsIj48L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9pIj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJyYWRpbyIgbmFtZT0icG9zaXRpb24iIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25faW5wdXQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9InBvc2l0aW9uLWJvdHRvbS1yaWdodCI+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImNoYW5nZS1wb3NpdGlvbl9sYWJlbCIgZm9yPSJwb3NpdGlvbi1ib3R0b20tcmlnaHQiPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzLXBvc2l0aW9uLWFyci1ib3R0b20tcmlnaHQiPjwvc3Bhbj4KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBpMThuPSJzZXR0aW5nc19yaWdodF9ib3R0b20iIGNsYXNzPSJjaGFuZ2UtcG9zaXRpb25fdmFsIj48L2Rpdj4KICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CgogICAgICAgIDwvZGl2PgogICAgPC9kaXY+CgoKICAgIDxkaXYgY2xhc3M9ImZvb3QiPgogICAgICAgIDxkaXYgY2xhc3M9ImZvb3RfYWN0aW9uIj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0iZm9vdF9hY3Rpb25fYnRuIj4KICAgICAgICAgICAgICAgIDxidXR0b24gaTE4bj0ic2V0dGluZ3NfY2FuY2VsIiBjbGFzcz0iYnRuIGJ0bi1kZWZhdWx0IiB0eXBlPSJidXR0b24iIGlkPSJjYW5jZWwiPjwvYnV0dG9uPgogICAgICAgICAgICAgICAgPGJ1dHRvbiBpMThuPSJzZXR0aW5nc19zYXZlIiBjbGFzcz0iYnRuIGJ0bi1wcmltYXJ5IiB0eXBlPSJidXR0b24iIGlkPSJzYXZlLXNldHRpbmdzIj48L2J1dHRvbj4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+CiAgICA8L2Rpdj4KPC9kaXY+Cg=="

};
var _getResource = function (name) {
                return Base64.decode(_resources[name]);
            }
return {getResource: _getResource};
};
/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
var cssEscape = (function(root, factory) { // jshint ignore:line
    // https://github.com/umdjs/umd/blob/master/returnExports.js
    // if (typeof exports == 'object') {
    //     // For Node.js.
    //     module.exports = factory(root);
    // } else if (typeof define == 'function' && define.amd) {
    //     // For AMD. Register as an anonymous module.
    //     define([], factory.bind(root, root));
    // } else {
    //     // For browser globals (not exposing the function separately).
    //     factory(root);
    // }
    return factory(root); //We use local variable because we don't want to spoil global scope
}(this, function(root) {

    if (root.CSS && root.CSS.escape) {
        return root.CSS.escape;
    }

    // https://drafts.csswg.org/cssom/#serialize-an-identifier
    var cssEscape = function(value) {
        if (arguments.length === 0) {
            throw new TypeError('`CSS.escape` requires an argument.');
        }
        var string = String(value);
        var length = string.length;
        var index = -1;
        var codeUnit;
        var result = '';
        var firstCodeUnit = string.charCodeAt(0);
        while (++index < length) {
            codeUnit = string.charCodeAt(index);
            // Note: there’s no need to special-case astral symbols, surrogate
            // pairs, or lone surrogates.

            // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
            // (U+FFFD).
            if (codeUnit === 0x0000) {
                result += '\uFFFD';
                continue;
            }

            if (
                // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, […]
            (codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
            // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), […]
            (index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
            // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
            (
                index == 1 &&
                codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
                firstCodeUnit == 0x002D
            )
            ) {
                // https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
                result += '\\' + codeUnit.toString(16) + ' ';
                continue;
            }

            if (
                // If the character is the first character and is a `-` (U+002D), and
            // there is no second character, […]
            index === 0 &&
            length == 1 &&
            codeUnit == 0x002D
            ) {
                result += '\\' + string.charAt(index);
                continue;
            }

            // If the character is not handled by one of the above rules and is
            // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
            // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
            // U+005A), or [a-z] (U+0061 to U+007A), […]
            if (
                codeUnit >= 0x0080 ||
                codeUnit == 0x002D ||
                codeUnit == 0x005F ||
                codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
                codeUnit >= 0x0041 && codeUnit <= 0x005A ||
                codeUnit >= 0x0061 && codeUnit <= 0x007A
            ) {
                // the character itself
                result += string.charAt(index);
                continue;
            }

            // Otherwise, the escaped character.
            // https://drafts.csswg.org/cssom/#escape-a-character
            result += '\\' + string.charAt(index);

        }
        return result;
    };

    if (!root.CSS) {
        root.CSS = {};
    }

    root.CSS.escape = cssEscape;
    return cssEscape;

}));
/**
 * Simple ioc implementation
 * @type {{add, get}}
 */
var Ioc = (function () { // jshint ignore:line
    var dependencies = {};

    var register = function (qualifier, obj) {
        dependencies[qualifier] = obj;
    };

    var get = function (func) {
        if (typeof func === 'string') {
            var resolved = dependencies[func];
            if (!resolved) {
                throw "Can't resolve " + func;
            }
            return resolved;
        }
        var resolvedDependencies = resolveDependencies(func);

        function FuncWrapper() {
            return func.apply(func, resolvedDependencies);
        }

        FuncWrapper.prototype = func.prototype;
        return new FuncWrapper();
    };

    var resolveDependencies = function (func) {
        var args = getArguments(func);
        var resolved = [];
        for (var i = 0; i < args.length; i++) {
            var depName = args[i].trim();
            var dep = dependencies[depName];
            if (!dep) {
                throw  "Can't find dependency: " + depName;
            }
            resolved.push(dependencies[depName]);
        }
        return resolved;
    };

    var getArguments = function (func) {
        //This regex is from require.js
        var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
        var args = func.toString().match(FN_ARGS)[1].split(',');
        if (args[0] === "") {
            return [];
        }
        return args;
    };

    return {
        register: register,
        get: get
    };

})();

/**
 * Simple logger with log levels
 * @returns {{warn: warn, info: info, debug: debug, error: error}}
 * @constructor
 */
var Log = function () { // jshint ignore:line

    var currentLevel = "INFO";

    var LogLevels = {
        ERROR: 1,
        WARN: 2,
        INFO: 3,
        DEBUG: 4
    };

    var print = function (level, method, args) {
        // gulp preprocess condition
        // @if DEBUG

        //check log level
        if (LogLevels[currentLevel] < LogLevels[level]) {
            return;
        }
        if (!args || args.length === 0 || !args[0]) {
            return;
        }
        var str = args[0] + "";
        args = Array.prototype.slice.call(args, 1);
        var formatted = str.replace(/{(\d+)}/g, function (match, number) {
            return typeof  args[number] !== "undefined" ? args[number] : match;
        });
        if (LogLevels[level] >= LogLevels[currentLevel]) {
            var now = new Date();
            formatted = now.toISOString() + ": " + formatted;
        }
        console[method](formatted);
        // @endif

        // @if !DEBUG
        return false;
        // @endif
    };

    var debug = function () {
        print("DEBUG", "log", arguments);
    };

    var info = function () {
        print("INFO", "info", arguments);
    };

    var warn = function () {
        print("WARN", "info", arguments);
    };

    var error = function () {
        print("ERROR", "error", arguments);
    };

    return {
        warn: warn,
        info: info,
        debug: debug,
        error: error
    };
};

/**
 * Balalaika library
 *
 * https://github.com/finom/balalaika/blob/master/balalaika.js
 *
 * The patch includes methods `addClass`, `removeClass`, `hasClass`, `get`, `css`, `hide`, `show`, `remove`, `text`, `attr`, `trigger`.
 * Also, for registration in the Ioc, the library is used through the variable `balalaika`
 */
var balalaika = (function (window, document, fn, nsRegAndEvents, id, s_EventListener, s_MatchesSelector, i, j, k, l, $) {
    $ = function (s, context) {
        return new $.i(s, context);
    };

    $.i = function (s, context) {
        var st;
        if (!s) {
            st = fn;
        } else {
            if (s.nodeType || s == window) {
                st = [s];
            } else {
                if (typeof(s) === 'string') {
                    if (/</.test(s)) {
                        st = ((i = document.createElement(context || 'q')).innerHTML = s, i.children);
                    } else {
                        st = (context && $(context)[0] || document).querySelectorAll(s);
                    }
                } else {
                    if (/f/.test(typeof s)) {
                        if (/c/.test(document.readyState)) {
                            st = s();
                        } else {
                            st = $(document).on('DOMContentLoaded', s);
                        }
                    } else {
                        st = s;
                    }
                }
            }
        }
        st = [].slice.call(st);
        fn.push.apply(this, st);
    };

    $.i[l = 'prototype'] = ( $.extend = function (obj) {
        k = arguments;
        for (i = 1; i < k.length; i++) {
            if (l = k[i]) {
                for (j in l) {
                    obj[j] = l[j];
                }
            }
        }

        return obj;
    })($.fn = $[l] = fn, { // $.fn = $.prototype = fn
        on: function (n, f) {
            // n = [ eventName, nameSpace ]
            n = n.split(nsRegAndEvents);
            this.map(function (item) {
                n.map(function (ev) {
                    item['add' + s_EventListener](ev, f);
                });
            });
            return this;
        },
        off: function (n, f) {
            // n = [ eventName, nameSpace ]
            n = n.split(nsRegAndEvents);
            // l = 'removeEventListener'
            l = 'remove' + s_EventListener;
            this.map(function (item) {
                n.map(function (ev) {
                    item[l](ev, f);
                });
            });
            return this;
        },
        is: function (s) {
            i = this[0];
            return (i.matches
            || i['webkit' + s_MatchesSelector]
            || i['moz' + s_MatchesSelector]
            || i['ms' + s_MatchesSelector]
            || i['o' + s_MatchesSelector]).call(i, s);
        }
    });
    return $;
})(window, window.document, [], /\.| /, 0, 'EventListener', 'MatchesSelector');

/**
 * Add some more functions to balalaika
 */
balalaika.fn.hasClass = function (className) {
    return !!this[0] && (this[0].classList != undefined) && this[0].classList.contains(className);
};

balalaika.fn.addClass = function (className) {
    this.forEach(function (item) {
        var classList = item.classList;
        classList.add.apply(classList, className.split(/\s/));
    });
    return this;
};

balalaika.fn.removeClass = function (className) {
    this.forEach(function (item) {
        var classList = item.classList;
        classList.remove.apply(classList, className.split(/\s/));
    });
    return this;
};

balalaika.fn.get = function (index) {
    return this.length > index ? this[index] : null;
};

balalaika.fn.css = function (attr, value) {
    this.forEach(function (item) {
        item.style[attr] = value;
    });
    return this;
};

balalaika.fn.hide = function () {
    this.forEach(function (item) {
        item.style['display'] = 'none';
    });
    return this;
};

balalaika.fn.show = function () {
    this.forEach(function (item) {
        item.style['display'] = 'block';
    });
    return this;
};

balalaika.fn.remove = function () {
    this.forEach(function (item) {
        item.parentNode.removeChild(item);
    });
    return this;
};

balalaika.fn.text = function (v) {
    this.forEach(function (item) {
        item.textContent = v;
    });
    return this;
};

balalaika.fn.attr = function (k, v) {
    this.forEach(function (item) {
        item.setAttribute(k, v);
    });
    return this;
};

balalaika.fn.trigger = function (eventName, options) {
    this.forEach(function (item) {
        if (window.CustomEvent) {
            var event = new CustomEvent(eventName, {detail: options});
        } else {
            var event = document.createEvent('CustomEvent');
            event.initCustomEvent(eventName, true, true, options);
        }

        item.dispatchEvent(event);
    });
    return this;
};

/**
 * UI utils
 * @param $
 * @returns {{makeElementDraggable: Function, makeIframeDraggable: Function, tryFullScreenPrefix: Function}}
 * @constructor
 */
var UIUtils = function($) { // jshint ignore:line
    var elWidth, elHeight, windowWidth, windowHeight;

    /**
     * Make element draggable
     * @param element
     * @param onDragEnd
     * @param onClick
     */
    var makeElementDraggable = function(element, onDragEnd, onClick) {
        var coords, shiftX, shiftY;

        var moveAt = function(e) {
            var position = {
                x: getOriginalEvent(e).pageX - shiftX,
                y: getOriginalEvent(e).pageY - shiftY
            };

            // disable mousemove if button element outside the screen
            var out = outsidePosition.top(position) ||
                outsidePosition.left(position) ||
                outsidePosition.bottom(position) ||
                outsidePosition.right(position);

            if (out) {
                onMouseUp(e, true);
            } else {
                moveElementTo(element, position.x, position.y);
            }
        };

        var onMouseMove = function(e) {
            pauseEvent(e);
            moveAt(e);
        };

        var getCoords = function(elem) {
            var box = elem.getBoundingClientRect();
            return {
                top: box.top,
                left: box.left,
                bottom: box.bottom,
                right: box.right
            };
        };

        coords = getCoords(element);

        /**
         * Prevent text selection
         * With cursor drag
         */
        var pauseEvent = function(e) {
            e.stopPropagation();
            e.preventDefault();
            e.cancelBubble = true;
            e.returnValue = false;

            return false;
        };

        var preventedEvent = function(e) {
            e.preventDefault();
        };

        var mouseDown = function(e) {
            pauseEvent(e);

            // prevent browser scroll
            $(document).on('wheel mousewheel', preventedEvent);

            // prevent right button mousedown
            if (e.button > 0) return;

            elWidth = element.clientWidth;
            elHeight = element.clientWidth;

            windowWidth = getWindowSize().width;
            windowHeight = getWindowSize().height;

            coords = getCoords(element);

            if (storedAnchor.top) {
                shiftY = getOriginalEvent(e).pageY - coords.top;
            } else {
                shiftY = windowHeight - (coords.bottom - getOriginalEvent(e).pageY);
            }

            if (storedAnchor.left) {
                shiftX = getOriginalEvent(e).pageX - coords.left;
            } else {
                shiftX = windowWidth - (coords.right - getOriginalEvent(e).pageX);
            }

            document.body.appendChild(element);

            /**
             * binding both mouse and touch/pointer events simultaneously
             * see: http://www.html5rocks.com/en/mobile/touchandmouse/
             */
            $(document).on('mouseup touchend pointerup', onMouseUp);
            $(document).on('mousemove touchmove pointermove', onMouseMove);
        };

        /**
         * On mouse up event
         * @param {Object} e  event object
         * @param {Boolean|undefined} doNotOpenIframe  do not open the iframe if true. This is necessary when the cursor is out of bounds
         */
        var onMouseUp = function(e, doNotOpenIframe) {
            e.stopPropagation();

            // make scroll availalbe
            $(document).off('wheel mousewheel', preventedEvent);

            // When a user finishes dragging icon, we set icon anchor
            // depending on the icon position, i.e. which quarter
            // of the screen it belongs.
            var lastX, lastY, lastCoords = getCoords(element);

            var topHalf = lastCoords.top < windowHeight / 2;
            var leftHalf = lastCoords.left < windowWidth / 2;

            setAnchorPosition.positionY(element, topHalf);
            setAnchorPosition.positionX(element, leftHalf);

            if (topHalf) {
                lastY = lastCoords.top;
            } else {
                lastY = lastCoords.bottom - windowHeight;
            }

            if (leftHalf) {
                lastX = lastCoords.left;
            } else {
                lastX = lastCoords.right - windowWidth;
            }

            moveElementTo(element, lastX, lastY);

            // Open the frame if the button has been shifted by no more than 20 pixels
            if (Math.abs(coords.left - lastCoords.left) > 20 || Math.abs(coords.top - lastCoords.top) > 20) {
                if (onDragEnd) {
                    var store = {
                        "x": lastX,
                        "y": lastY,
                        "storedAnchor": storedAnchor
                    };
                    onDragEnd(store);
                }
            } else {
                if (onClick && !doNotOpenIframe) {
                    onClick(e);
                }
            }

            $(document).off('mouseup touchend pointerup', onMouseUp);

            $(document).off('mousemove touchmove pointermove', onMouseMove);
        };

        $(element).on('mousedown touchstart', mouseDown.bind(this));
        $(element).on('dragstart', function() {return;});
        $(element).on('click', function(e) {
            onClick();
        });
    };

    var outsidePosition = {
        top: function(pos) {
            return storedAnchor.top && (pos.y + elHeight > windowHeight || pos.y < 0);
        },
        bottom: function(pos) {
            return !storedAnchor.top && (Math.abs(pos.y) + elHeight > windowHeight || pos.y > 0);
        },
        left: function(pos) {
            return storedAnchor.left && (pos.x + elWidth > windowWidth || pos.x < 0);
        },
        right: function(pos) {
            return !storedAnchor.left && (Math.abs(pos.x) + elWidth > windowWidth || pos.x > 0);
        }
    };

    /**
     * Makes iframe draggable
     *
     * @param iframe
     * @param handleElement
     */
    var makeIframeDraggable = function(iframe, handleElement) {
        var iframeJ = iframe;
        var dragHandle = handleElement;
        var $iframeDocument = $(iframe[0].contentDocument);

        var offset = Object.create(null);

        /**
         * Function that does actual "dragging"
         *
         * @param x
         * @param y
         */
        var drag = function(x, y) {
            iframeJ.css('left', x + 'px');
            iframeJ.css('top', y + 'px');
        };

        var cancelIFrameSelection = function(e) {
            e.preventDefault();
            e.stopPropagation();
        };

        var onMouseMove = function(e) {
            var eventPosition = getOriginalEvent(e);
            drag(eventPosition.screenX + offset.x, eventPosition.screenY + offset.y);
        };

        var onMouseDown = function(e) {
            var eventPosition = getOriginalEvent(e);
            var dragHandleEl = dragHandle.get(0);
            var rect = iframeJ.get(0).getBoundingClientRect();

            offset.x = rect.left + dragHandleEl.offsetLeft - eventPosition.screenX;
            offset.y = rect.top + dragHandleEl.offsetTop - eventPosition.screenY;

            $iframeDocument.on('mousemove touchmove pointermove', onMouseMove);
            $iframeDocument.on('selectstart', cancelIFrameSelection);
        };

        var onMouseUp = function() {
            $iframeDocument.off('mousemove touchmove pointermove', onMouseMove);
            $iframeDocument.off('selectstart', cancelIFrameSelection);
        };

        // prevent iframe dragging while browser tabs is switching
        document.addEventListener('visibilitychange', onMouseUp);

        dragHandle.on('mousedown touchstart', onMouseDown);
        $iframeDocument.on('mouseup touchend pointerup', onMouseUp);
        $iframeDocument.on('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });
    };

    var browserPrefixes = ["webkit", "moz", "ms", "o", ""];

    /*
     Checks prefixes for full screen mode.
     */
    var tryFullScreenPrefix = function(obj, method) {
        var i = 0,
            currentMethod = null,
            type;
        while (i < browserPrefixes.length && !obj[currentMethod]) {
            currentMethod = method;
            if (browserPrefixes[i] === "") {
                currentMethod = currentMethod.substr(0, 1).toLowerCase() + currentMethod.substr(1);
            }
            currentMethod = browserPrefixes[i] + currentMethod;
            type = typeof obj[currentMethod];
            if (type !== "undefined") {
                browserPrefixes = [browserPrefixes[i]];
                return (type === "function" ? obj[currentMethod]() : obj[currentMethod]);
            }
            i++;
        }
    };

    /**
     * Set transition css property for drag
     * translate3d is for better rendering performance
     * see: https://www.html5rocks.com/en/tutorials/speed/layers/
     */
    var moveElementTo = function(el, x, y) {
        var transform = 'translate3d(' + x + 'px,' + y + 'px, 0px)';
        el.style.webkitTransform = transform;
        el.style.mozTransform = transform;
        el.style.msTransform = transform;
        el.style.oTransform = transform;
        el.style.transform = transform;
    };

    /**
     * Get original event object for touch
     * devices to getting current coordinates
     * @param {Object}
     * @return {Object}
     */
    var getOriginalEvent = function(e) {
        return e.targetTouches ? e.targetTouches[0] : e;
    };

    /**
     * Functions for saving left/top anchors and setting class position
     *
     * @param {Object} element  button element
     * @param {Boolean} anchor  anchors positions `true` for top/left or `false` for bottom/right
     */
    var setAnchorPosition = {
        positionY: function(element, anchor) {
            storedAnchor.top = anchor;

            if (storedAnchor.top) {
                $(element).addClass('adguard-assistant-button-top');
                $(element).removeClass('adguard-assistant-button-bottom');
            } else {
                $(element).addClass('adguard-assistant-button-bottom');
                $(element).removeClass('adguard-assistant-button-top');
            }
        },
        positionX: function(element, anchor) {
            storedAnchor.left = anchor;

            if (storedAnchor.left) {
                $(element).addClass('adguard-assistant-button-left');
                $(element).removeClass('adguard-assistant-button-right');
            } else {
                $(element).addClass('adguard-assistant-button-right');
                $(element).removeClass('adguard-assistant-button-left');
            }
        }
    };

    // getting screen width and height without scroll bars
    var getWindowSize = function() {
        return {
            width: Math.min(document.documentElement.clientWidth, window.innerWidth || screen.width),
            height: Math.min(document.documentElement.clientHeight, window.innerHeight || screen.height)
        };
    };

    var checkElementPosition = function(element, pos) {
        windowWidth = getWindowSize().width;
        windowHeight = getWindowSize().height;

        elWidth = element.clientWidth;
        elHeight = element.clientHeight;

        if(outsidePosition.top(pos)) pos.y = windowHeight - 60;
        if(outsidePosition.bottom(pos)) pos.y = - windowHeight + 60;
        if(outsidePosition.left(pos)) pos.x = windowWidth - 60;
        if(outsidePosition.right(pos)) pos.x = - windowWidth + 60;

        moveElementTo(element, pos.x, pos.y);
    };

    var storedAnchor = {
        top: false,
        left: false
    };

    return {
        makeElementDraggable: makeElementDraggable,
        makeIframeDraggable: makeIframeDraggable,
        tryFullScreenPrefix: tryFullScreenPrefix,
        moveElementTo: moveElementTo,
        setAnchorPosition: setAnchorPosition,
        checkElementPosition: checkElementPosition
    };
};

/**
 * Utils that checks environment for compatibility with assistant
 * @param settings
 * @param log
 * @returns {{checkVisibleAreaSize: checkVisibleAreaSize, validateBrowser: validateBrowser, validatePage: validatePage}}
 * @constructor
 */
var UIValidationUtils = function(settings, log) { // jshint ignore:line
    var document = window.document;
    /**
     * Check if visible area are enough to show menu.
     * @returns boolean. True if area enough
     */
    var checkVisibleAreaSize = function() {
        var viewPort = getViewPort();
        var visibleAreaSize = viewPort.height > settings.Constants.MINIMUM_VISIBLE_HEIGHT_TO_SHOW_BUTTON;

        if (!visibleAreaSize) {
            log.error('Viewport height is too small: ' + viewPort.height);
        }

        return visibleAreaSize;
    };

    var getViewPort = function() {
        var viewPortWidth;
        var viewPortHeight;

        viewPortWidth = window.innerWidth;
        viewPortHeight = window.innerHeight;

        return {
            width: viewPortWidth,
            height: viewPortHeight
        };
    };

    /**
     * Checks if browser is valid for Adguard assistant
     * @returns boolean. True if browser valid
     */
    var validateBrowser = function() {
        var valid = !document.documentMode || (document.documentMode > settings.Constants.MINIMUM_IE_SUPPORTED_VERSION);

        if (!valid) {
            log.error('IE version is ' + document.documentMode);
        }

        return valid;
    };

    /**
     * Checks if page is valid for Adguard assistant to work here.
     */
    var validatePage = function() {
        // Assistant do not work in iframes
        if (window.window !== window.top) {
            log.error('Page is iframe: ' + window.location.href);
            return false;
        }

        // Check for necessary html elements existence
        var head = !!document.getElementsByTagName('head').length;
        var body = !!document.getElementsByTagName('body').length;

        if (!head) {
            log.error('head is missing');
        }

        if (!body) {
            log.error('body is missing');
        }

        return head && body;
    };

    return {
        checkVisibleAreaSize: checkVisibleAreaSize,
        validateBrowser: validateBrowser,
        validatePage: validatePage,
        getViewPort: getViewPort
    };
};

/**
 * String utils
 */
var StringUtils = { // jshint ignore:line
    /**
     * Replaces the format items in a specified String with the text equivalents of the values of corresponding object instances.
     * @param format
     */
    format: function (format) {
        for (var i = 1; i < arguments.length; i++) {
            format = format.replace('{' + (i - 1) + '}', arguments[i]);
        }
        return format;
    }
};

/**
 * Common utils
 * @type {{getParentsLevel: Function, getNodeName: Function, getAllChilds: Function, getSingleChildren: Function, cropDomain: Function}}
 */
var CommonUtils = { // jshint ignore:line

    getParentsLevel: function (element) {
        var parent = element;
        var parentArr = [];
        while ((parent = parent.parentNode) && this.getNodeName(parent) !== "BODY") {
            parentArr.push(parent);
        }
        return parentArr;
    },

    getNodeName: function (element) {
        return element && element.nodeName ? element.nodeName.toUpperCase() : "";
    },

    getAllChildren: function (element) {
        var childArray = [];
        var child = element;
        while ((child = this.getSingleChildren(child))) {
            childArray.push(child);
        }
        return childArray;
    },

    getSingleChildren: function (element) {
        var children = element.childNodes;
        if (children) {
            var count = 0;
            var child;
            var i;
            for (i = 0; i < children.length; i++) {
                if (children[i].nodeType === 1) {
                    child = children[i];
                    count++;
                }
            }
            return count === 1 ? child : null;
        }
    },

    cropDomain: function (domain) {
        return domain.replace("www.", "").replace(/:\d+/, '');
    },

    /**
     * Force clear page cache
     * see: https://stackoverflow.com/questions/10719505/force-a-reload-of-page-in-chrome-using-javascript-no-cache/27058362#27058362
     */
    reloadPageBypassCache: function() {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', window.location.href, true);

        xhr.setRequestHeader('Pragma', 'no-cache');
        xhr.setRequestHeader('Expires', -1);
        xhr.setRequestHeader('Cache-Control', 'no-cache');

        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
                window.location.reload(true);
            }
        };

        xhr.send();
    }
};

/**
 * Base64 implementation
 * @type {{_keyStr: string, encode: Base64.encode, decode: Base64.decode, _utf8_encode: Base64._utf8_encode, _utf8_decode: Base64._utf8_decode}}
 */
var Base64 = {
    // private property
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    // public method for encoding
    encode: function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;

        input = Base64._utf8_encode(input);

        while (i < input.length) {

            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);

            // jshint ignore:start
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            // jshint ignore:end

            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }

            output = output +
                Base64._keyStr.charAt(enc1) + Base64._keyStr.charAt(enc2) +
                Base64._keyStr.charAt(enc3) + Base64._keyStr.charAt(enc4);

        }

        return output;
    },

    // public method for decoding
    decode: function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;

        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        while (i < input.length) {

            enc1 = Base64._keyStr.indexOf(input.charAt(i++));
            enc2 = Base64._keyStr.indexOf(input.charAt(i++));
            enc3 = Base64._keyStr.indexOf(input.charAt(i++));
            enc4 = Base64._keyStr.indexOf(input.charAt(i++));

            // jshint ignore:start
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            // jshint ignore:end

            output = output + String.fromCharCode(chr1);

            if (enc3 !== 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
                output = output + String.fromCharCode(chr3);
            }

        }

        output = Base64._utf8_decode(output);

        return output;

    },

    // private method for UTF-8 encoding
    _utf8_encode: function (string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";

        // jshint ignore:start
        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            } else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            } else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        // jshint ignore:end

        return utftext;
    },

    // private method for UTF-8 decoding
    _utf8_decode: function (utftext) {
        var string = "";
        var i = 0;
        var c = 0;
        var c2 = 0;
        var c3 = 0;

        while (i < utftext.length) {

            c = utftext.charCodeAt(i);

            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            } else if ((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i + 1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63)); // jshint ignore:line
                i += 2;
            } else {
                c2 = utftext.charCodeAt(i + 1);
                c3 = utftext.charCodeAt(i + 2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)); // jshint ignore:line
                i += 3;
            }

        }
        return string;
    }
};

/*! http://mths.be/punycode v1.3.0 by @mathias */
var punycode = (function (root) { //We use local variable because we don't want to spoil global scope

    /** Detect free variables */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    var freeModule = typeof module == 'object' && module && !module.nodeType && module;
    var freeGlobal = typeof global == 'object' && global;
    if (
        freeGlobal.global === freeGlobal ||
        freeGlobal.window === freeGlobal ||
        freeGlobal.self === freeGlobal
    ) {
        root = freeGlobal;
    }

    /**
     * The `punycode` object.
     * @name punycode
     * @type Object
     */
    var punycode,

        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        base = 36,
        tMin = 1,
        tMax = 26,
        skew = 38,
        damp = 700,
        initialBias = 72,
        initialN = 128, // 0x80
        delimiter = '-', // '\x2D'

        /** Regular expressions */
        regexPunycode = /^xn--/,
        regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

        /** Error messages */
        errors = {
            'overflow': 'Overflow: input needs wider integers to process',
            'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
            'invalid-input': 'Invalid input'
        },

        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
        floor = Math.floor,
        stringFromCharCode = String.fromCharCode,

        /** Temporary variable */
        key;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error(type) {
        throw RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
            result[length] = fn(array[length]);
        }
        return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(string, fn) {
        var labels = string.split(regexSeparators);
        // Note: each label could still contain `@` in the case of an email address.
        return map(labels, function (label) {
            var parts = label.split('@');
            return map(parts, fn).join('@');
        }).join('.');
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <http://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
        var output = [],
            counter = 0,
            length = string.length,
            value,
            extra;
        while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            } else {
                output.push(value);
            }
        }
        return output;
    }

    /**
     * Creates a string based on an array of numeric code points.
     * @see `punycode.ucs2.decode`
     * @memberOf punycode.ucs2
     * @name encode
     * @param {Array} codePoints The array of numeric code points.
     * @returns {String} The new Unicode string (UCS-2).
     */
    function ucs2encode(array) {
        return map(array, function (value) {
            var output = '';
            if (value > 0xFFFF) {
                value -= 0x10000;
                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
            return output;
        }).join('');
    }

    /**
     * Converts a basic code point into a digit/integer.
     * @see `digitToBasic()`
     * @private
     * @param {Number} codePoint The basic numeric code point value.
     * @returns {Number} The numeric value of a basic code point (for use in
     * representing integers) in the range `0` to `base - 1`, or `base` if
     * the code point does not represent a value.
     */
    function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
            return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
            return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
            return codePoint - 97;
        }
        return base;
    }

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * http://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }

    /**
     * Converts a Punycode string of ASCII-only symbols to a string of Unicode
     * symbols.
     * @memberOf punycode
     * @param {String} input The Punycode string of ASCII-only symbols.
     * @returns {String} The resulting string of Unicode symbols.
     */
    function decode(input) {
        // Don't use UCS-2
        var output = [],
            inputLength = input.length,
            out,
            i = 0,
            n = initialN,
            bias = initialBias,
            basic,
            j,
            index,
            oldi,
            w,
            k,
            digit,
            t,
            /** Cached calculation results */
            baseMinusT;

        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.

        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
            basic = 0;
        }

        for (j = 0; j < basic; ++j) {
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
                error('not-basic');
            }
            output.push(input.charCodeAt(j));
        }

        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.

        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

                if (index >= inputLength) {
                    error('invalid-input');
                }

                digit = basicToDigit(input.charCodeAt(index++));

                if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error('overflow');
                }

                i += digit * w;
                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

                if (digit < t) {
                    break;
                }

                baseMinusT = base - t;
                if (w > floor(maxInt / baseMinusT)) {
                    error('overflow');
                }

                w *= baseMinusT;

            }

            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);

            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
                error('overflow');
            }

            n += floor(i / out);
            i %= out;

            // Insert `n` at position `i` of the output
            output.splice(i++, 0, n);

        }

        return ucs2encode(output);
    }

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    function encode(input) {
        var n,
            delta,
            handledCPCount,
            basicLength,
            bias,
            j,
            m,
            q,
            k,
            t,
            currentValue,
            output = [],
            /** `inputLength` will hold the number of code points in `input`. */
            inputLength,
            /** Cached calculation results */
            handledCPCountPlusOne,
            baseMinusT,
            qMinusT;

        // Convert the input in UCS-2 to Unicode
        input = ucs2decode(input);

        // Cache the length
        inputLength = input.length;

        // Initialize the state
        n = initialN;
        delta = 0;
        bias = initialBias;

        // Handle the basic code points
        for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
                output.push(stringFromCharCode(currentValue));
            }
        }

        handledCPCount = basicLength = output.length;

        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.

        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) {
            output.push(delimiter);
        }

        // Main encoding loop:
        while (handledCPCount < inputLength) {

            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                }
            }

            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                error('overflow');
            }

            delta += (m - n) * handledCPCountPlusOne;
            n = m;

            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];

                if (currentValue < n && ++delta > maxInt) {
                    error('overflow');
                }

                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = base; /* no condition */; k += base) {
                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                        if (q < t) {
                            break;
                        }
                        qMinusT = q - t;
                        baseMinusT = base - t;
                        output.push(
                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                        );
                        q = floor(qMinusT / baseMinusT);
                    }

                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }

            ++delta;
            ++n;

        }
        return output.join('');
    }

    /**
     * Converts a Punycode string representing a domain name or an email address
     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
     * it doesn't matter if you call it on a string that has already been
     * converted to Unicode.
     * @memberOf punycode
     * @param {String} input The Punycoded domain name or email address to
     * convert to Unicode.
     * @returns {String} The Unicode representation of the given Punycode
     * string.
     */
    function toUnicode(input) {
        return mapDomain(input, function (string) {
            return regexPunycode.test(string)
                ? decode(string.slice(4).toLowerCase())
                : string;
        });
    }

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    function toASCII(input) {
        return mapDomain(input, function (string) {
            return regexNonASCII.test(string)
                ? 'xn--' + encode(string)
                : string;
        });
    }

    /*--------------------------------------------------------------------------*/

    /** Define the public API */
    punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        'version': '1.3.0',
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <http://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        'ucs2': {
            'decode': ucs2decode,
            'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
    };

    /** Expose `punycode` */
    // Some AMD build optimizers, like r.js, check for specific condition patterns
    // like the following:
    // if (typeof exports !== 'undefined') {
    //     exports.punycode = punycode;
    // } else if (
    //     typeof define == 'function' &&
    //     typeof define.amd == 'object' &&
    //     define.amd
    // ) {
    //     define('punycode', function () {
    //         return punycode;
    //     });
    // } else if (freeExports && freeModule) {
    //     if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
    //         freeModule.exports = punycode;
    //     } else { // in Narwhal or RingoJS v0.7.0-
    //         for (key in punycode) {
    //             punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
    //         }
    //     }
    // } else { // in Rhino or a web browser
    //     root.punycode = punycode;
    // }
    return punycode;

}(this));
/**
 * Custom event
 * @returns {{attach: attach, notify: notify}}
 * @constructor
 */
var CustomEvent = function () { // jshint ignore:line
    var listeners = [];

    var attach = function (listener) {
        listeners.push(listener);
    };

    var notify = function (args) {
        for (var i = 0; i < listeners.length; i++) {
            listeners[i](args);
        }
    };

    return {
        attach: attach,
        notify: notify
    };
};

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

    // Defaults.
    // Redefine these in your program to override the defaults.

    // Number of seconds to map a diff before giving up (0 for infinity).
    this.Diff_Timeout = 1.0;
    // Cost of an empty edit operation in terms of edit characters.
    this.Diff_EditCost = 4;
    // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
    this.Match_Threshold = 0.5;
    // How far to search for a match (0 = exact location, 1000+ = broad match).
    // A match this many characters away from the expected location will add
    // 1.0 to the score (0.0 is a perfect match).
    this.Match_Distance = 1000;
    // When deleting a large block of text (over ~64 characters), how close do
    // the contents have to be to match the expected contents. (0.0 = perfection,
    // 1.0 = very loose).  Note that Match_Threshold controls how closely the
    // end points of a delete need to match.
    this.Patch_DeleteThreshold = 0.5;
    // Chunk size for context length.
    this.Patch_Margin = 4;

    // The number of bits in an int.
    this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.Diff;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
                                                opt_deadline) {
    // Set a deadline by which time the diff must be complete.
    if (typeof opt_deadline == 'undefined') {
        if (this.Diff_Timeout <= 0) {
            opt_deadline = Number.MAX_VALUE;
        } else {
            opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
        }
    }
    var deadline = opt_deadline;

    // Check for null inputs.
    if (text1 == null || text2 == null) {
        throw new Error('Null input. (diff_main)');
    }

    // Check for equality (speedup).
    if (text1 == text2) {
        if (text1) {
            return [[DIFF_EQUAL, text1]];
        }
        return [];
    }

    if (typeof opt_checklines == 'undefined') {
        opt_checklines = true;
    }
    var checklines = opt_checklines;

    // Trim off common prefix (speedup).
    var commonlength = this.diff_commonPrefix(text1, text2);
    var commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);

    // Trim off common suffix (speedup).
    commonlength = this.diff_commonSuffix(text1, text2);
    var commonsuffix = text1.substring(text1.length - commonlength);
    text1 = text1.substring(0, text1.length - commonlength);
    text2 = text2.substring(0, text2.length - commonlength);

    // Compute the diff on the middle block.
    var diffs = this.diff_compute_(text1, text2, checklines, deadline);

    // Restore the prefix and suffix.
    if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
    }
    if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
    }
    this.diff_cleanupMerge(diffs);
    return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
                                                    deadline) {
    var diffs;

    if (!text1) {
        // Just add some text (speedup).
        return [[DIFF_INSERT, text2]];
    }

    if (!text2) {
        // Just delete some text (speedup).
        return [[DIFF_DELETE, text1]];
    }

    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    var i = longtext.indexOf(shorttext);
    if (i != -1) {
        // Shorter text is inside the longer text (speedup).
        diffs = [[DIFF_INSERT, longtext.substring(0, i)],
            [DIFF_EQUAL, shorttext],
            [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
        // Swap insertions for deletions if diff is reversed.
        if (text1.length > text2.length) {
            diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
    }

    if (shorttext.length == 1) {
        // Single character string.
        // After the previous speedup, the character can't be an equality.
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }

    // Check to see if the problem can be split in two.
    var hm = this.diff_halfMatch_(text1, text2);
    if (hm) {
        // A half-match was found, sort out the return data.
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        // Send both pairs off for separate processing.
        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
        // Merge the results.
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
    }

    if (checklines && text1.length > 100 && text2.length > 100) {
        return this.diff_lineMode_(text1, text2, deadline);
    }

    return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
    // Scan the text on a line-by-line basis first.
    var a = this.diff_linesToChars_(text1, text2);
    text1 = a.chars1;
    text2 = a.chars2;
    var linearray = a.lineArray;

    var diffs = this.diff_main(text1, text2, false, deadline);

    // Convert the diff back to original text.
    this.diff_charsToLines_(diffs, linearray);
    // Eliminate freak matches (e.g. blank lines)
    this.diff_cleanupSemantic(diffs);

    // Rediff any replacement blocks, this time character-by-character.
    // Add a dummy entry at the end.
    diffs.push([DIFF_EQUAL, '']);
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
            case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                break;
            case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                break;
            case DIFF_EQUAL:
                // Upon reaching an equality, check for prior redundancies.
                if (count_delete >= 1 && count_insert >= 1) {
                    // Delete the offending records and add the merged ones.
                    diffs.splice(pointer - count_delete - count_insert,
                        count_delete + count_insert);
                    pointer = pointer - count_delete - count_insert;
                    var a = this.diff_main(text_delete, text_insert, false, deadline);
                    for (var j = a.length - 1; j >= 0; j--) {
                        diffs.splice(pointer, 0, a[j]);
                    }
                    pointer = pointer + a.length;
                }
                count_insert = 0;
                count_delete = 0;
                text_delete = '';
                text_insert = '';
                break;
        }
        pointer++;
    }
    diffs.pop();  // Remove the dummy entry at the end.

    return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
    // Cache the text lengths to prevent multiple calls.
    var text1_length = text1.length;
    var text2_length = text2.length;
    var max_d = Math.ceil((text1_length + text2_length) / 2);
    var v_offset = max_d;
    var v_length = 2 * max_d;
    var v1 = new Array(v_length);
    var v2 = new Array(v_length);
    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
    // integers and undefined.
    for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
    }
    v1[v_offset + 1] = 0;
    v2[v_offset + 1] = 0;
    var delta = text1_length - text2_length;
    // If the total number of characters is odd, then the front path will collide
    // with the reverse path.
    var front = (delta % 2 != 0);
    // Offsets for start and end of k loop.
    // Prevents mapping of space beyond the grid.
    var k1start = 0;
    var k1end = 0;
    var k2start = 0;
    var k2end = 0;
    for (var d = 0; d < max_d; d++) {
        // Bail out if deadline is reached.
        if ((new Date()).getTime() > deadline) {
            break;
        }

        // Walk the front path one step.
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
            var k1_offset = v_offset + k1;
            var x1;
            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
                x1 = v1[k1_offset + 1];
            } else {
                x1 = v1[k1_offset - 1] + 1;
            }
            var y1 = x1 - k1;
            while (x1 < text1_length && y1 < text2_length &&
            text1.charAt(x1) == text2.charAt(y1)) {
                x1++;
                y1++;
            }
            v1[k1_offset] = x1;
            if (x1 > text1_length) {
                // Ran off the right of the graph.
                k1end += 2;
            } else if (y1 > text2_length) {
                // Ran off the bottom of the graph.
                k1start += 2;
            } else if (front) {
                var k2_offset = v_offset + delta - k1;
                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
                    // Mirror x2 onto top-left coordinate system.
                    var x2 = text1_length - v2[k2_offset];
                    if (x1 >= x2) {
                        // Overlap detected.
                        return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
                    }
                }
            }
        }

        // Walk the reverse path one step.
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
            var k2_offset = v_offset + k2;
            var x2;
            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
                x2 = v2[k2_offset + 1];
            } else {
                x2 = v2[k2_offset - 1] + 1;
            }
            var y2 = x2 - k2;
            while (x2 < text1_length && y2 < text2_length &&
            text1.charAt(text1_length - x2 - 1) ==
            text2.charAt(text2_length - y2 - 1)) {
                x2++;
                y2++;
            }
            v2[k2_offset] = x2;
            if (x2 > text1_length) {
                // Ran off the left of the graph.
                k2end += 2;
            } else if (y2 > text2_length) {
                // Ran off the top of the graph.
                k2start += 2;
            } else if (!front) {
                var k1_offset = v_offset + delta - k2;
                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
                    var x1 = v1[k1_offset];
                    var y1 = v_offset + x1 - k1_offset;
                    // Mirror x2 onto top-left coordinate system.
                    x2 = text1_length - x2;
                    if (x1 >= x2) {
                        // Overlap detected.
                        return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
                    }
                }
            }
        }
    }
    // Diff took too long and hit the deadline or
    // number of diffs equals number of characters, no commonality at all.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
                                                        deadline) {
    var text1a = text1.substring(0, x);
    var text2a = text2.substring(0, y);
    var text1b = text1.substring(x);
    var text2b = text2.substring(y);

    // Compute both diffs serially.
    var diffs = this.diff_main(text1a, text2a, false, deadline);
    var diffsb = this.diff_main(text1b, text2b, false, deadline);

    return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
    var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
    var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

    // '\x00' is a valid character, but various debuggers don't like it.
    // So we'll insert a junk entry to avoid generating a null character.
    lineArray[0] = '';

    /**
     * Split a text into an array of strings.  Reduce the texts to a string of
     * hashes where each Unicode character represents one line.
     * Modifies linearray and linehash through being a closure.
     * @param {string} text String to encode.
     * @return {string} Encoded string.
     * @private
     */
    function diff_linesToCharsMunge_(text) {
        var chars = '';
        // Walk the text, pulling out a substring for each line.
        // text.split('\n') would would temporarily double our memory footprint.
        // Modifying text would create many large strings to garbage collect.
        var lineStart = 0;
        var lineEnd = -1;
        // Keeping our own length variable is faster than looking it up.
        var lineArrayLength = lineArray.length;
        while (lineEnd < text.length - 1) {
            lineEnd = text.indexOf('\n', lineStart);
            if (lineEnd == -1) {
                lineEnd = text.length - 1;
            }
            var line = text.substring(lineStart, lineEnd + 1);
            lineStart = lineEnd + 1;

            if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
                    (lineHash[line] !== undefined)) {
                chars += String.fromCharCode(lineHash[line]);
            } else {
                chars += String.fromCharCode(lineArrayLength);
                lineHash[line] = lineArrayLength;
                lineArray[lineArrayLength++] = line;
            }
        }
        return chars;
    }

    var chars1 = diff_linesToCharsMunge_(text1);
    var chars2 = diff_linesToCharsMunge_(text2);
    return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
    for (var x = 0; x < diffs.length; x++) {
        var chars = diffs[x][1];
        var text = [];
        for (var y = 0; y < chars.length; y++) {
            text[y] = lineArray[chars.charCodeAt(y)];
        }
        diffs[x][1] = text.join('');
    }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
    }
    // Binary search.
    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerstart = 0;
    while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) ==
            text2.substring(pointerstart, pointermid)) {
            pointermin = pointermid;
            pointerstart = pointermin;
        } else {
            pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
    // Quick check for common null cases.
    if (!text1 || !text2 ||
        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
    }
    // Binary search.
    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
    var pointermin = 0;
    var pointermax = Math.min(text1.length, text2.length);
    var pointermid = pointermax;
    var pointerend = 0;
    while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
            pointermin = pointermid;
            pointerend = pointermin;
        } else {
            pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
    }
    return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
    // Cache the text lengths to prevent multiple calls.
    var text1_length = text1.length;
    var text2_length = text2.length;
    // Eliminate the null case.
    if (text1_length == 0 || text2_length == 0) {
        return 0;
    }
    // Truncate the longer string.
    if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
    } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
    }
    var text_length = Math.min(text1_length, text2_length);
    // Quick check for the worst case.
    if (text1 == text2) {
        return text_length;
    }

    // Start by looking for a single character match
    // and increase length until no match is found.
    // Performance analysis: http://neil.fraser.name/news/2010/11/04/
    var best = 0;
    var length = 1;
    while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
            return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) ==
            text2.substring(0, length)) {
            best = length;
            length++;
        }
    }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
    if (this.Diff_Timeout <= 0) {
        // Don't risk returning a non-optimal diff if we have unlimited time.
        return null;
    }
    var longtext = text1.length > text2.length ? text1 : text2;
    var shorttext = text1.length > text2.length ? text2 : text1;
    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;  // Pointless.
    }
    var dmp = this;  // 'this' becomes 'window' in a closure.

    /**
     * Does a substring of shorttext exist within longtext such that the substring
     * is at least half the length of longtext?
     * Closure, but does not reference any external variables.
     * @param {string} longtext Longer string.
     * @param {string} shorttext Shorter string.
     * @param {number} i Start index of quarter length substring within longtext.
     * @return {Array.<string>} Five element Array, containing the prefix of
     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
     *     of shorttext and the common middle.  Or null if there was no match.
     * @private
     */
    function diff_halfMatchI_(longtext, shorttext, i) {
        // Start with a 1/4 length substring at position i as a seed.
        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
        var j = -1;
        var best_common = '';
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
            var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                shorttext.substring(j));
            var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                shorttext.substring(0, j));
            if (best_common.length < suffixLength + prefixLength) {
                best_common = shorttext.substring(j - suffixLength, j) +
                    shorttext.substring(j, j + prefixLength);
                best_longtext_a = longtext.substring(0, i - suffixLength);
                best_longtext_b = longtext.substring(i + prefixLength);
                best_shorttext_a = shorttext.substring(0, j - suffixLength);
                best_shorttext_b = shorttext.substring(j + prefixLength);
            }
        }
        if (best_common.length * 2 >= longtext.length) {
            return [best_longtext_a, best_longtext_b,
                best_shorttext_a, best_shorttext_b, best_common];
        } else {
            return null;
        }
    }

    // First check if the second quarter is the seed for a half-match.
    var hm1 = diff_halfMatchI_(longtext, shorttext,
        Math.ceil(longtext.length / 4));
    // Check again based on the third quarter.
    var hm2 = diff_halfMatchI_(longtext, shorttext,
        Math.ceil(longtext.length / 2));
    var hm;
    if (!hm1 && !hm2) {
        return null;
    } else if (!hm2) {
        hm = hm1;
    } else if (!hm1) {
        hm = hm2;
    } else {
        // Both matched.  Select the longest.
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
    }

    // A half-match was found, sort out the return data.
    var text1_a, text1_b, text2_a, text2_b;
    if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
    } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
    }
    var mid_common = hm[4];
    return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
    var changes = false;
    var equalities = [];  // Stack of indices where equalities are found.
    var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
    /** @type {?string} */
    var lastequality = null;
    // Always equal to diffs[equalities[equalitiesLength - 1]][1]
    var pointer = 0;  // Index of current position.
    // Number of characters that changed prior to the equality.
    var length_insertions1 = 0;
    var length_deletions1 = 0;
    // Number of characters that changed after the equality.
    var length_insertions2 = 0;
    var length_deletions2 = 0;
    while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
            equalities[equalitiesLength++] = pointer;
            length_insertions1 = length_insertions2;
            length_deletions1 = length_deletions2;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = diffs[pointer][1];
        } else {  // An insertion or deletion.
            if (diffs[pointer][0] == DIFF_INSERT) {
                length_insertions2 += diffs[pointer][1].length;
            } else {
                length_deletions2 += diffs[pointer][1].length;
            }
            // Eliminate an equality that is smaller or equal to the edits on both
            // sides of it.
            if (lastequality && (lastequality.length <=
                Math.max(length_insertions1, length_deletions1)) &&
                (lastequality.length <= Math.max(length_insertions2,
                    length_deletions2))) {
                // Duplicate record.
                diffs.splice(equalities[equalitiesLength - 1], 0,
                    [DIFF_DELETE, lastequality]);
                // Change second copy to insert.
                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                // Throw away the equality we just deleted.
                equalitiesLength--;
                // Throw away the previous equality (it needs to be reevaluated).
                equalitiesLength--;
                pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
                length_insertions1 = 0;  // Reset the counters.
                length_deletions1 = 0;
                length_insertions2 = 0;
                length_deletions2 = 0;
                lastequality = null;
                changes = true;
            }
        }
        pointer++;
    }

    // Normalize the diff.
    if (changes) {
        this.diff_cleanupMerge(diffs);
    }
    this.diff_cleanupSemanticLossless(diffs);

    // Find any overlaps between deletions and insertions.
    // e.g: <del>abcxxx</del><ins>xxxdef</ins>
    //   -> <del>abc</del>xxx<ins>def</ins>
    // e.g: <del>xxxabc</del><ins>defxxx</ins>
    //   -> <ins>def</ins>xxx<del>abc</del>
    // Only extract an overlap if it is as big as the edit ahead or behind it.
    pointer = 1;
    while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE &&
            diffs[pointer][0] == DIFF_INSERT) {
            var deletion = diffs[pointer - 1][1];
            var insertion = diffs[pointer][1];
            var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
            var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
            if (overlap_length1 >= overlap_length2) {
                if (overlap_length1 >= deletion.length / 2 ||
                    overlap_length1 >= insertion.length / 2) {
                    // Overlap found.  Insert an equality and trim the surrounding edits.
                    diffs.splice(pointer, 0,
                        [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
                    diffs[pointer - 1][1] =
                        deletion.substring(0, deletion.length - overlap_length1);
                    diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                    pointer++;
                }
            } else {
                if (overlap_length2 >= deletion.length / 2 ||
                    overlap_length2 >= insertion.length / 2) {
                    // Reverse overlap found.
                    // Insert an equality and swap and trim the surrounding edits.
                    diffs.splice(pointer, 0,
                        [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
                    diffs[pointer - 1][0] = DIFF_INSERT;
                    diffs[pointer - 1][1] =
                        insertion.substring(0, insertion.length - overlap_length2);
                    diffs[pointer + 1][0] = DIFF_DELETE;
                    diffs[pointer + 1][1] =
                        deletion.substring(overlap_length2);
                    pointer++;
                }
            }
            pointer++;
        }
        pointer++;
    }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
    /**
     * Given two strings, compute a score representing whether the internal
     * boundary falls on logical boundaries.
     * Scores range from 6 (best) to 0 (worst).
     * Closure, but does not reference any external variables.
     * @param {string} one First string.
     * @param {string} two Second string.
     * @return {number} The score.
     * @private
     */
    function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
            // Edges are the best.
            return 6;
        }

        // Each port of this function behaves slightly differently due to
        // subtle differences in each language's definition of things like
        // 'whitespace'.  Since this function's purpose is largely cosmetic,
        // the choice has been made to use each language's native features
        // rather than force total conformity.
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 &&
            char1.match(diff_match_patch.whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 &&
            char2.match(diff_match_patch.whitespaceRegex_);
        var lineBreak1 = whitespace1 &&
            char1.match(diff_match_patch.linebreakRegex_);
        var lineBreak2 = whitespace2 &&
            char2.match(diff_match_patch.linebreakRegex_);
        var blankLine1 = lineBreak1 &&
            one.match(diff_match_patch.blanklineEndRegex_);
        var blankLine2 = lineBreak2 &&
            two.match(diff_match_patch.blanklineStartRegex_);

        if (blankLine1 || blankLine2) {
            // Five points for blank lines.
            return 5;
        } else if (lineBreak1 || lineBreak2) {
            // Four points for line breaks.
            return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
            // Three points for end of sentences.
            return 3;
        } else if (whitespace1 || whitespace2) {
            // Two points for whitespace.
            return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
            // One point for non-alphanumeric.
            return 1;
        }
        return 0;
    }

    var pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL &&
            diffs[pointer + 1][0] == DIFF_EQUAL) {
            // This is a single edit surrounded by equalities.
            var equality1 = diffs[pointer - 1][1];
            var edit = diffs[pointer][1];
            var equality2 = diffs[pointer + 1][1];

            // First, shift the edit as far left as possible.
            var commonOffset = this.diff_commonSuffix(equality1, edit);
            if (commonOffset) {
                var commonString = edit.substring(edit.length - commonOffset);
                equality1 = equality1.substring(0, equality1.length - commonOffset);
                edit = commonString + edit.substring(0, edit.length - commonOffset);
                equality2 = commonString + equality2;
            }

            // Second, step character by character right, looking for the best fit.
            var bestEquality1 = equality1;
            var bestEdit = edit;
            var bestEquality2 = equality2;
            var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
                diff_cleanupSemanticScore_(edit, equality2);
            while (edit.charAt(0) === equality2.charAt(0)) {
                equality1 += edit.charAt(0);
                edit = edit.substring(1) + equality2.charAt(0);
                equality2 = equality2.substring(1);
                var score = diff_cleanupSemanticScore_(equality1, edit) +
                    diff_cleanupSemanticScore_(edit, equality2);
                // The >= encourages trailing rather than leading whitespace on edits.
                if (score >= bestScore) {
                    bestScore = score;
                    bestEquality1 = equality1;
                    bestEdit = edit;
                    bestEquality2 = equality2;
                }
            }

            if (diffs[pointer - 1][1] != bestEquality1) {
                // We have an improvement, save it back to the diff.
                if (bestEquality1) {
                    diffs[pointer - 1][1] = bestEquality1;
                } else {
                    diffs.splice(pointer - 1, 1);
                    pointer--;
                }
                diffs[pointer][1] = bestEdit;
                if (bestEquality2) {
                    diffs[pointer + 1][1] = bestEquality2;
                } else {
                    diffs.splice(pointer + 1, 1);
                    pointer--;
                }
            }
        }
        pointer++;
    }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
    var changes = false;
    var equalities = [];  // Stack of indices where equalities are found.
    var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
    /** @type {?string} */
    var lastequality = null;
    // Always equal to diffs[equalities[equalitiesLength - 1]][1]
    var pointer = 0;  // Index of current position.
    // Is there an insertion operation before the last equality.
    var pre_ins = false;
    // Is there a deletion operation before the last equality.
    var pre_del = false;
    // Is there an insertion operation after the last equality.
    var post_ins = false;
    // Is there a deletion operation after the last equality.
    var post_del = false;
    while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
            if (diffs[pointer][1].length < this.Diff_EditCost &&
                (post_ins || post_del)) {
                // Candidate found.
                equalities[equalitiesLength++] = pointer;
                pre_ins = post_ins;
                pre_del = post_del;
                lastequality = diffs[pointer][1];
            } else {
                // Not a candidate, and can never become one.
                equalitiesLength = 0;
                lastequality = null;
            }
            post_ins = post_del = false;
        } else {  // An insertion or deletion.
            if (diffs[pointer][0] == DIFF_DELETE) {
                post_del = true;
            } else {
                post_ins = true;
            }
            /*
             * Five types to be split:
             * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
             * <ins>A</ins>X<ins>C</ins><del>D</del>
             * <ins>A</ins><del>B</del>X<ins>C</ins>
             * <ins>A</del>X<ins>C</ins><del>D</del>
             * <ins>A</ins><del>B</del>X<del>C</del>
             */
            if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                ((lastequality.length < this.Diff_EditCost / 2) &&
                (pre_ins + pre_del + post_ins + post_del) == 3))) {
                // Duplicate record.
                diffs.splice(equalities[equalitiesLength - 1], 0,
                    [DIFF_DELETE, lastequality]);
                // Change second copy to insert.
                diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
                equalitiesLength--;  // Throw away the equality we just deleted;
                lastequality = null;
                if (pre_ins && pre_del) {
                    // No changes made which could affect previous entry, keep going.
                    post_ins = post_del = true;
                    equalitiesLength = 0;
                } else {
                    equalitiesLength--;  // Throw away the previous equality.
                    pointer = equalitiesLength > 0 ?
                        equalities[equalitiesLength - 1] : -1;
                    post_ins = post_del = false;
                }
                changes = true;
            }
        }
        pointer++;
    }

    if (changes) {
        this.diff_cleanupMerge(diffs);
    }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
    diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
    var pointer = 0;
    var count_delete = 0;
    var count_insert = 0;
    var text_delete = '';
    var text_insert = '';
    var commonlength;
    while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
            case DIFF_INSERT:
                count_insert++;
                text_insert += diffs[pointer][1];
                pointer++;
                break;
            case DIFF_DELETE:
                count_delete++;
                text_delete += diffs[pointer][1];
                pointer++;
                break;
            case DIFF_EQUAL:
                // Upon reaching an equality, check for prior redundancies.
                if (count_delete + count_insert > 1) {
                    if (count_delete !== 0 && count_insert !== 0) {
                        // Factor out any common prefixies.
                        commonlength = this.diff_commonPrefix(text_insert, text_delete);
                        if (commonlength !== 0) {
                            if ((pointer - count_delete - count_insert) > 0 &&
                                diffs[pointer - count_delete - count_insert - 1][0] ==
                                DIFF_EQUAL) {
                                diffs[pointer - count_delete - count_insert - 1][1] +=
                                    text_insert.substring(0, commonlength);
                            } else {
                                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                                pointer++;
                            }
                            text_insert = text_insert.substring(commonlength);
                            text_delete = text_delete.substring(commonlength);
                        }
                        // Factor out any common suffixies.
                        commonlength = this.diff_commonSuffix(text_insert, text_delete);
                        if (commonlength !== 0) {
                            diffs[pointer][1] = text_insert.substring(text_insert.length -
                                    commonlength) + diffs[pointer][1];
                            text_insert = text_insert.substring(0, text_insert.length -
                                commonlength);
                            text_delete = text_delete.substring(0, text_delete.length -
                                commonlength);
                        }
                    }
                    // Delete the offending records and add the merged ones.
                    if (count_delete === 0) {
                        diffs.splice(pointer - count_insert,
                            count_delete + count_insert, [DIFF_INSERT, text_insert]);
                    } else if (count_insert === 0) {
                        diffs.splice(pointer - count_delete,
                            count_delete + count_insert, [DIFF_DELETE, text_delete]);
                    } else {
                        diffs.splice(pointer - count_delete - count_insert,
                            count_delete + count_insert, [DIFF_DELETE, text_delete],
                            [DIFF_INSERT, text_insert]);
                    }
                    pointer = pointer - count_delete - count_insert +
                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
                } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
                    // Merge this equality with the previous one.
                    diffs[pointer - 1][1] += diffs[pointer][1];
                    diffs.splice(pointer, 1);
                } else {
                    pointer++;
                }
                count_insert = 0;
                count_delete = 0;
                text_delete = '';
                text_insert = '';
                break;
        }
    }
    if (diffs[diffs.length - 1][1] === '') {
        diffs.pop();  // Remove the dummy entry at the end.
    }

    // Second pass: look for single edits surrounded on both sides by equalities
    // which can be shifted sideways to eliminate an equality.
    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
    var changes = false;
    pointer = 1;
    // Intentionally ignore the first and last element (don't need checking).
    while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL &&
            diffs[pointer + 1][0] == DIFF_EQUAL) {
            // This is a single edit surrounded by equalities.
            if (diffs[pointer][1].substring(diffs[pointer][1].length -
                    diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
                // Shift the edit over the previous equality.
                diffs[pointer][1] = diffs[pointer - 1][1] +
                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
                        diffs[pointer - 1][1].length);
                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
                diffs.splice(pointer - 1, 1);
                changes = true;
            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
                diffs[pointer + 1][1]) {
                // Shift the edit over the next equality.
                diffs[pointer - 1][1] += diffs[pointer + 1][1];
                diffs[pointer][1] =
                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
                    diffs[pointer + 1][1];
                diffs.splice(pointer + 1, 1);
                changes = true;
            }
        }
        pointer++;
    }
    // If shifts were made, the diff needs reordering and another shift sweep.
    if (changes) {
        this.diff_cleanupMerge(diffs);
    }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
    var chars1 = 0;
    var chars2 = 0;
    var last_chars1 = 0;
    var last_chars2 = 0;
    var x;
    for (x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
            chars1 += diffs[x][1].length;
        }
        if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
            chars2 += diffs[x][1].length;
        }
        if (chars1 > loc) {  // Overshot the location.
            break;
        }
        last_chars1 = chars1;
        last_chars2 = chars2;
    }
    // Was the location was deleted?
    if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
        return last_chars2;
    }
    // Add the remaining character length.
    return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
    var html = [];
    var pattern_amp = /&/g;
    var pattern_lt = /</g;
    var pattern_gt = />/g;
    var pattern_para = /\n/g;
    for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];    // Operation (insert, delete, equal)
        var data = diffs[x][1];  // Text of change.
        var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
            .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
        switch (op) {
            case DIFF_INSERT:
                html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
                break;
            case DIFF_DELETE:
                html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
                break;
            case DIFF_EQUAL:
                html[x] = '<span>' + text + '</span>';
                break;
        }
    }
    return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
            text[x] = diffs[x][1];
        }
    }
    return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_DELETE) {
            text[x] = diffs[x][1];
        }
    }
    return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
    var levenshtein = 0;
    var insertions = 0;
    var deletions = 0;
    for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        switch (op) {
            case DIFF_INSERT:
                insertions += data.length;
                break;
            case DIFF_DELETE:
                deletions += data.length;
                break;
            case DIFF_EQUAL:
                // A deletion and an insertion is one substitution.
                levenshtein += Math.max(insertions, deletions);
                insertions = 0;
                deletions = 0;
                break;
        }
    }
    levenshtein += Math.max(insertions, deletions);
    return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
    var text = [];
    for (var x = 0; x < diffs.length; x++) {
        switch (diffs[x][0]) {
            case DIFF_INSERT:
                text[x] = '+' + encodeURI(diffs[x][1]);
                break;
            case DIFF_DELETE:
                text[x] = '-' + diffs[x][1].length;
                break;
            case DIFF_EQUAL:
                text[x] = '=' + diffs[x][1].length;
                break;
        }
    }
    return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
    var diffs = [];
    var diffsLength = 0;  // Keeping our own length var is faster in JS.
    var pointer = 0;  // Cursor in text1
    var tokens = delta.split(/\t/g);
    for (var x = 0; x < tokens.length; x++) {
        // Each token begins with a one character parameter which specifies the
        // operation of this token (delete, insert, equality).
        var param = tokens[x].substring(1);
        switch (tokens[x].charAt(0)) {
            case '+':
                try {
                    diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
                } catch (ex) {
                    // Malformed URI sequence.
                    throw new Error('Illegal escape in diff_fromDelta: ' + param);
                }
                break;
            case '-':
            // Fall through.
            case '=':
                var n = parseInt(param, 10);
                if (isNaN(n) || n < 0) {
                    throw new Error('Invalid number in diff_fromDelta: ' + param);
                }
                var text = text1.substring(pointer, pointer += n);
                if (tokens[x].charAt(0) == '=') {
                    diffs[diffsLength++] = [DIFF_EQUAL, text];
                } else {
                    diffs[diffsLength++] = [DIFF_DELETE, text];
                }
                break;
            default:
                // Blank tokens are ok (from a trailing \t).
                // Anything else is an error.
                if (tokens[x]) {
                    throw new Error('Invalid diff operation in diff_fromDelta: ' +
                        tokens[x]);
                }
        }
    }
    if (pointer != text1.length) {
        throw new Error('Delta length (' + pointer +
            ') does not equal source text length (' + text1.length + ').');
    }
    return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
    // Check for null inputs.
    if (text == null || pattern == null || loc == null) {
        throw new Error('Null input. (match_main)');
    }

    loc = Math.max(0, Math.min(loc, text.length));
    if (text == pattern) {
        // Shortcut (potentially not guaranteed by the algorithm)
        return 0;
    } else if (!text.length) {
        // Nothing to match.
        return -1;
    } else if (text.substring(loc, loc + pattern.length) == pattern) {
        // Perfect match at the perfect spot!  (Includes case of null pattern)
        return loc;
    } else {
        // Do a fuzzy compare.
        return this.match_bitap_(text, pattern, loc);
    }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
    if (pattern.length > this.Match_MaxBits) {
        throw new Error('Pattern too long for this browser.');
    }

    // Initialise the alphabet.
    var s = this.match_alphabet_(pattern);

    var dmp = this;  // 'this' becomes 'window' in a closure.

    /**
     * Compute and return the score for a match with e errors and x location.
     * Accesses loc and pattern through being a closure.
     * @param {number} e Number of errors in match.
     * @param {number} x Location of match.
     * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
     * @private
     */
    function match_bitapScore_(e, x) {
        var accuracy = e / pattern.length;
        var proximity = Math.abs(loc - x);
        if (!dmp.Match_Distance) {
            // Dodge divide by zero error.
            return proximity ? 1.0 : accuracy;
        }
        return accuracy + (proximity / dmp.Match_Distance);
    }

    // Highest score beyond which we give up.
    var score_threshold = this.Match_Threshold;
    // Is there a nearby exact match? (speedup)
    var best_loc = text.indexOf(pattern, loc);
    if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        // What about in the other direction? (speedup)
        best_loc = text.lastIndexOf(pattern, loc + pattern.length);
        if (best_loc != -1) {
            score_threshold =
                Math.min(match_bitapScore_(0, best_loc), score_threshold);
        }
    }

    // Initialise the bit arrays.
    var matchmask = 1 << (pattern.length - 1);
    best_loc = -1;

    var bin_min, bin_mid;
    var bin_max = pattern.length + text.length;
    var last_rd;
    for (var d = 0; d < pattern.length; d++) {
        // Scan for the best match; each iteration allows for one more error.
        // Run a binary search to determine how far from 'loc' we can stray at this
        // error level.
        bin_min = 0;
        bin_mid = bin_max;
        while (bin_min < bin_mid) {
            if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
                bin_min = bin_mid;
            } else {
                bin_max = bin_mid;
            }
            bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
        }
        // Use the result from this iteration as the maximum for the next.
        bin_max = bin_mid;
        var start = Math.max(1, loc - bin_mid + 1);
        var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

        var rd = Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for (var j = finish; j >= start; j--) {
            // The alphabet (s) is a sparse hash, so the following line generates
            // warnings.
            var charMatch = s[text.charAt(j - 1)];
            if (d === 0) {  // First pass: exact match.
                rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
            } else {  // Subsequent passes: fuzzy match.
                rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                    (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                    last_rd[j + 1];
            }
            if (rd[j] & matchmask) {
                var score = match_bitapScore_(d, j - 1);
                // This match will almost certainly be better than any existing match.
                // But check anyway.
                if (score <= score_threshold) {
                    // Told you so.
                    score_threshold = score;
                    best_loc = j - 1;
                    if (best_loc > loc) {
                        // When passing loc, don't exceed our current distance from loc.
                        start = Math.max(1, 2 * loc - best_loc);
                    } else {
                        // Already passed loc, downhill from here on in.
                        break;
                    }
                }
            }
        }
        // No hope for a (better) match at greater error levels.
        if (match_bitapScore_(d + 1, loc) > score_threshold) {
            break;
        }
        last_rd = rd;
    }
    return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
    var s = {};
    for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] = 0;
    }
    for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
    }
    return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
    if (text.length == 0) {
        return;
    }
    var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
    var padding = 0;

    // Look for the first and last matches of pattern in text.  If two different
    // matches are found, increase the pattern length.
    while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
    pattern.length < this.Match_MaxBits - this.Patch_Margin -
    this.Patch_Margin) {
        padding += this.Patch_Margin;
        pattern = text.substring(patch.start2 - padding,
            patch.start2 + patch.length1 + padding);
    }
    // Add one chunk for good luck.
    padding += this.Patch_Margin;

    // Add the prefix.
    var prefix = text.substring(patch.start2 - padding, patch.start2);
    if (prefix) {
        patch.diffs.unshift([DIFF_EQUAL, prefix]);
    }
    // Add the suffix.
    var suffix = text.substring(patch.start2 + patch.length1,
        patch.start2 + patch.length1 + padding);
    if (suffix) {
        patch.diffs.push([DIFF_EQUAL, suffix]);
    }

    // Roll back the start points.
    patch.start1 -= prefix.length;
    patch.start2 -= prefix.length;
    // Extend the lengths.
    patch.length1 += prefix.length + suffix.length;
    patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
    var text1, diffs;
    if (typeof a == 'string' && typeof opt_b == 'string' &&
        typeof opt_c == 'undefined') {
        // Method 1: text1, text2
        // Compute diffs from text1 and text2.
        text1 = /** @type {string} */(a);
        diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
        if (diffs.length > 2) {
            this.diff_cleanupSemantic(diffs);
            this.diff_cleanupEfficiency(diffs);
        }
    } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
        typeof opt_c == 'undefined') {
        // Method 2: diffs
        // Compute text1 from diffs.
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
        text1 = this.diff_text1(diffs);
    } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
        typeof opt_c == 'undefined') {
        // Method 3: text1, diffs
        text1 = /** @type {string} */(a);
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
    } else if (typeof a == 'string' && typeof opt_b == 'string' &&
        opt_c && typeof opt_c == 'object') {
        // Method 4: text1, text2, diffs
        // text2 is not used.
        text1 = /** @type {string} */(a);
        diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
    } else {
        throw new Error('Unknown call format to patch_make.');
    }

    if (diffs.length === 0) {
        return [];  // Get rid of the null case.
    }
    var patches = [];
    var patch = new diff_match_patch.patch_obj();
    var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
    var char_count1 = 0;  // Number of characters into the text1 string.
    var char_count2 = 0;  // Number of characters into the text2 string.
    // Start with text1 (prepatch_text) and apply the diffs until we arrive at
    // text2 (postpatch_text).  We recreate the patches one by one to determine
    // context info.
    var prepatch_text = text1;
    var postpatch_text = text1;
    for (var x = 0; x < diffs.length; x++) {
        var diff_type = diffs[x][0];
        var diff_text = diffs[x][1];

        if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
            // A new patch starts here.
            patch.start1 = char_count1;
            patch.start2 = char_count2;
        }

        switch (diff_type) {
            case DIFF_INSERT:
                patch.diffs[patchDiffLength++] = diffs[x];
                patch.length2 += diff_text.length;
                postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                    postpatch_text.substring(char_count2);
                break;
            case DIFF_DELETE:
                patch.length1 += diff_text.length;
                patch.diffs[patchDiffLength++] = diffs[x];
                postpatch_text = postpatch_text.substring(0, char_count2) +
                    postpatch_text.substring(char_count2 +
                        diff_text.length);
                break;
            case DIFF_EQUAL:
                if (diff_text.length <= 2 * this.Patch_Margin &&
                    patchDiffLength && diffs.length != x + 1) {
                    // Small equality inside a patch.
                    patch.diffs[patchDiffLength++] = diffs[x];
                    patch.length1 += diff_text.length;
                    patch.length2 += diff_text.length;
                } else if (diff_text.length >= 2 * this.Patch_Margin) {
                    // Time for a new patch.
                    if (patchDiffLength) {
                        this.patch_addContext_(patch, prepatch_text);
                        patches.push(patch);
                        patch = new diff_match_patch.patch_obj();
                        patchDiffLength = 0;
                        // Unlike Unidiff, our patch lists have a rolling context.
                        // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
                        // Update prepatch text & pos to reflect the application of the
                        // just completed patch.
                        prepatch_text = postpatch_text;
                        char_count1 = char_count2;
                    }
                }
                break;
        }

        // Update the current character count.
        if (diff_type !== DIFF_INSERT) {
            char_count1 += diff_text.length;
        }
        if (diff_type !== DIFF_DELETE) {
            char_count2 += diff_text.length;
        }
    }
    // Pick up the leftover patch if not empty.
    if (patchDiffLength) {
        this.patch_addContext_(patch, prepatch_text);
        patches.push(patch);
    }

    return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
    // Making deep copies is hard in JavaScript.
    var patchesCopy = [];
    for (var x = 0; x < patches.length; x++) {
        var patch = patches[x];
        var patchCopy = new diff_match_patch.patch_obj();
        patchCopy.diffs = [];
        for (var y = 0; y < patch.diffs.length; y++) {
            patchCopy.diffs[y] = patch.diffs[y].slice();
        }
        patchCopy.start1 = patch.start1;
        patchCopy.start2 = patch.start2;
        patchCopy.length1 = patch.length1;
        patchCopy.length2 = patch.length2;
        patchesCopy[x] = patchCopy;
    }
    return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
    if (patches.length == 0) {
        return [text, []];
    }

    // Deep copy the patches so that no changes are made to originals.
    patches = this.patch_deepCopy(patches);

    var nullPadding = this.patch_addPadding(patches);
    text = nullPadding + text + nullPadding;

    this.patch_splitMax(patches);
    // delta keeps track of the offset between the expected and actual location
    // of the previous patch.  If there are patches expected at positions 10 and
    // 20, but the first patch was found at 12, delta is 2 and the second patch
    // has an effective expected position of 22.
    var delta = 0;
    var results = [];
    for (var x = 0; x < patches.length; x++) {
        var expected_loc = patches[x].start2 + delta;
        var text1 = this.diff_text1(patches[x].diffs);
        var start_loc;
        var end_loc = -1;
        if (text1.length > this.Match_MaxBits) {
            // patch_splitMax will only provide an oversized pattern in the case of
            // a monster delete.
            start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                expected_loc);
            if (start_loc != -1) {
                end_loc = this.match_main(text,
                    text1.substring(text1.length - this.Match_MaxBits),
                    expected_loc + text1.length - this.Match_MaxBits);
                if (end_loc == -1 || start_loc >= end_loc) {
                    // Can't find valid trailing context.  Drop this patch.
                    start_loc = -1;
                }
            }
        } else {
            start_loc = this.match_main(text, text1, expected_loc);
        }
        if (start_loc == -1) {
            // No match found.  :(
            results[x] = false;
            // Subtract the delta for this failed patch from subsequent patches.
            delta -= patches[x].length2 - patches[x].length1;
        } else {
            // Found a match.  :)
            results[x] = true;
            delta = start_loc - expected_loc;
            var text2;
            if (end_loc == -1) {
                text2 = text.substring(start_loc, start_loc + text1.length);
            } else {
                text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
            }
            if (text1 == text2) {
                // Perfect match, just shove the replacement text in.
                text = text.substring(0, start_loc) +
                    this.diff_text2(patches[x].diffs) +
                    text.substring(start_loc + text1.length);
            } else {
                // Imperfect match.  Run a diff to get a framework of equivalent
                // indices.
                var diffs = this.diff_main(text1, text2, false);
                if (text1.length > this.Match_MaxBits &&
                    this.diff_levenshtein(diffs) / text1.length >
                    this.Patch_DeleteThreshold) {
                    // The end points match, but the content is unacceptably bad.
                    results[x] = false;
                } else {
                    this.diff_cleanupSemanticLossless(diffs);
                    var index1 = 0;
                    var index2;
                    for (var y = 0; y < patches[x].diffs.length; y++) {
                        var mod = patches[x].diffs[y];
                        if (mod[0] !== DIFF_EQUAL) {
                            index2 = this.diff_xIndex(diffs, index1);
                        }
                        if (mod[0] === DIFF_INSERT) {  // Insertion
                            text = text.substring(0, start_loc + index2) + mod[1] +
                                text.substring(start_loc + index2);
                        } else if (mod[0] === DIFF_DELETE) {  // Deletion
                            text = text.substring(0, start_loc + index2) +
                                text.substring(start_loc + this.diff_xIndex(diffs,
                                        index1 + mod[1].length));
                        }
                        if (mod[0] !== DIFF_DELETE) {
                            index1 += mod[1].length;
                        }
                    }
                }
            }
        }
    }
    // Strip the padding off.
    text = text.substring(nullPadding.length, text.length - nullPadding.length);
    return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
    var paddingLength = this.Patch_Margin;
    var nullPadding = '';
    for (var x = 1; x <= paddingLength; x++) {
        nullPadding += String.fromCharCode(x);
    }

    // Bump all the patches forward.
    for (var x = 0; x < patches.length; x++) {
        patches[x].start1 += paddingLength;
        patches[x].start2 += paddingLength;
    }

    // Add some padding on start of first diff.
    var patch = patches[0];
    var diffs = patch.diffs;
    if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
        // Add nullPadding equality.
        diffs.unshift([DIFF_EQUAL, nullPadding]);
        patch.start1 -= paddingLength;  // Should be 0.
        patch.start2 -= paddingLength;  // Should be 0.
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
    } else if (paddingLength > diffs[0][1].length) {
        // Grow first equality.
        var extraLength = paddingLength - diffs[0][1].length;
        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
        patch.start1 -= extraLength;
        patch.start2 -= extraLength;
        patch.length1 += extraLength;
        patch.length2 += extraLength;
    }

    // Add some padding on end of last diff.
    patch = patches[patches.length - 1];
    diffs = patch.diffs;
    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
        // Add nullPadding equality.
        diffs.push([DIFF_EQUAL, nullPadding]);
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
    } else if (paddingLength > diffs[diffs.length - 1][1].length) {
        // Grow last equality.
        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
        patch.length1 += extraLength;
        patch.length2 += extraLength;
    }

    return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
    var patch_size = this.Match_MaxBits;
    for (var x = 0; x < patches.length; x++) {
        if (patches[x].length1 <= patch_size) {
            continue;
        }
        var bigpatch = patches[x];
        // Remove the big old patch.
        patches.splice(x--, 1);
        var start1 = bigpatch.start1;
        var start2 = bigpatch.start2;
        var precontext = '';
        while (bigpatch.diffs.length !== 0) {
            // Create one of several smaller patches.
            var patch = new diff_match_patch.patch_obj();
            var empty = true;
            patch.start1 = start1 - precontext.length;
            patch.start2 = start2 - precontext.length;
            if (precontext !== '') {
                patch.length1 = patch.length2 = precontext.length;
                patch.diffs.push([DIFF_EQUAL, precontext]);
            }
            while (bigpatch.diffs.length !== 0 &&
            patch.length1 < patch_size - this.Patch_Margin) {
                var diff_type = bigpatch.diffs[0][0];
                var diff_text = bigpatch.diffs[0][1];
                if (diff_type === DIFF_INSERT) {
                    // Insertions are harmless.
                    patch.length2 += diff_text.length;
                    start2 += diff_text.length;
                    patch.diffs.push(bigpatch.diffs.shift());
                    empty = false;
                } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                    patch.diffs[0][0] == DIFF_EQUAL &&
                    diff_text.length > 2 * patch_size) {
                    // This is a large deletion.  Let it pass in one chunk.
                    patch.length1 += diff_text.length;
                    start1 += diff_text.length;
                    empty = false;
                    patch.diffs.push([diff_type, diff_text]);
                    bigpatch.diffs.shift();
                } else {
                    // Deletion or equality.  Only take as much as we can stomach.
                    diff_text = diff_text.substring(0,
                        patch_size - patch.length1 - this.Patch_Margin);
                    patch.length1 += diff_text.length;
                    start1 += diff_text.length;
                    if (diff_type === DIFF_EQUAL) {
                        patch.length2 += diff_text.length;
                        start2 += diff_text.length;
                    } else {
                        empty = false;
                    }
                    patch.diffs.push([diff_type, diff_text]);
                    if (diff_text == bigpatch.diffs[0][1]) {
                        bigpatch.diffs.shift();
                    } else {
                        bigpatch.diffs[0][1] =
                            bigpatch.diffs[0][1].substring(diff_text.length);
                    }
                }
            }
            // Compute the head context for the next patch.
            precontext = this.diff_text2(patch.diffs);
            precontext =
                precontext.substring(precontext.length - this.Patch_Margin);
            // Append the end context for this patch.
            var postcontext = this.diff_text1(bigpatch.diffs)
                .substring(0, this.Patch_Margin);
            if (postcontext !== '') {
                patch.length1 += postcontext.length;
                patch.length2 += postcontext.length;
                if (patch.diffs.length !== 0 &&
                    patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
                    patch.diffs[patch.diffs.length - 1][1] += postcontext;
                } else {
                    patch.diffs.push([DIFF_EQUAL, postcontext]);
                }
            }
            if (!empty) {
                patches.splice(++x, 0, patch);
            }
        }
    }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
    var text = [];
    for (var x = 0; x < patches.length; x++) {
        text[x] = patches[x];
    }
    return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
    var patches = [];
    if (!textline) {
        return patches;
    }
    var text = textline.split('\n');
    var textPointer = 0;
    var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
    while (textPointer < text.length) {
        var m = text[textPointer].match(patchHeader);
        if (!m) {
            throw new Error('Invalid patch string: ' + text[textPointer]);
        }
        var patch = new diff_match_patch.patch_obj();
        patches.push(patch);
        patch.start1 = parseInt(m[1], 10);
        if (m[2] === '') {
            patch.start1--;
            patch.length1 = 1;
        } else if (m[2] == '0') {
            patch.length1 = 0;
        } else {
            patch.start1--;
            patch.length1 = parseInt(m[2], 10);
        }

        patch.start2 = parseInt(m[3], 10);
        if (m[4] === '') {
            patch.start2--;
            patch.length2 = 1;
        } else if (m[4] == '0') {
            patch.length2 = 0;
        } else {
            patch.start2--;
            patch.length2 = parseInt(m[4], 10);
        }
        textPointer++;

        while (textPointer < text.length) {
            var sign = text[textPointer].charAt(0);
            try {
                var line = decodeURI(text[textPointer].substring(1));
            } catch (ex) {
                // Malformed URI sequence.
                throw new Error('Illegal escape in patch_fromText: ' + line);
            }
            if (sign == '-') {
                // Deletion.
                patch.diffs.push([DIFF_DELETE, line]);
            } else if (sign == '+') {
                // Insertion.
                patch.diffs.push([DIFF_INSERT, line]);
            } else if (sign == ' ') {
                // Minor equality.
                patch.diffs.push([DIFF_EQUAL, line]);
            } else if (sign == '@') {
                // Start of next patch.
                break;
            } else if (sign === '') {
                // Blank line?  Whatever.
            } else {
                // WTF?
                throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
            }
            textPointer++;
        }
    }
    return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
    /** @type {!Array.<!diff_match_patch.Diff>} */
    this.diffs = [];
    /** @type {?number} */
    this.start1 = null;
    /** @type {?number} */
    this.start2 = null;
    /** @type {number} */
    this.length1 = 0;
    /** @type {number} */
    this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
    var coords1, coords2;
    if (this.length1 === 0) {
        coords1 = this.start1 + ',0';
    } else if (this.length1 == 1) {
        coords1 = this.start1 + 1;
    } else {
        coords1 = (this.start1 + 1) + ',' + this.length1;
    }
    if (this.length2 === 0) {
        coords2 = this.start2 + ',0';
    } else if (this.length2 == 1) {
        coords2 = this.start2 + 1;
    } else {
        coords2 = (this.start2 + 1) + ',' + this.length2;
    }
    var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
    var op;
    // Escape the body of the patch with %xx notation.
    for (var x = 0; x < this.diffs.length; x++) {
        switch (this.diffs[x][0]) {
            case DIFF_INSERT:
                op = '+';
                break;
            case DIFF_DELETE:
                op = '-';
                break;
            case DIFF_EQUAL:
                op = ' ';
                break;
        }
        text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
    }
    return text.join('').replace(/%20/g, ' ');
};


// Export these global variables so that they survive Google's JS compiler.
// In a browser, 'this' will be 'window'.
// Users of node.js should 'require' the uncompressed version since Google's
// JS compiler may break the following exports for non-browser environments.
this['diff_match_patch'] = diff_match_patch;
this['DIFF_DELETE'] = DIFF_DELETE;
this['DIFF_INSERT'] = DIFF_INSERT;
this['DIFF_EQUAL'] = DIFF_EQUAL;

// Copyright (c) 2008, 2009 Andrew Cantino
// Copyright (c) 2008, 2009 Kyle Maxwell

/**
 * Patched to exclude jquery usages.
 *
 */

function DomPredictionHelper() {
};
DomPredictionHelper.prototype = new Object();

DomPredictionHelper.prototype.recursiveNodes = function (e) {
    var n;
    if (e.nodeName && e.parentNode && e != document.body) {
        n = this.recursiveNodes(e.parentNode);
    } else {
        n = new Array();
    }
    n.push(e);
    return n;
};

DomPredictionHelper.prototype.escapeCssNames = function (name) {
    if (name) {
        try {
            return name.replace(/\s*sg_\w+\s*/g, '').replace(/\\/g, '\\\\').
                replace(/\./g, '\\.').replace(/#/g, '\\#').replace(/\>/g, '\\>').replace(/\,/g, '\\,').replace(/\:/g, '\\:');
        } catch (e) {
            console.log('---');
            console.log("exception in escapeCssNames");
            console.log(name);
            console.log('---');
            return '';
        }
    } else {
        return '';
    }
};

DomPredictionHelper.prototype.childElemNumber = function (elem) {
    var count = 0;
    while (elem.previousSibling && (elem = elem.previousSibling)) {
        if (elem.nodeType == 1) count++;
    }
    return count;
};

DomPredictionHelper.prototype.pathOf = function (elem) {
    var nodes = this.recursiveNodes(elem);
    var self = this;
    var path = "";
    for (var i = 0; i < nodes.length; i++) {
        var e = nodes[i];
        if (e) {
            path += e.nodeName.toLowerCase();
            var escaped = e.id && self.escapeCssNames(new String(e.id));
            if (escaped && escaped.length > 0) path += '#' + escaped;

            if (e.className) {
                var split = e.className.split(/ /);

                for (var j = 0; j < split.length; j++) {
                    var escaped = self.escapeCssNames(split[j]);
                    if (split[j] && escaped.length > 0) {
                        path += '.' + escaped;
                    }
                }
            }

            path += ':nth-child(' + (self.childElemNumber(e) + 1) + ')';
            path += ' '
        }
    }
    if (path.charAt(path.length - 1) == ' ') path = path.substring(0, path.length - 1);
    return path;
};

DomPredictionHelper.prototype.commonCss = function (array) {
    try {
        var dmp = new diff_match_patch();
    } catch (e) {
        throw "Please include the diff_match_patch library.";
    }

    if (typeof array == 'undefined' || array.length == 0) return '';

    var existing_tokens = {};
    var encoded_css_array = this.encodeCssForDiff(array, existing_tokens);

    var collective_common = encoded_css_array.pop();

    encoded_css_array.forEach(function(el) {
        var diff = dmp.diff_main(collective_common, el);
        collective_common = '';

        diff.forEach(function(d) {
            if (d[0] == 0) {
                collective_common += d[1];
            }
        });
    });

    return this.decodeCss(collective_common, existing_tokens);
};

DomPredictionHelper.prototype.tokenizeCss = function (css_string) {
    var skip = false;
    var word = '';
    var tokens = [];

    var css_string = css_string.replace(/,/, ' , ').replace(/\s+/g, ' ');
    var length = css_string.length;
    var c = '';

    for (var i = 0; i < length; i++) {
        c = css_string[i];

        if (skip) {
            skip = false;
        } else if (c == '\\') {
            skip = true;
        } else if (c == '.' || c == ' ' || c == '#' || c == '>' || c == ':' || c == ',') {
            if (word.length > 0) tokens.push(word);
            word = '';
        }
        word += c;
        if (c == ' ' || c == ',') {
            tokens.push(word);
            word = '';
        }
    }
    if (word.length > 0) tokens.push(word);
    return tokens;
};

DomPredictionHelper.prototype.decodeCss = function (string, existing_tokens) {
    var inverted = this.invertObject(existing_tokens);
    var out = '';
    var split = string.split('');
    for (var i = 0; i < split.length; i++) {
        out += inverted[split[i]];
    }

    return this.cleanCss(out);
};

// Encode css paths for diff using unicode codepoints to allow for a large number of tokens.
DomPredictionHelper.prototype.encodeCssForDiff = function (strings, existing_tokens) {
    var codepoint = 50;
    var self = this;
    var strings_out = [];
    for (var i = 0; i < strings.length; i++) {
        var out = new String();

        var tokenizeCss = self.tokenizeCss(strings[i]);
        for (var j = 0; j < tokenizeCss.length; j++) {
            var s = tokenizeCss[j];

            if (!existing_tokens[s]) {
                existing_tokens[s] = String.fromCharCode(codepoint++);
            }

            out += existing_tokens[s];
        }

        strings_out.push(out);
    }

    return strings_out;
};

DomPredictionHelper.prototype.simplifyCss = function (css, selected_paths, rejected_paths) {
    var self = this;
    var parts = self.tokenizeCss(css);
    var best_so_far = "";
    if (self.selectorGets('all', selected_paths, css) && self.selectorGets('none', rejected_paths, css)) best_so_far = css;
    for (var pass = 0; pass < 4; pass++) {
        for (var part = 0; part < parts.length; part++) {
            var first = parts[part].substring(0, 1);
            if (self.wouldLeaveFreeFloatingNthChild(parts, part)) continue;
            if ((pass == 0 && first == ':') || // :nth-child
                (pass == 1 && first != ':' && first != '.' && first != '#' && first != ' ') || // elem, etc.
                (pass == 2 && first == '.') || // classes
                (pass == 3 && first == '#')) // ids
            {
                var tmp = parts[part];
                parts[part] = '';
                var selector = self.cleanCss(parts.join(''));
                if (selector == '') {
                    parts[part] = tmp;
                    continue;
                }
                if (self.selectorGets('all', selected_paths, selector) && self.selectorGets('none', rejected_paths, selector)) {
                    best_so_far = selector;
                } else {
                    parts[part] = tmp;
                }
            }
        }
    }
    return self.cleanCss(best_so_far);
};

DomPredictionHelper.prototype.wouldLeaveFreeFloatingNthChild = function (parts, part) {
    return (((part - 1 >= 0 && parts[part - 1].substring(0, 1) == ':') &&
    (part - 2 < 0 || parts[part - 2] == ' ') &&
    (part + 1 >= parts.length || parts[part + 1] == ' ')) ||
    ((part + 1 < parts.length && parts[part + 1].substring(0, 1) == ':') &&
    (part + 2 >= parts.length || parts[part + 2] == ' ') &&
    (part - 1 < 0 || parts[part - 1] == ' ')));
};

DomPredictionHelper.prototype.cleanCss = function (css) {
    return css.replace(/\>/, ' > ').replace(/,/, ' , ').replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '').replace(/,$/, '');
};

DomPredictionHelper.prototype.getPathsFor = function (arr) {
    var self = this;
    var out = [];

    for (var i = 0; i < arr.length; i++) {
        var s = arr[i];

        if (s && s.nodeName) {
            out.push(self.pathOf(s));
        }
    }

    return out;
};

DomPredictionHelper.prototype.predictCss = function (s, r) {
    var self = this;

    if (s.length == 0) return '';
    var selected_paths = self.getPathsFor(s);
    var rejected_paths = self.getPathsFor(r);

    var css = self.commonCss(selected_paths);
    var simplest = self.simplifyCss(css, selected_paths, rejected_paths);

    // Do we get off easy?
    if (simplest.length > 0) return simplest;

    // Okay, then make a union and possibly try to reduce subsets.
    var union = '';
    for (var i = 0; i < s.length; i++) {
        union = self.pathOf(s[i]) + ", " + union;
    }

    union = self.cleanCss(union);

    return self.simplifyCss(union, selected_paths, rejected_paths);
};

DomPredictionHelper.prototype.fragmentSelector = function (selector) {
    var self = this;
    var out = [];
    var split = selector.split(/\,/);

    for (var i = 0; i < split.length; i++) {
        var out2 = [];
        var splitInner = self.cleanCss(split[i]).split(/\s+/);

        for (var j = 0; j < splitInner.length; j++) {
            out2.push(self.tokenizeCss(splitInner[j]));
        }

        out.push(out2);
    }

    return out;
};

// Everything in the first selector must be present in the second.
DomPredictionHelper.prototype.selectorBlockMatchesSelectorBlock = function (selector_block1, selector_block2) {
    for (var j = 0; j < selector_block1.length; j++) {
        if (selector_block2.indexOf(selector_block1[j]) == -1) {
            return false;
        }
    }
    return true;
};

// Assumes list is an array of complete CSS selectors represented as strings.
DomPredictionHelper.prototype.selectorGets = function (type, list, the_selector) {
    var self = this;
    var result = true;

    if (list.length == 0 && type == 'all') return false;
    if (list.length == 0 && type == 'none') return true;

    var selectors = self.fragmentSelector(the_selector);

    var cleaned_list = [];
    for (var i = 0; i < list.length; i++) {
        cleaned_list.push(self.fragmentSelector(list[i])[0]);
    }

    for (var i = 0; i < selectors.length; i++) {
        if (!result) return;
        var selector = selectors[i];

        for (var j = 0; j < cleaned_list.length; i++) {
            if (!result || cleaned_list[j] == '') return;

            if (self._selectorGets(cleaned_list[j], selector)) {
                if (type == 'none') result = false;
                cleaned_list[j] = '';
            }
        }
    }

    if (type == 'all' && cleaned_list.join('').length > 0) { // Some candidates didn't get matched.
        result = false;
    }

    return result;
};

DomPredictionHelper.prototype._selectorGets = function (candidate_as_blocks, selector_as_blocks) {
    var cannot_match = false;
    var position = candidate_as_blocks.length - 1;
    for (var i = selector_as_blocks.length - 1; i > -1; i--) {
        if (cannot_match) break;
        if (i == selector_as_blocks.length - 1) { // First element on right.
            // If we don't match the first element, we cannot match.
            if (!this.selectorBlockMatchesSelectorBlock(selector_as_blocks[i], candidate_as_blocks[position])) cannot_match = true;
            position--;
        } else {
            var found = false;
            while (position > -1 && !found) {
                found = this.selectorBlockMatchesSelectorBlock(selector_as_blocks[i], candidate_as_blocks[position]);
                position--;
            }
            if (!found) cannot_match = true;
        }
    }
    return !cannot_match;
};

DomPredictionHelper.prototype.invertObject = function (object) {
    var new_object = {};

    for(var key in object) {
        var value = object[key];
        new_object[value] = key;
    }

    return new_object;
};

DomPredictionHelper.prototype.cssToXPath = function (css_string) {
    var tokens = this.tokenizeCss(css_string);
    if (tokens[0] && tokens[0] == ' ') tokens.splice(0, 1);
    if (tokens[tokens.length - 1] && tokens[tokens.length - 1] == ' ') tokens.splice(tokens.length - 1, 1);

    var css_block = [];
    var out = "";

    for (var i = 0; i < tokens.length; i++) {
        if (tokens[i] == ' ') {
            out += this.cssToXPathBlockHelper(css_block);
            css_block = [];
        } else {
            css_block.push(tokens[i]);
        }
    }

    return out + this.cssToXPathBlockHelper(css_block);
};

// Process a block (html entity, class(es), id, :nth-child()) of css
DomPredictionHelper.prototype.cssToXPathBlockHelper = function (css_block) {
    if (css_block.length == 0) return '//';
    var out = '//';
    var first = css_block[0].substring(0, 1);

    if (first == ',') return " | ";

    if (first == ':' || first == '#' || first == '.') {
        out += '*';
    }

    var expressions = [];
    var re = null;

    for (var i = 0; i < css_block.length; i++) {
        var current = css_block[i];
        first = current.substring(0, 1);
        var rest = current.substring(1);

        if (first == ':') {
            // We only support :nth-child(n) at the moment.
            if (re = rest.match(/^nth-child\((\d+)\)$/))
                expressions.push('(((count(preceding-sibling::*) + 1) = ' + re[1] + ') and parent::*)');
        } else if (first == '.') {
            expressions.push('contains(concat( " ", @class, " " ), concat( " ", "' + rest + '", " " ))');
        } else if (first == '#') {
            expressions.push('(@id = "' + rest + '")');
        } else if (first == ',') {
        } else {
            out += current;
        }
    }

    if (expressions.length > 0) out += '[';
    for (var i = 0; i < expressions.length; i++) {
        out += expressions[i];
        if (i < expressions.length - 1) out += ' and ';
    }
    if (expressions.length > 0) out += ']';
    return out;
};


/**
 * Adguard selector library
 * @type {Function}
 */
var AdguardSelectorLib = (function(api, $) {

    // PRIVATE FIELDS

    var PLACEHOLDER_PREFIX = 'adguard-placeholder';
    var placeholdedElements = null;

    var restrictedElements = null;
    var predictionHelper = null;

    var SUGGESTED_CLASS = 'sg_suggested';
    var SELECTED_CLASS = 'sg_selected';
    var REJECTED_CLASS = 'sg_rejected';
    var IGNORED_CLASS = 'sg_ignore';

    var selectedElements = [];
    var rejectedElements = [];

    var selectMode = 'exact';
    var unbound = true;
    var onElementSelectedHandler = null;

    var ignoreTouchEvent = 0;

    var selectionRenderer;


    // PRIVATE METHODS

    var removeClassName = function(className) {
        $('.' + className).removeClass(className);
    };

    var suggestPredicted = function(prediction) {
        if (prediction) {
            $(prediction).each(function() {
                if (!$(this).hasClass(SELECTED_CLASS) &&
                    !$(this).hasClass(IGNORED_CLASS) &&
                    !$(this).hasClass(REJECTED_CLASS)
                ) {
                    $(this).addClass(SUGGESTED_CLASS);
                }
            });
        }
    };

    var makePredictionPath = function(elem) {
        var w_elem = $(elem);

        if (w_elem.hasClass(SELECTED_CLASS)) {
            w_elem.removeClass(SELECTED_CLASS);
            selectedElements.splice($.inArray(elem, selectedElements), 1);
        } else if (w_elem.hasClass(REJECTED_CLASS)) {
            w_elem.removeClass(REJECTED_CLASS);
            rejectedElements.splice($.inArray(elem, rejectedElements), 1);
        } else if (w_elem.hasClass(SUGGESTED_CLASS)) {
            w_elem.addClass(REJECTED_CLASS);
            rejectedElements.push(elem);
        } else {
            if (selectMode == 'exact' && selectedElements.length > 0) {
                removeClassName(SELECTED_CLASS);
                selectedElements = [];
            }
            //w_elem.addClass('sg_selected');
            selectedElements.push(elem);
        }

        var prediction = predictionHelper.predictCss(selectedElements,
            rejectedElements.concat(restrictedElements));

        if (selectMode == 'similar') {
            removeClassName(SUGGESTED_CLASS);
            suggestPredicted(prediction);
        }

        return prediction;
    };

    var firstSelectedOrSuggestedParent = function(element) {
        if ($(element).hasClass(SUGGESTED_CLASS) || $(element).hasClass(SELECTED_CLASS)) {
            return element;
        }

        while (element.parentNode && (element = element.parentNode)) {
            if (restrictedElements.indexOf(element) == -1) {
                if ($(element).hasClass(SUGGESTED_CLASS) || $(element).hasClass(SELECTED_CLASS)) {
                    return element;
                }
            }
        }

        return null;
    };

    var px = function(p) {
        return p + 'px';
    };

    var getTagPath = function(element) {
        if (element.parentNode) {
            return element.parentNode.tagName.toLowerCase() + ' ' + element.tagName.toLowerCase();
        } else {
            return element.tagName.toLowerCase();
        }
    };

    var clearSelected = function() {
        selectedElements = [];
        rejectedElements = [];

        removeClassName(SELECTED_CLASS);
        removeClassName(REJECTED_CLASS);

        selectionRenderer.remove();
        removeClassName(SUGGESTED_CLASS);
    };

    /**
     * Returns element offset coordinates extended with width and height values.
     *
     * @param elem
     * @returns {{top: number, left: number, outerWidth: number, outerHeight: number}}
     */
    var getOffsetExtended = function(elem) {
        var bodyRect = document.body.getBoundingClientRect();
        var elemRect = elem.getBoundingClientRect();

        var rectTop = elemRect.top - bodyRect.top;
        var rectLeft = elemRect.left - bodyRect.left;

        return {
            top: rectTop,
            left: rectLeft,
            outerWidth: elem.offsetWidth,
            outerHeight: elem.offsetHeight
        };
    };

    /**
     * Adds borders to selected element.
     *
     * Default implementation of selection renderer.
     * Can be overwritten with custom implementation as a parameter of init function.
     *
     * @param element
     * @private
     */
    var BorderSelectionRenderer = (function(api) {
        var BORDER_WIDTH = 5;
        var BORDER_PADDING = 2;
        var BORDER_CLASS = 'sg_border';

        var borderTop = null;
        var borderLeft = null;
        var borderRight = null;
        var borderBottom = null;

        var showBorders = function() {
            if (borderTop && borderBottom && borderLeft && borderRight) {
                borderTop.show();
                borderBottom.show();
                borderLeft.show();
                borderRight.show();
            }
        };

        var addBorderToDom = function() {
            document.body.appendChild(borderTop.get(0));
            document.body.appendChild(borderBottom.get(0));
            document.body.appendChild(borderLeft.get(0));
            document.body.appendChild(borderRight.get(0));
        };

        var removeBorderFromDom = function() {
            if (borderTop && borderTop.get(0)) {
                var parent = borderTop.get(0).parentNode;

                if (parent) {
                    parent.removeChild(borderTop.get(0));
                    parent.removeChild(borderBottom.get(0));
                    parent.removeChild(borderLeft.get(0));
                    parent.removeChild(borderRight.get(0));
                }
            }

            borderTop = borderBottom = borderRight = borderLeft = null;
        };

        /**
         * Preparing renderer.
         */
        api.init = function() {
            if (!borderTop) {
                var width = px(BORDER_WIDTH);

                borderTop = $('<div/>').addClass(BORDER_CLASS).css('height', width).hide()
                    .on('click', sgMousedownHandler);
                borderBottom = $('<div/>').addClass(BORDER_CLASS).addClass('sg_bottom_border')
                    .css('height', px(BORDER_WIDTH + 6)).hide()
                    .on('click', sgMousedownHandler);
                borderLeft = $('<div/>').addClass(BORDER_CLASS).css('width', width).hide()
                    .on('click', sgMousedownHandler);
                borderRight = $('<div/>').addClass(BORDER_CLASS).css('width', width).hide()
                    .on('click', sgMousedownHandler);

                addBorderToDom();
            }
        };

        /**
         * Clearing DOM and so on.
         */
        api.finalize = function() {
            removeBorderFromDom();
        };

        /**
         * Adds borders to specified element
         *
         * @param element
         */
        api.add = function(element) {
            api.remove();

            if (!element) {
                return;
            }

            var p = getOffsetExtended(element);

            var top = p.top;
            var left = p.left;
            var width = p.outerWidth;
            var height = p.outerHeight;

            borderTop.css('width', px(width + BORDER_PADDING * 2 + BORDER_WIDTH * 2)).
            css('top', px(top - BORDER_WIDTH - BORDER_PADDING)).
            css('left', px(left - BORDER_PADDING - BORDER_WIDTH));
            borderBottom.css('width', px(width + BORDER_PADDING * 2 + BORDER_WIDTH)).
            css('top', px(top + height + BORDER_PADDING)).
            css('left', px(left - BORDER_PADDING - BORDER_WIDTH));
            borderLeft.css('height', px(height + BORDER_PADDING * 2)).
            css('top', px(top - BORDER_PADDING)).
            css('left', px(left - BORDER_PADDING - BORDER_WIDTH));
            borderRight.css('height', px(height + BORDER_PADDING * 2)).
            css('top', px(top - BORDER_PADDING)).
            css('left', px(left + width + BORDER_PADDING));

            borderBottom.get(0).textContent = getTagPath(element);
            borderRight.get(0).target_elem = borderLeft.get(0).target_elem = borderTop.get(0).target_elem = borderBottom.get(0).target_elem = element;

            showBorders();
        };

        /**
         * Removes borders
         */
        api.remove = function() {
            if (borderTop && borderBottom && borderLeft && borderRight) {
                borderTop.hide();
                borderBottom.hide();
                borderLeft.hide();
                borderRight.hide();
            }
        };

        /**
         * Border class
         *
         * @type {string}
         */
        api.BORDER_CLASS = BORDER_CLASS;

        return api;
    })(BorderSelectionRenderer || {});

    var linkHelper = document.createElement('a');
    var getHost = function(url) {
        if (!url) {
            return '';
        }

        linkHelper.href = url;
        return linkHelper.hostname;
    };

    var makePlaceholderImage = function(element) {
        var placeHolder = document.createElement('div');
        var style = window.getComputedStyle(element);
        placeHolder.style.height = style.height;
        placeHolder.style.width = style.width;
        placeHolder.style.position = style.position;
        placeHolder.style.top = style.top;
        placeHolder.style.bottom = style.bottom;
        placeHolder.style.left = style.left;
        placeHolder.style.right = style.right;
        placeHolder.className += PLACEHOLDER_PREFIX + ' ' + IGNORED_CLASS;

        var icon = document.createElement('div');
        icon.className += PLACEHOLDER_PREFIX + '-icon ' + IGNORED_CLASS;

        var domain = document.createElement('div');
        domain.textContent = getHost(element.src);
        domain.className += PLACEHOLDER_PREFIX + '-domain ' + IGNORED_CLASS;

        icon.appendChild(domain);
        placeHolder.appendChild(icon);

        return placeHolder;
    };

    var removePlaceholders = function() {
        if (!placeholdedElements) {
            return;
        }
        var elements = placeholdedElements;
        for (var i = 0; i < elements.length; i++) {
            var current = elements[i];
            var id = PLACEHOLDER_PREFIX + i;

            var placeHolder = $('#' + id).get(0);
            if (placeHolder) {
                var parent = placeHolder.parentNode;
                if (parent) {
                    parent.replaceChild(current, placeHolder);
                }
            }
        }

        placeholdedElements = null;
    };

    var placeholderClick = function(element) {
        selectionRenderer.remove();
        removePlaceholders();

        onElementSelectedHandler(element);
    };

    var makeIFrameAndEmbeddedSelector = function() {
        placeholdedElements = $('iframe:not(.' + IGNORED_CLASS + '),embed,object').filter(function(elem) {
            var isVisible = elem.style.display != 'none';
            var isHaveSize = elem.offsetWidth != 0 && elem.offsetHeight != 0;
            return isVisible && isHaveSize;
        });

        var elements = placeholdedElements;
        for (var i = 0; i < elements.length; i++) {
            var current = elements[i];
            (function(current) {
                var placeHolder = makePlaceholderImage(current);
                var id = PLACEHOLDER_PREFIX + i;

                placeHolder.setAttribute('id', id);

                var parent = current.parentNode;
                if (parent) {
                    parent.replaceChild(placeHolder, current);

                    $(placeHolder).on('gestureend', gestureEndHandler);
                    $(placeHolder).on('touchmove', touchMoveHandler);
                    $(placeHolder).on('touchend', function(e) {
                        e.preventDefault();

                        if (needIgnoreTouchEvent()) {
                            return true;
                        }

                        placeholderClick(current);
                    });

                    $('#' + id).on('click', function(e) {
                        e.preventDefault();

                        placeholderClick(current);
                    });

                }

            })(current);
        }
    };

    /********** Events ***************/
    var sgMouseoverHandler = function(e) {
        e.stopPropagation();

        if (unbound) {
            return true;
        }

        if (this == document.body || this == document.body.parentNode) {
            return false;
        }

        var parent = firstSelectedOrSuggestedParent(this);
        if (parent != null && parent != this) {
            selectionRenderer.add(parent);
        } else {
            selectionRenderer.add(this);
        }

        return false;
    };

    var sgMouseoutHandler = function() {
        if (unbound) {
            return true;
        }

        if (this == document.body || this == document.body.parentNode) {
            return false;
        }

        selectionRenderer.remove();
        return false;
    };

    // e.isTrusted checking for prevent programmatically events
    // see: https://github.com/AdguardTeam/AdguardAssistant/issues/134
    var sgMousedownHandler = function(e) {
        if (e && e.isTrusted === false) return false;
        if ($(e.target).hasClass(IGNORED_CLASS)) return false;
        e.preventDefault();
        e.stopImmediatePropagation();
        if (unbound) {
            return true;
        }

        var elem = e.target;
        if ($(elem).hasClass(selectionRenderer.BORDER_CLASS)) {
            //Clicked on one of our floating borders, target the element that we are bordering.
            elem = elem.target_elem || elem;
        }

        if (elem == document.body || elem == document.body.parentNode) {
            return;
        }

        makePredictionPath(elem);

        selectionRenderer.remove();

        onElementSelectedHandler(elem);

        return false;
    };

    /********** Touch event handlers ***************/
    var touchElementSelectHandler = function(e) {
        e.preventDefault();
        e.stopImmediatePropagation();

        sgMouseoverHandler.call(this, e);
        sgMousedownHandler.call(this, e);
    };

    var needIgnoreTouchEvent = function() {

        if (ignoreTouchEvent > 0) {

            ignoreTouchEvent--;
            return true;
        }

        return false;
    };

    var elementTouchendHandler = function(e) {
        if($(e.target).hasClass(IGNORED_CLASS)) return false;

        e.stopPropagation();

        if (needIgnoreTouchEvent()) {
            return true;
        }

        touchElementSelectHandler.call(this, e);
        return false;
    };

    var emptyEventHandler = function(e) {
        e.stopPropagation();

        return false;
    };

    var gestureEndHandler = function() {
        ignoreTouchEvent = 2;
        return true;
    };

    var touchMoveHandler = function() {
        ignoreTouchEvent = 1;
        return true;
    };


    var setupEventHandlers = function() {
        makeIFrameAndEmbeddedSelector();
        var elements = $('body *:not(.' + IGNORED_CLASS + ')');

        elements.forEach(function(el) {
            el.addEventListener('gestureend', gestureEndHandler);
            el.addEventListener('touchmove', touchMoveHandler);
            el.addEventListener('touchend', elementTouchendHandler, true);
            el.addEventListener('touchstart', emptyEventHandler);
            el.addEventListener('mouseover', sgMouseoverHandler);
            el.addEventListener('mouseout', sgMouseoutHandler);
            el.addEventListener('click', sgMousedownHandler, true);
        });
    };

    var deleteEventHandlers = function() {
        removePlaceholders();

        var elements = $('body *');
        elements.forEach(function(el) {
            el.removeEventListener('gestureend', gestureEndHandler);
            el.removeEventListener('touchmove', touchMoveHandler);
            el.removeEventListener('touchend', elementTouchendHandler, true);
            el.removeEventListener('touchstart', emptyEventHandler);
            el.removeEventListener('mouseover', sgMouseoverHandler);
            el.removeEventListener('mouseout', sgMouseoutHandler);
            el.removeEventListener('click', sgMousedownHandler, true);
        });
    };

    //Define default implementation of selection renderer.
    selectionRenderer = BorderSelectionRenderer;

    // PUBLIC API

    /**
     * Starts selector module.
     *
     * @param onElementSelected callback function
     * @param selectionRenderImpl optional object contains selection presentation implementation
     */
    api.init = function(onElementSelected, selectionRenderImpl) {

        onElementSelectedHandler = onElementSelected;
        if (selectionRenderImpl && typeof selectionRenderImpl === 'object') {
            selectionRenderer = selectionRenderImpl;
        }

        restrictedElements = ['html', 'body', 'head', 'base'].map(function(selector) {
            return $(selector).get(0);
        });
        predictionHelper = new DomPredictionHelper($, String);

        selectionRenderer.init();
        setupEventHandlers();
        unbound = false;
    };

    /**
     * Resets state of selector.
     * Clears current selection.
     */
    api.reset = function() {
        clearSelected();
    };

    /**
     * Destroys selector module.
     * Removes all selector elements and unbinds event handlers.
     */
    api.close = function() {
        unbound = true;

        selectionRenderer.finalize();
        deleteEventHandlers();
    };

    /**
     * Selects specified element.
     * Marks element as selected and holds selection on it.
     *
     * @param element
     */
    api.selectElement = function(element) {
        deleteEventHandlers();
        selectionRenderer.add(element);

        unbound = true;
    };

    /**
     Returns css class name.
     If this class assigns to HTML element, then Adguard Selector ignores it.
     */
    api.ignoreClassName = function() {
        return IGNORED_CLASS;
    };

    return api;

});

/**
 * Adguard rules constructor
 * @type {Function}
 */
var AdguardRulesConstructorLib = function (api) { // jshint ignore:line

    var CSS_RULE_MARK = '##';
    var RULE_OPTIONS_MARK = '$';

    var URLBLOCK_ATTRIBUTES = ["src", "data"];

    var linkHelper = document.createElement('a');

    /**
     * Constructs css selector for element using tag name, id and classed, like: tagName#id.class1.class2
     *
     * @param element Element
     * @param classList Override element classes (If classList is null, element classes will be used)
     * @param excludeTagName Omit tag name in selector
     * @param excludeId Omit element id in selector
     * @returns {string}
     */
    var makeDefaultCssFilter = function (element, classList, excludeTagName, excludeId) {
        var cssSelector = excludeTagName ? '' : element.tagName.toLowerCase();
        if (element.id && !excludeId) {
            cssSelector += '#' + cssEscape(element.id);
        }
        cssSelector += constructClassCssSelectorByAND(classList || element.classList);
        return cssSelector;
    };

    /**
     * Constructs css selector for element using parent elements and nth-child (first-child, last-child) pseudo classes.
     *
     * @param element Element
     * @param options Construct options. For example: {excludeTagName: false, excludeId: false, classList: []}
     * @returns {string}
     */
    var makeCssNthChildFilter = function (element, options) {

        options = options || {};

        var classList = options.classList;

        var excludeTagNameOverride = 'excludeTagName' in options;
        var excludeTagName = options.excludeTagName;

        var excludeIdOverride = 'excludeId' in options;
        var excludeId = options.excludeId;

        var path = [];
        var el = element;
        while (el.parentNode) {
            var nodeName = el && el.nodeName ? el.nodeName.toUpperCase() : "";
            if (nodeName === "BODY") {
                break;
            }
            if (el.id) {
                /**
                 * Be default we don't include tag name and classes to selector for element with id attribute
                 */
                var cssSelector = '';
                if (el === element) {
                    cssSelector = makeDefaultCssFilter(el, classList || [], excludeTagNameOverride ? excludeTagName : true, excludeIdOverride ? excludeId : false);
                } else {
                    cssSelector = makeDefaultCssFilter(el, [], true, false);
                }
                path.unshift(cssSelector);
                break;
            } else {
                var c = 1;
                for (var e = el; e.previousSibling; e = e.previousSibling) {
                    if (e.previousSibling.nodeType === 1) {
                        c++;
                    }
                }

                var cldCount = 0;
                for (var i = 0; el.parentNode && i < el.parentNode.childNodes.length; i++) {
                    cldCount += el.parentNode.childNodes[i].nodeType === 1 ? 1 : 0;
                }

                var ch;
                if (cldCount === 0 || cldCount === 1) {
                    ch = "";
                } else if (c === 1) {
                    ch = ":first-child";
                } else if (c === cldCount) {
                    ch = ":last-child";
                } else {
                    ch = ":nth-child(" + c + ")";
                }

                /**
                 * By default we include tag name and element classes to selector for element without id attribute
                 */
                if (el === element) {
                    var p = makeDefaultCssFilter(el, classList, excludeTagNameOverride ? excludeTagName : false, excludeId);
                    p += ch;
                    path.unshift(p);
                } else {
                    path.unshift(makeDefaultCssFilter(el, el.classList, false, false) + ch);
                }

                el = el.parentNode;
            }
        }
        return path.join(" > ");
    };

    /**
     * Constructs element selector for matching elements that contain any of classes in original element
     * For example <el class="cl1 cl2 cl3"></el> => .cl1, .cl2, .cl3
     *
     * @param element Element
     * @param classList Override element classes (If classList is null, element classes will be used)
     * @returns {string}
     */
    var makeSimilarCssFilter = function (element, classList) {
        return constructClassCssSelectorByOR(classList || element.classList);
    };

    /**
     * Creates css rule text
     * @param element Element
     * @param options Construct options. For example: {cssSelectorType: 'STRICT_FULL', excludeTagName: false, excludeId: false, classList: []}
     * @returns {string}
     */
    var constructCssRuleText = function (element, options) {

        if (!element) {
            return;
        }

        options = options || {};
        var cssSelectorType = options.cssSelectorType || 'STRICT_FULL';

        var selector;
        switch (cssSelectorType) {
            case 'STRICT_FULL':
                selector = makeCssNthChildFilter(element, options);
                break;
            case 'STRICT':
                selector = makeDefaultCssFilter(element, options.classList, options.excludeTagName, options.excludeId);
                break;
            case 'SIMILAR':
                selector = makeSimilarCssFilter(element, options.classList, true);
                break;
        }

        return selector ? CSS_RULE_MARK + selector : '';
    };

    var constructUrlBlockRuleText = function (element, urlBlockAttribute, oneDomain, domain) {

        if (!urlBlockAttribute) {
            return null;
        }

        var blockUrlRuleText = urlBlockAttribute.replace(/^http:\/\/(www\.)?/, "||");
        if (blockUrlRuleText.indexOf('.') === 0) {
            blockUrlRuleText = blockUrlRuleText.substring(1);
        }

        if (!oneDomain) {
            blockUrlRuleText = blockUrlRuleText + RULE_OPTIONS_MARK + "domain=" + domain;
        }

        return blockUrlRuleText;
    };

    var getUrlBlockAttribute = function (element) {
        if (!element || !element.getAttribute) {
            return null;
        }

        for (var i = 0; i < URLBLOCK_ATTRIBUTES.length; i++) {
            var attr = URLBLOCK_ATTRIBUTES[i];
            var value = element.getAttribute(attr);
            if (isValidUrl(value)) {
                return value;
            }
        }

        return null;
    };

    var haveUrlBlockParameter = function (element) {
        var value = getUrlBlockAttribute(element);
        return value && value !== '';
    };

    var haveClassAttribute = function (element) {
        return element.classList && element.classList.length > 0;
    };

    var haveIdAttribute = function (element) {
        return element.id && element.id.trim() !== '';
    };

    var cropDomain = function (url) {
        var domain = getUrl(url).host;
        return domain.replace("www.", "").replace(/:\d+/, '');
    };

    var getUrl = function (url) {
        var pattern = "^(([^:/\\?#]+):)?(//(([^:/\\?#]*)(?::([^/\\?#]*))?))?([^\\?#]*)(\\?([^#]*))?(#(.*))?$";
        var rx = new RegExp(pattern);
        var parts = rx.exec(url);

        return {
            host: parts[4] || "",
            path: parts[7] || ""
        };
    };

    var isValidUrl = function (value) {
        if (value) {
            linkHelper.href = value;
            if (linkHelper.hostname) {
                return true;
            }
        }

        return false;
    };

    /**
     * Constructs css selector by combining classes by AND
     * @param classList
     * @returns {string}
     */
    var constructClassCssSelectorByAND = function (classList) {
        var selectors = [];
        if (classList) {
            for (var i = 0; i < classList.length; i++) {
                selectors.push('.' + cssEscape(classList[i]));
            }
        }
        return selectors.join('');
    };

    /**
     * Constructs css selector by combining classes by OR
     * @param classList
     * @returns {string}
     */
    var constructClassCssSelectorByOR = function (classList) {
        var selectors = [];
        if (classList) {
            for (var i = 0; i < classList.length; i++) {
                selectors.push('.' + cssEscape(classList[i]));
            }
        }
        return selectors.join(', ');
    };

    /**
     * Utility method
     *
     * @param element
     * @returns {string}
     */
    api.makeCssNthChildFilter = makeCssNthChildFilter;

    /**
     * Returns detailed element info
     *
     * @param element
     */
    api.getElementInfo = function (element) {

        // Convert attributes to array
        var attributes = [];
        var elementAttributes = element.attributes;
        if (elementAttributes) {
            for (var i = 0; i < elementAttributes.length; i++) {
                var attr = elementAttributes[i];
                attributes.push({
                    name: attr.name,
                    value: attr.value
                });
            }
        }

        return {
            tagName: element.tagName,
            attributes: attributes,
            urlBlockAttributeValue: getUrlBlockAttribute(element),
            haveUrlBlockParameter: haveUrlBlockParameter(element),
            haveClassAttribute: haveClassAttribute(element),
            haveIdAttribute: haveIdAttribute(element)
        };
    };

    /**
     * Constructs css selector for specified rule
     *
     * @param ruleText rule text
     * @returns {string} css style selector
     */
    api.constructRuleCssSelector = function (ruleText) {
        if (!ruleText) {
            return null;
        }

        var index = ruleText.indexOf(CSS_RULE_MARK);
        var optionsIndex = ruleText.indexOf(RULE_OPTIONS_MARK);

        if (index >= 0) {
            return ruleText.substring(index + CSS_RULE_MARK.length, optionsIndex >= 0 ? optionsIndex : ruleText.length);
        }

        var s = ruleText.substring(0, optionsIndex);
        s = s.replace(/[\|]|[\^]/g, '');

        if (isValidUrl(s)) {
            return '[src*="' + s + '"]';
        }

        return null;
    };

    /**
     * Constructs adguard rule text from element node and specified options
     *
     * var options = {
	 *	urlMask: url block attributes,
	 *	isBlockOneDomain: boolean,
	 *	url: url,
	 *  attributes: attributesSelectorText,
	 *  ruleType: (URL, CSS)
	 *  cssSelectorType: (STRICT_FULL, STRICT, SIMILAR),
	 *  excludeTagName: false, (Exclude element tag name from selector)
	 *  excludeId: false, (Exclude element identifier from selector)
	 *  classList: [] (Override element classes (If classList is null, element classes will be used))
	 * }
     *
     * @param element
     * @param options
     * @returns {*}
     */
    api.constructRuleText = function (element, options) {

        var croppedDomain = cropDomain(options.url);

        var ruleType = options.ruleType;

        if (ruleType === 'URL') {
            var blockUrlRuleText = constructUrlBlockRuleText(element, options.urlMask, options.isBlockOneDomain, croppedDomain);
            if (blockUrlRuleText) {
                return blockUrlRuleText;
            }
        }

        var result;

        if (ruleType === 'CSS') {

            result = constructCssRuleText(element, options);

            // Append html attributes to css selector
            if (options.attributes) {
                result = (result ? result : CSS_RULE_MARK + result) + options.attributes;
            }
        }

        if (!options.isBlockOneDomain) {
            result = croppedDomain + result;
        }

        return result;
    };

    return api;

};
/**
 * Manages iframe and it's content
 * @param $
 * @param log
 * @param selector
 * @param localization
 * @param resources
 * @returns {{showSelectorMenu: showSelectorMenu, showSliderMenu: showSliderMenu, setButtonPosition: setButtonPosition, onCloseMenu: CustomEvent, onShowMenuItem: CustomEvent, removeIframe: removeIframe, resizeSliderMenuToAdvanced: resizeSliderMenuToAdvanced, resizeSliderMenuToNormal: resizeSliderMenuToNormal}}
 * @constructor
 */
/* global StringUtils, Ioc, DetailedMenuController, SelectorMenuController, SliderMenuControllerMobile, BlockPreviewController, SettingsMenuController */
var IframeControllerMobile = function ($, log, selector, localization, resources) { // jshint ignore:line
    var iframe = null;
    var currentItem = null;
    var iframePositionOffset = 5;

    var onCloseMenu = new CustomEvent();
    var onShowMenuItem = new CustomEvent();

    var createIframe = function (onIframeLoadCallback) {
        log.debug('Creating iframe');
        iframe = $('<iframe/>');
        var css = {
            position: 'fixed',
            left: 0,
            top: 'auto',
            bottom: '1px',
            clip: 'auto',
            width: '100%',
            height: '70px',
            'z-index': 999999999999999
        };
        var attributes = {
            'id': 'adguard-assistant-dialog',
            'class': selector.ignoreClassName(),
            frameBorder: 0,
            allowTransparency: 'true'
        };
        Object.keys(css).forEach(function (item) {
            iframe.css(item, css[item]);
        });
        Object.keys(attributes).forEach(function (item) {
            iframe.attr(item, attributes[item]);
        });
        var iframeAlreadyLoaded = false;
        $(iframe).on('load', function () {
            if (iframeAlreadyLoaded) {
                //IE calls load each time when we use document.close
                return;
            }
            iframeAlreadyLoaded = true;
            appendDefaultStyle();
            onIframeLoadCallback();
        });

        var body = $('body')[0];

        if (!body) {
            log.error("Body not found");
            return;
        }

        if (document.getElementById('adguard-assistant-dialog')) {
            log.error("Iframe already added");
            return;
        }

        body.appendChild(iframe[0]);

        var selectorCSS = document.createElement('style');
        var styles = resources.getResource('selector.css');

        if (selectorCSS.styleSheet) {
            selectorCSS.styleSheet.cssText = styles;
        } else {
            selectorCSS.appendChild(document.createTextNode(styles));
        }

        document.getElementsByTagName("head")[0].appendChild(selectorCSS);
    };

    var appendDefaultStyle = function () {
        try {
            log.info('Iframe loaded writing styles');
            var doc = iframe[0].contentDocument;
            doc.open();
            doc.write(
                StringUtils.format("<html><head>{0}</head></html>",
                StringUtils.format('<style {0} type="text/css">{1}{2}</style>',
                getStyleNonce(),
                resources.getResource('style.css'),
                resources.getResource('mobile-style.css')))
            );
            doc.close();
        } catch (ex) {
            log.error(ex);
        }
    };

    var getStyleNonce = function () {
        return '';
    };

    var showMenuItem = function (viewName, controller, width, height, options) {
        log.debug(StringUtils.format("Showing menu item: {0}", viewName));
        if (currentItem === viewName) {
            return;
        }
        var onIframeLoad = function () {
            var frameElement = iframe[0];
            frameElement.width = width;
            frameElement.height = height;
            var view = $(resources.getResource(viewName))[0];
            appendContent(view);
            localize();
            if (!options) {
                options = {};
            }
            controller.init(frameElement, options);
            currentItem = viewName;
            onShowMenuItem.notify();
        };
        if (!iframe) {
            createIframe(onIframeLoad);
            return;
        }
        onIframeLoad();
    };

    var showSelectorMenu = function () {
        var controller = Ioc.get(SelectorMenuController);
        var options = {dragElement: 'head'};
        showMenuItem('selectorMenu.html', controller, 'auto', 'auto', options);
        setCloseEventIfNotHitIframe(false);
    };

    var showSliderMenu = function (element) {
        var controller = Ioc.get(SliderMenuControllerMobile);
        var options = {element: element, dragElement: 'head'};
        showMenuItem('sliderMenu.html', controller, 'auto', 'auto', options);
        setCloseEventIfNotHitIframe(false);
    };

    var localize = function () {
        var elements = iframe[0].contentDocument.querySelectorAll("[i18n]");
        for (var i = 0; i < elements.length; i++) {
            var message = localization.getMessage(elements[i].getAttribute("i18n"));
            localization.translateElement(elements[i], message);
        }
    };

    var setCloseEventIfNotHitIframe = function (setEvent) {
        document.removeEventListener('click', removeIframe);

        if(setEvent) {
            window.setTimeout(function () {
                document.addEventListener('click', removeIframe);
            }, 150);
        }
    };

    var resizeSliderMenuToAdvanced = function () {
        resizeIframe(null, sliderMenuHeight.advanced);
    };

    var resizeSliderMenuToNormal = function () {
        resizeIframe(null, sliderMenuHeight.normal);
    };

    var appendContent = function (view) {
        var body = iframe[0].contentDocument.body;
        for (var i = 0; i < body.children.length; i++) {
            body.removeChild(body.children[i]);
        }
        body.appendChild(view);
    };

    // e.isTrusted checking for prevent programmatically events
    // see: https://github.com/AdguardTeam/AdguardAssistant/issues/134
    var removeIframe = function (e) {
        if (e && e.isTrusted === false) return false;
        document.removeEventListener('click', removeIframe);
        window.removeEventListener('resize', showSelectorMenu);
        $('body')[0].removeChild(iframe[0]);
        iframe = null;
        currentItem = null;
        selector.close();
        onCloseMenu.notify();
    };

    return {
        showSelectorMenu: showSelectorMenu,
        showSliderMenu: showSliderMenu,
        onCloseMenu: onCloseMenu,
        onShowMenuItem: onShowMenuItem,
        removeIframe: removeIframe,
        resizeSliderMenuToAdvanced: resizeSliderMenuToAdvanced,
        resizeSliderMenuToNormal: resizeSliderMenuToNormal
    };
};

/**
 * Slider widget
 * @type {Function}
 */
var SliderWidget = (function(api, $) { // jshint ignore:line
    var PLACEHOLDER_CLASS = "adg-slide ui-slider ui-slider-horizontal ui-widget ui-widget-content ui-corner-all";
    var HANDLE_CLASS = "ui-slider-handle";
    var HANDLE_FULL_CLASS = "ui-slider-handle ui-state-default ui-corner-all";
    var TICK_CLASS = "tick";
    var TICK_FULL_CLASS = "tick ui-widget-content";
    var TICK_LEFT_COLOR = "#36BA53";
    var TICK_RIGHT_COLOR = "#E0DFDB";

    var placeholder = null;

    var min = 0;
    var max = 1;
    var value = 0;
    var sliderArea = null;

    var onValueChanged = null;


    var refresh = function() {
        var handle = placeholder.querySelectorAll("." + HANDLE_CLASS);
        $(handle).css('left', (value - 1) * 100 / (max - min) + "%");

        var ticks = placeholder.querySelectorAll("." + TICK_CLASS);
        for (var i = 0; i < ticks.length; i++) {
            if (i + 1 < value) {
                $(ticks[i]).css('background-color', TICK_LEFT_COLOR);
            } else {
                $(ticks[i]).css('background-color', TICK_RIGHT_COLOR);
            }
        }
    };

    var render = function() {
        $(placeholder).addClass(PLACEHOLDER_CLASS);

        var handle = document.createElement('span');
        handle.setAttribute('class', HANDLE_FULL_CLASS);
        placeholder.appendChild(handle);

        var count = max - min;
        var prepare = function(i) {
            var tick = document.createElement('div');
            tick.setAttribute('class', TICK_FULL_CLASS);
            tick.style.left = (100 / count * i) + '%';
            tick.style.width = (100 / count) + '%';

            placeholder.appendChild(tick);
        };

        for (var i = 0; i < count; i++) {
            prepare(i);
        }

        refresh();
    };

    var setValue = function(v) {
        if (v < min) {
            value = min;
        } else if (v > max) {
            value = max;
        } else {
            value = v;
        }

        refresh();

        onValueChanged(value);
    };

    var bindEvents = function() {
        var $placeholder = $(placeholder);
        var handle = placeholder.querySelectorAll("." + HANDLE_CLASS);
        var $handle = $(handle);
        var $sliderArea = $(sliderArea);

        $(document).on('mouseup touchend pointerup', function() {
            $sliderArea.off('mousemove touchmove pointermove', onMouseMove);
        });

        var rect = placeholder.getBoundingClientRect();
        var sliderWidth = rect.width;
        var offsetLeft = rect.left + document.body.scrollLeft;

        var getSliderValue = function(pageX) {
            return Math.round((max - min) / sliderWidth * (pageX - offsetLeft) + min);
        };

        var onClick = function(e) {
            //calculate the correct position of the slider set the value
            var value = getSliderValue(e.pageX);
            setValue(value);
        };

        var onMouseMove = function(e) {
            //calculate the correct position of the slider set the value
            var value = getSliderValue(e.pageX);
            setValue(value);
        };

        var onMouseDown = function(e) {
            e.stopPropagation();
            e.preventDefault();
            e.cancelBubble = true;
            e.returnValue = false;

            $sliderArea.on('mousemove touchmove pointermove', onMouseMove);
        };

        $placeholder.on('click', onClick);
        $placeholder.on('mousedown touchstart', onMouseDown);

        $sliderArea.on('mouseup touchend pointerup', function() {
            $sliderArea.off('mousemove touchmove pointermove', onMouseMove);
        });

        $sliderArea.on('mouseleave', function() {
            $sliderArea.off('mousemove touchmove pointermove', onMouseMove);
        });
    };

    /**
     *
     * @param placeholderElement
     * @param options
     */
    api.init = function(placeholderElement, options) {
        placeholder = placeholderElement;

        min = options.min;
        max = options.max;
        value = options.value;
        onValueChanged = options.onValueChanged;
        sliderArea = options.sliderArea;

        render();
        bindEvents();
    };

    return api;
});

/**
 * Object that manages wot data
 * @returns {{registerWotEventHandler: Function, getWotData: Function, getWotScorecardUrl: Function, WOT_URL: string}}
 * @constructor
 */
/* global StringUtils */
var Wot = function () { // jshint ignore:line
    var wotUrlScorecardTemplate = 'http://adguard.com/wot-scorecard.html?domain={0}';
    var WOT_URL = 'http://adguard.com/wot.html';
    var wotData = null;

    /*
     Waiting for event from wot extension. Send event back to stop
     firing wot extension events
     */
    var registerWotEventHandler = function () {
        document.addEventListener('wot-score', function (e) {
            wotData = e.data.wotData;
            fireEvent('wot-accepted', null);
        });
    };

    var getWotData = function () {
        return wotData;
    };

    var getWotScorecardUrl = function (url) {
        return StringUtils.format(wotUrlScorecardTemplate, url);
    };

    var fireEvent = function (name, data) {
        var event = document.createEvent("Events");
        event.initEvent(name, true, true);
        event.data = data;
        document.dispatchEvent(event);
    };

    return {
        registerWotEventHandler: registerWotEventHandler,
        getWotData: getWotData,
        getWotScorecardUrl: getWotScorecardUrl,
        WOT_URL: WOT_URL
    };
};

var ru = {
    "menu_filtration_status": {
        "message": "\u0424\u0438\u043b\u044c\u0442\u0440\u0430\u0446\u0438\u044f \u043d\u0430 \u044d\u0442\u043e\u043c \u0441\u0430\u0439\u0442\u0435"
    },
    "menu_do_not_filter_30_sec": {
        "message": "\u041d\u0435 \u0444\u0438\u043b\u044c\u0442\u0440\u043e\u0432\u0430\u0442\u044c 30 \u0441\u0435\u043a\u0443\u043d\u0434"
    },
    "menu_block_ad_on_site": {
        "message": "\u0417\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0440\u0435\u043a\u043b\u0430\u043c\u0443 \u043d\u0430 \u0441\u0430\u0439\u0442\u0435"
    },
    "menu_report_abuse": {
        "message": "\u041f\u043e\u0436\u0430\u043b\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043d\u0430 \u0441\u0430\u0439\u0442"
    },
    "menu_site_report": {
        "message": "\u041e\u0442\u0447\u0451\u0442 \u043e \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0441\u0442\u0438 \u0441\u0430\u0439\u0442\u0430"
    },
    "menu_settings": {
        "message": "\u041d\u0430\u0441\u0442\u0440\u043e\u0438\u0442\u044c \u043f\u043e\u043c\u043e\u0449\u043d\u0438\u043a"
    },
    "assistant_select_element": {
        "message": " \u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430"
    },
    "assistant_select_element_ext": {
        "message": "\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043d\u0430 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430\u0434\u043e \u0437\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c"
    },
    "assistant_select_element_cancel": {
        "message": "\u041e\u0442\u043c\u0435\u043d\u0430"
    },
    "assistant_block_element": {
        "message": "\u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430"
    },
    "assistant_block_element_explain": {
        "message": "\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u043e \u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430"
    },
    "assistant_slider_explain": {
        "message": "\u041f\u0435\u0440\u0435\u043c\u0435\u0449\u0430\u0439\u0442\u0435 \u0431\u0435\u0433\u0443\u043d\u043e\u043a, \u0447\u0442\u043e\u0431\u044b \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u044c \u0440\u0430\u0437\u043c\u0435\u0440 \u0431\u043b\u043e\u043a\u0430, \u0434\u043b\u044f \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u0431\u0443\u0434\u0435\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u043f\u0440\u0430\u0432\u0438\u043b\u043e:"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAX"
    },
    "assistant_extended_settings": {
        "message": "\u0420\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u044b\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u044c \u043f\u0440\u0430\u0432\u0438\u043b\u043e \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u0441\u0430\u0439\u0442\u043e\u0432"
    },
    "assistant_block_by_reference": {
        "message": "\u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u043e \u0441\u0441\u044b\u043b\u043a\u0435"
    },
    "assistant_block_similar": {
        "message": "\u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043f\u043e\u0445\u043e\u0436\u0438\u0435"
    },
    "assistant_another_element": {
        "message": "\u0412\u044b\u0431\u0440\u0430\u0442\u044c \u0434\u0440\u0443\u0433\u043e\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442"
    },
    "assistant_preview": {
        "message": "\u041f\u0440\u0435\u0434\u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440"
    },
    "assistant_block": {
        "message": "\u0417\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c"
    },
    "assistant_settings": {
        "message": "\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043f\u043e\u043c\u043e\u0449\u043d\u0438\u043a\u0430"
    },
    "assistant_preview_header": {
        "message": "\u0411\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 - \u043f\u0440\u0435\u0434\u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440"
    },
    "assistant_preview_header_info": {
        "message": "\u0423\u0431\u0435\u0434\u0438\u0442\u0435\u0441\u044c, \u0447\u0442\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u0437\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u043d \u043a\u0430\u043a \u0437\u0430\u0434\u0443\u043c\u0430\u043d\u043e"
    },
    "assistant_preview_end": {
        "message": "\u0417\u0430\u043a\u043e\u043d\u0447\u0438\u0442\u044c \u043f\u0440\u0435\u0434\u043f\u0440\u043e\u0441\u043c\u043e\u0442\u0440"
    },
    "wot_unknown_description": {
        "message": "\u0420\u0435\u043f\u0443\u0442\u0430\u0446\u0438\u044f \u043d\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0430"
    },
    "wot_bad_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u043e\u0447\u0435\u043d\u044c \u043f\u043b\u043e\u0445\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "wot_poor_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u043f\u043b\u043e\u0445\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "wot_unsatisfactory_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u043d\u0435\u0443\u0434\u0432\u043e\u043b\u0435\u0442\u0432\u043e\u0440\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "wot_good_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u0445\u043e\u0440\u043e\u0448\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "wot_excellent_description": {
        "message": "\u0423 \u0441\u0430\u0439\u0442\u0430 \u043e\u0442\u043b\u0438\u0447\u043d\u0430\u044f \u0440\u0435\u0443\u0442\u0430\u0446\u0438\u044f \u043f\u043e \u0434\u0430\u043d\u043d\u044b\u043c "
    },
    "settings_choose_size_and_position": {
        "message": "\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u0442\u0435 \u0440\u0430\u0437\u043c\u0435\u0440 \u0438 \u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u043f\u043e\u043c\u043e\u0449\u043d\u0438\u043a\u0430 Adguard"
    },
    "settings_icon_size": {
        "message": "\u0420\u0430\u0437\u043c\u0435\u0440 \u0438\u043a\u043e\u043d\u043a\u0438:"
    },
    "settings_small": {
        "message": "\u041c\u0430\u043b\u0435\u043d\u044c\u043a\u0430\u044f"
    },
    "settings_big": {
        "message": "\u0411\u043e\u043b\u044c\u0448\u0430\u044f"
    },
    "settings_position": {
        "message": "\u0420\u0430\u0441\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435:"
    },
    "settings_left_top": {
        "message": "\u0412\u0432\u0435\u0440\u0445\u0443 \u0441\u043b\u0435\u0432\u0430"
    },
    "settings_right_top": {
        "message": "\u0412\u0432\u0435\u0440\u0445\u0443 \u0441\u043f\u0440\u0430\u0432\u0430"
    },
    "settings_left_bottom": {
        "message": "\u0412\u043d\u0438\u0437\u0443 \u0441\u043b\u0435\u0432\u0430"
    },
    "settings_right_bottom": {
        "message": "\u0412\u043d\u0438\u0437\u0443 \u0441\u043f\u0440\u0430\u0432\u0430"
    },
    "settings_cancel": {
        "message": "\u041e\u0442\u043c\u0435\u043d\u0430"
    },
    "settings_save": {
        "message": "\u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438"
    }
}
var en = {
    "menu_filtration_status": {
        "message": "Filtering on this website"
    },
    "menu_do_not_filter_30_sec": {
        "message": "Do not filter for 30 seconds"
    },
    "menu_block_ad_on_site": {
        "message": "Block ad on this website"
    },
    "menu_report_abuse": {
        "message": "Report the website"
    },
    "menu_site_report": {
        "message": "Website security report"
    },
    "menu_settings": {
        "message": "Assistant settings"
    },
    "assistant_select_element": {
        "message": "Element blocking"
    },
    "assistant_select_element_ext": {
        "message": "Choose an element on the page to block"
    },
    "assistant_select_element_cancel": {
        "message": "Cancel"
    },
    "assistant_block_element": {
        "message": "Element blocking"
    },
    "assistant_block_element_explain": {
        "message": "Adjust element blocking rule"
    },
    "assistant_slider_explain": {
        "message": "Move the slider to change the size of the frame the new rule will work for:"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAX"
    },
    "assistant_extended_settings": {
        "message": "Advanced settings"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "Apply the rule to all websites"
    },
    "assistant_block_by_reference": {
        "message": "Block by reference link"
    },
    "assistant_block_similar": {
        "message": "Block similar"
    },
    "assistant_another_element": {
        "message": "Select another element"
    },
    "assistant_preview": {
        "message": "Preview"
    },
    "assistant_block": {
        "message": "Block"
    },
    "assistant_settings": {
        "message": "Assistant settings"
    },
    "assistant_preview_header": {
        "message": "Element blocking - preview"
    },
    "assistant_preview_header_info": {
        "message": "Make sure that element is blocked as intended"
    },
    "assistant_preview_end": {
        "message": "Exit preview"
    },
    "wot_unknown_description": {
        "message": "Reputation is not defined"
    },
    "wot_bad_description": {
        "message": "This website has very bad reputation\naccording to "
    },
    "wot_poor_description": {
        "message": "This website has bad reputation\naccording to "
    },
    "wot_unsatisfactory_description": {
        "message": "This website has poor reputation\naccording to "
    },
    "wot_good_description": {
        "message": "This website has good reputation\naccording to "
    },
    "wot_excellent_description": {
        "message": "This website has excellent reputation\naccording to "
    },
    "settings_choose_size_and_position": {
        "message": "Adjust Adguard Assistant size and position"
    },
    "settings_icon_size": {
        "message": "Icon size:"
    },
    "settings_small": {
        "message": "Small"
    },
    "settings_big": {
        "message": "Large"
    },
    "settings_position": {
        "message": "Position:"
    },
    "settings_left_top": {
        "message": "Top left"
    },
    "settings_right_top": {
        "message": "Top right"
    },
    "settings_left_bottom": {
        "message": "Bottom left"
    },
    "settings_right_bottom": {
        "message": "Bottom right"
    },
    "settings_cancel": {
        "message": "Cancel"
    },
    "settings_save": {
        "message": "Save changes"
    }
}
var fa = {
    "menu_filtration_status": {
        "message": "\u0641\u06cc\u0644\u062a\u0631\u06cc\u0646\u06af \u062f\u0631 \u0627\u06cc\u0646 \u0648\u0628\u0633\u0627\u06cc\u062a"
    },
    "menu_do_not_filter_30_sec": {
        "message": "\u0628\u0647 \u0645\u062f\u062a 30 \u062b\u0627\u0646\u06cc\u0647 \u0641\u06cc\u0644\u062a\u0631 \u0646\u06a9\u0646"
    },
    "menu_block_ad_on_site": {
        "message": "\u0645\u0633\u062f\u0648\u062f\u0633\u0627\u0632\u06cc \u062a\u0628\u0644\u06cc\u063a \u062f\u0631 \u0627\u06cc\u0646 \u0648\u0628\u0633\u0627\u06cc\u062a"
    },
    "menu_report_abuse": {
        "message": "\u06af\u0632\u0627\u0631\u0634 \u0648\u0628\u0633\u0627\u06cc\u062a"
    },
    "menu_site_report": {
        "message": "\u06af\u0632\u0627\u0631\u0634 \u0627\u0645\u0646\u06cc\u062a\u06cc \u0648\u0628\u0633\u0627\u06cc\u062a"
    },
    "menu_settings": {
        "message": "\u062a\u0646\u0638\u06cc\u0645\u0627\u062a \u062f\u0633\u062a\u06cc\u0627\u0631"
    },
    "assistant_select_element": {
        "message": "\u0645\u0633\u062f\u0648\u062f\u0633\u0627\u0632\u06cc \u0639\u0646\u0635\u0631"
    },
    "assistant_select_element_ext": {
        "message": "\u0639\u0646\u0635\u0631\u06cc \u062f\u0631 \u0635\u0641\u062d\u0647 \u0628\u0631\u0627\u06cc \u0645\u0633\u062f\u0648\u062f\u0633\u0627\u0632\u06cc \u0627\u0646\u062a\u062e\u0627\u0628 \u06a9\u0646\u06cc\u062f"
    },
    "assistant_select_element_cancel": {
        "message": "\u0644\u063a\u0648"
    },
    "assistant_block_element": {
        "message": "\u0645\u0633\u062f\u0648\u062f\u0633\u0627\u0632\u06cc \u0639\u0646\u0635\u0631"
    },
    "assistant_block_element_explain": {
        "message": "\u062a\u0646\u0638\u06cc\u0645 \u062f\u0633\u062a\u0648\u0631 \u0645\u0633\u062f\u0648\u062f\u0633\u0627\u0632\u06cc \u0639\u0646\u0635\u0631"
    },
    "assistant_slider_explain": {
        "message": "\u062c\u0627\u0628\u062c\u0627\u06cc\u06cc \u0644\u063a\u0632\u0646\u062f\u0647 \u0628\u0631\u0627\u06cc \u062a\u063a\u06cc\u06cc\u0631 \u0627\u0646\u062f\u0627\u0632\u0647 \u0641\u0631\u06cc\u0645 \u06a9\u0647 \u062f\u0633\u062a\u0648\u0631 \u062c\u062f\u06cc\u062f\u06cc \u06a9\u0627\u0631 \u062e\u0648\u0627\u0647\u062f \u06a9\u0631\u062f:"
    },
    "assistant_slider_min": {
        "message": "\u062d\u062f\u0627\u0642\u0644"
    },
    "assistant_slider_max": {
        "message": "\u062d\u062f\u0627\u06a9\u062b\u0631"
    },
    "assistant_extended_settings": {
        "message": "\u062a\u0646\u0638\u06cc\u0645\u0627\u062a \u067e\u06cc\u0634\u0631\u0641\u062a\u0647"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "\u0627\u0650\u0639\u0645\u0627\u0644 \u062f\u0633\u062a\u0648\u0631 \u062f\u0631 \u0647\u0645\u0647 \u0648\u0628\u0633\u0627\u06cc\u062a \u0647\u0627"
    },
    "assistant_block_by_reference": {
        "message": "\u0645\u0633\u062f\u0648\u062f\u0633\u0627\u0632\u06cc \u0628\u0627 \u0644\u06cc\u0646\u06a9 \u0645\u0631\u062c\u0639"
    },
    "assistant_block_similar": {
        "message": "\u0645\u0633\u062f\u0648\u062f\u0633\u0627\u0632\u06cc \u0645\u0634\u0627\u0628\u0647"
    },
    "assistant_another_element": {
        "message": "\u0639\u0646\u0635\u0631 \u062f\u06cc\u06af\u0631\u06cc \u0627\u0646\u062a\u062e\u0627\u0628 \u06a9\u0646\u06cc\u062f"
    },
    "assistant_preview": {
        "message": "\u067e\u06cc\u0634\u0646\u0645\u0627\u06cc\u0634"
    },
    "assistant_block": {
        "message": "\u0645\u0633\u062f\u0648\u062f"
    },
    "assistant_settings": {
        "message": "\u062a\u0646\u0638\u06cc\u0645\u0627\u062a \u062f\u0633\u062a\u06cc\u0627\u0631"
    },
    "assistant_preview_header": {
        "message": "\u0645\u0633\u062f\u0648\u062f\u0633\u0627\u0632\u06cc \u0639\u0646\u0635\u0631 - \u067e\u06cc\u0634\u0646\u0645\u0627\u06cc\u0634"
    },
    "assistant_preview_header_info": {
        "message": "\u0645\u0637\u0645\u0626\u0646 \u0634\u0648\u06cc\u062f \u0639\u0646\u0635\u0631 \u0628\u0647 \u0634\u06a9\u0644 \u062f\u0644\u062e\u0648\u0627\u0647 \u0645\u0633\u062f\u0648\u062f \u0634\u0648\u062f"
    },
    "assistant_preview_end": {
        "message": "\u062e\u0631\u0648\u062c \u0627\u0632 \u067e\u06cc\u0634\u0646\u0645\u0627\u06cc\u0634"
    },
    "wot_unknown_description": {
        "message": "\u0627\u0639\u062a\u0628\u0627\u0631 \u062a\u0639\u0631\u06cc\u0641 \u0646\u0634\u062f\u0647 \u0627\u0633\u062a"
    },
    "wot_bad_description": {
        "message": "\u0627\u06cc\u0646 \u0648\u0628\u0633\u0627\u06cc\u062a \u0627\u0639\u062a\u0628\u0627\u0631 \u062e\u06cc\u0644\u06cc \u0628\u062f\u06cc \u062f\u0627\u0631\u062f\n\u0628\u0631 \u0637\u0628\u0642 "
    },
    "wot_poor_description": {
        "message": "\u0627\u06cc\u0646 \u0648\u0628\u0633\u0627\u06cc\u062a \u0627\u0639\u062a\u0628\u0627\u0631 \u0628\u062f\u06cc \u062f\u0627\u0631\u062f\n\u0628\u0631 \u0637\u0628\u0642 "
    },
    "wot_unsatisfactory_description": {
        "message": "\u0627\u06cc\u0646 \u0648\u0628\u0633\u0627\u06cc\u062a \u0627\u0639\u062a\u0628\u0627\u0631 \u06a9\u0645\u06cc \u062f\u0627\u0631\u062f\n\u0628\u0631 \u0637\u0628\u0642 "
    },
    "wot_good_description": {
        "message": "\u0627\u06cc\u0646 \u0648\u0628\u0633\u0627\u06cc\u062a \u0627\u0639\u062a\u0628\u0627\u0631 \u062e\u0648\u0628\u06cc \u062f\u0627\u0631\u062f\n\u0628\u0631 \u0637\u0628\u0642 "
    },
    "wot_excellent_description": {
        "message": "\u0627\u06cc\u0646 \u0648\u0628\u0633\u0627\u06cc\u062a \u0627\u0639\u062a\u0628\u0627\u0631 \u0639\u0627\u0644\u06cc \u062f\u0627\u0631\u062f\n\u0628\u0631 \u0637\u0628\u0642 "
    },
    "settings_choose_size_and_position": {
        "message": "\u062a\u0646\u0638\u06cc\u0645 \u0627\u0646\u062f\u0627\u0632\u0647 \u0648 \u0645\u0648\u0642\u0639\u06cc\u062a \u062f\u0633\u062a\u06cc\u0627\u0631 \u0627\u064e\u062f\u06af\u0627\u0631\u062f"
    },
    "settings_icon_size": {
        "message": "\u0627\u0646\u062f\u0627\u0632\u0647 \u0622\u06cc\u06a9\u0648\u0646:"
    },
    "settings_small": {
        "message": "\u06a9\u0648\u0686\u06a9"
    },
    "settings_big": {
        "message": "\u0628\u0632\u0631\u06af"
    },
    "settings_position": {
        "message": "\u0645\u0648\u0642\u0639\u06cc\u062a:"
    },
    "settings_left_top": {
        "message": "\u0628\u0627\u0644\u0627 \u0633\u0645\u062a \u0686\u067e"
    },
    "settings_right_top": {
        "message": "\u0628\u0627\u0644\u0627 \u0633\u0645\u062a \u0631\u0627\u0633\u062a"
    },
    "settings_left_bottom": {
        "message": "\u067e\u0627\u06cc\u06cc\u0646 \u0633\u0645\u062a \u0686\u067e"
    },
    "settings_right_bottom": {
        "message": "\u067e\u0627\u06cc\u06cc\u0646 \u0633\u0645\u062a \u0631\u0627\u0633\u062a"
    },
    "settings_cancel": {
        "message": "\u0644\u063a\u0648"
    },
    "settings_save": {
        "message": "\u0630\u062e\u06cc\u0631\u0647 \u062a\u063a\u06cc\u06cc\u0631\u0627\u062a"
    }
}
var he = {
    "menu_filtration_status": {
        "message": "\u05e1\u05d9\u05e0\u05d5\u05df \u05d1\u05d0\u05ea\u05e8 \u05d6\u05d4"
    },
    "menu_do_not_filter_30_sec": {
        "message": "\u05d0\u05dc \u05ea\u05e1\u05e0\u05df \u05db- 30 \u05e9\u05e0\u05d9\u05d5\u05ea"
    },
    "menu_block_ad_on_site": {
        "message": "\u05d7\u05e1\u05d5\u05dd \u05e4\u05e8\u05e1\u05d5\u05de\u05ea \u05d1\u05d0\u05ea\u05e8 \u05d6\u05d4"
    },
    "menu_report_abuse": {
        "message": "\u05d3\u05d5\u05d5\u05d7 \u05e2\u05dc \u05d4\u05d0\u05ea\u05e8"
    },
    "menu_site_report": {
        "message": "\u05d3\u05d9\u05d5\u05d5\u05d7 \u05d0\u05d1\u05d8\u05d7\u05ea \u05d0\u05ea\u05e8"
    },
    "menu_settings": {
        "message": "\u05d4\u05d2\u05d3\u05e8\u05d5\u05ea \u05d4\u05e2\u05d5\u05d6\u05e8 \u05d4\u05d0\u05d9\u05e9\u05d9"
    },
    "assistant_select_element": {
        "message": "\u05d7\u05d5\u05e1\u05dd \u05d0\u05dc\u05de\u05e0\u05d8"
    },
    "assistant_select_element_ext": {
        "message": "\u05d1\u05d7\u05e8 \u05d0\u05dc\u05de\u05e0\u05d8 \u05d1\u05d3\u05e3 \u05dc\u05d7\u05e1\u05d9\u05de\u05d4"
    },
    "assistant_select_element_cancel": {
        "message": "\u05d1\u05d8\u05dc"
    },
    "assistant_block_element": {
        "message": "\u05d7\u05e1\u05d9\u05de\u05ea \u05d0\u05dc\u05de\u05e0\u05d8"
    },
    "assistant_block_element_explain": {
        "message": "\u05d4\u05ea\u05d0\u05dd \u05db\u05dc\u05dc \u05d7\u05e1\u05d9\u05de\u05ea \u05d0\u05dc\u05de\u05e0\u05d8"
    },
    "assistant_slider_explain": {
        "message": ":\u05d4\u05d6\u05d6 \u05d0\u05ea \u05d4\u05de\u05d7\u05d5\u05d5\u05df \u05db\u05d3\u05d9 \u05dc\u05e9\u05e0\u05d5\u05ea \u05d0\u05ea \u05d2\u05d5\u05d3\u05dc \u05d4\u05de\u05e1\u05d2\u05e8\u05ea \u05d1\u05d4 \u05d9\u05e2\u05d1\u05d5\u05d3 \u05d4\u05db\u05dc\u05dc \u05d4\u05d7\u05d3\u05e9"
    },
    "assistant_slider_min": {
        "message": "\u05de\u05d9\u05e0\u05d9\u05de\u05d5\u05dd"
    },
    "assistant_slider_max": {
        "message": "\u05de\u05e7\u05e1\u05d9\u05de\u05d5\u05dd"
    },
    "assistant_extended_settings": {
        "message": "\u05d4\u05d2\u05d3\u05e8\u05d5\u05ea \u05de\u05ea\u05e7\u05d3\u05de\u05d5\u05ea"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "\u05d4\u05d7\u05dc \u05d0\u05ea \u05d4\u05db\u05dc\u05dc \u05e2\u05dc \u05db\u05dc \u05d4\u05d0\u05ea\u05e8\u05d9\u05dd"
    },
    "assistant_block_by_reference": {
        "message": "\u05d7\u05e1\u05d5\u05dd \u05d4\u05e4\u05e0\u05d9\u05d9\u05ea \u05e7\u05d9\u05e9\u05d5\u05e8"
    },
    "assistant_block_similar": {
        "message": "\u05d7\u05e1\u05d5\u05dd \u05d3\u05d5\u05de\u05d4"
    },
    "assistant_another_element": {
        "message": "\u05d1\u05d7\u05e8 \u05d0\u05dc\u05de\u05e0\u05d8 \u05d0\u05d7\u05e8"
    },
    "assistant_preview": {
        "message": "\u05ea\u05e6\u05d5\u05d2\u05d4 \u05de\u05e7\u05d3\u05d9\u05de\u05d4"
    },
    "assistant_block": {
        "message": "\u05d7\u05e1\u05d5\u05dd"
    },
    "assistant_settings": {
        "message": "\u05d4\u05d2\u05d3\u05e8\u05d5\u05ea \u05d4\u05e2\u05d5\u05d6\u05e8 \u05d4\u05d0\u05d9\u05e9\u05d9"
    },
    "assistant_preview_header": {
        "message": "\u05ea\u05e6\u05d5\u05d2\u05d4 \u05de\u05e7\u05d3\u05d9\u05de\u05d4 - \u05d7\u05e1\u05d9\u05de\u05ea \u05d0\u05dc\u05de\u05e0\u05d8"
    },
    "assistant_preview_header_info": {
        "message": "\u05d5\u05d3\u05d0 \u05db\u05d9 \u05d0\u05dc\u05de\u05e0\u05d8 \u05d6\u05d4 \u05d7\u05e1\u05d5\u05dd \u05d1\u05db\u05d5\u05d5\u05e0\u05d4"
    },
    "assistant_preview_end": {
        "message": "\u05e6\u05d0 \u05de\u05ea\u05e6\u05d5\u05d2\u05d4 \u05de\u05e7\u05d3\u05d9\u05de\u05d4"
    },
    "wot_unknown_description": {
        "message": "\u05de\u05d5\u05e0\u05d9\u05d8\u05d9\u05df \u05d0\u05d9\u05e0\u05d5 \u05de\u05d5\u05d2\u05d3\u05e8"
    },
    "wot_bad_description": {
        "message": "\u05dc\u05d0\u05ea\u05e8 \u05d6\u05d4 \u05d9\u05e9 \u05de\u05d5\u05e0\u05d9\u05d8\u05d9\u05df \u05e8\u05e2 \u05de\u05d0\u05d5\u05d3 \u05e2\u05dc \u05e4\u05d9"
    },
    "wot_poor_description": {
        "message": "\u05dc\u05d0\u05ea\u05e8 \u05d6\u05d4 \u05d9\u05e9 \u05de\u05d5\u05e0\u05d9\u05d8\u05d9\u05df \u05e8\u05e2 \u05e2\u05dc \u05e4\u05d9"
    },
    "wot_unsatisfactory_description": {
        "message": "\u05dc\u05d0\u05ea\u05e8 \u05d6\u05d4 \u05d9\u05e9 \u05de\u05d5\u05e0\u05d9\u05d8\u05d9\u05df \u05d3\u05dc \u05e2\u05dc \u05e4\u05d9"
    },
    "wot_good_description": {
        "message": "\u05dc\u05d0\u05ea\u05e8 \u05d6\u05d4 \u05d9\u05e9 \u05de\u05d5\u05e0\u05d9\u05d8\u05d9\u05df \u05d8\u05d5\u05d1 \u05e2\u05dc \u05e4\u05d9"
    },
    "wot_excellent_description": {
        "message": "\u05dc\u05d0\u05ea\u05e8 \u05d6\u05d4 \u05d9\u05e9 \u05de\u05d5\u05e0\u05d9\u05d8\u05d9\u05df \u05de\u05e2\u05d5\u05dc\u05d4 \u05e2\u05dc \u05e4\u05d9"
    },
    "settings_choose_size_and_position": {
        "message": "\u05d4\u05ea\u05d0\u05dd \u05d2\u05d5\u05d3\u05dc \u05d5\u05de\u05d9\u05e7\u05d5\u05dd \u05e9\u05dc \u05d4\u05e2\u05d5\u05d6\u05e8 \u05d4\u05d0\u05d9\u05e9\u05d9 \u05e9\u05dc \u05d0\u05d3\u05d2\u05d0\u05e8\u05d3"
    },
    "settings_icon_size": {
        "message": ":\u05d2\u05d5\u05d3\u05dc \u05e6\u05dc\u05de\u05d9\u05ea"
    },
    "settings_small": {
        "message": "\u05e7\u05d8\u05df"
    },
    "settings_big": {
        "message": "\u05d2\u05d3\u05d5\u05dc"
    },
    "settings_position": {
        "message": ":\u05de\u05d9\u05e7\u05d5\u05dd"
    },
    "settings_left_top": {
        "message": "\u05d1\u05d7\u05dc\u05e7 \u05d4\u05e2\u05dc\u05d9\u05d5\u05df \u05de\u05e9\u05de\u05d0\u05dc"
    },
    "settings_right_top": {
        "message": "\u05d1\u05d7\u05dc\u05e7 \u05d4\u05e2\u05dc\u05d9\u05d5\u05df \u05de\u05d9\u05de\u05d9\u05df"
    },
    "settings_left_bottom": {
        "message": "\u05e6\u05d3 \u05e9\u05de\u05d0\u05dc \u05dc\u05de\u05d8\u05d4"
    },
    "settings_right_bottom": {
        "message": "\u05e6\u05d3 \u05d9\u05de\u05d9\u05df \u05dc\u05de\u05d8\u05d4"
    },
    "settings_cancel": {
        "message": "\u05d1\u05d8\u05dc"
    },
    "settings_save": {
        "message": "\u05e9\u05de\u05d5\u05e8 \u05e9\u05d9\u05e0\u05d5\u05d9\u05d9\u05dd"
    }
}
var it = {
    "menu_filtration_status": {
        "message": "Filtraggio su questo sito"
    },
    "menu_do_not_filter_30_sec": {
        "message": "Non filtrare per 30 secondi"
    },
    "menu_block_ad_on_site": {
        "message": "Blocca annunci su questo sito"
    },
    "menu_report_abuse": {
        "message": "Segnala il sito"
    },
    "menu_site_report": {
        "message": "Rapporto di sicurezza del sito internet"
    },
    "menu_settings": {
        "message": "Impostazioni assistente"
    },
    "assistant_select_element": {
        "message": "Bloccaggio elemento"
    },
    "assistant_select_element_ext": {
        "message": "Scegli un elemento da bloccare sulla pagina"
    },
    "assistant_select_element_cancel": {
        "message": "Annulla"
    },
    "assistant_block_element": {
        "message": "Bloccaggio elemento"
    },
    "assistant_block_element_explain": {
        "message": "Modifica la regola di bloccaggio elemento"
    },
    "assistant_slider_explain": {
        "message": "Muovi la barra per cambiare la grandezza del frame da per il quale la nuova regola funzioner\u00e0:"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAX"
    },
    "assistant_extended_settings": {
        "message": "Impostazioni avanzate"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "Applica la regola a tutti i siti"
    },
    "assistant_block_by_reference": {
        "message": "Blocca tramite link di referenza"
    },
    "assistant_block_similar": {
        "message": "Blocca simile"
    },
    "assistant_another_element": {
        "message": "Seleziona un altro elemento"
    },
    "assistant_preview": {
        "message": "Anteprima"
    },
    "assistant_block": {
        "message": "Blocca"
    },
    "assistant_settings": {
        "message": "Impostazioni assistente"
    },
    "assistant_preview_header": {
        "message": "Bloccaggio elemento - anteprima"
    },
    "assistant_preview_header_info": {
        "message": "Assicurati che l'elemento \u00e8 bloccato come richiesto"
    },
    "assistant_preview_end": {
        "message": "Esci dall'anteprima"
    },
    "wot_unknown_description": {
        "message": "La reputazione non \u00e8 definita"
    },
    "wot_bad_description": {
        "message": "Questo sito ha una pessima reputazione\n\nsecondo "
    },
    "wot_poor_description": {
        "message": "Questo sito ha una cattiva reputazione\n\nsecondo "
    },
    "wot_unsatisfactory_description": {
        "message": "Questo sito ha una discreta reputazione\n\nsecondo "
    },
    "wot_good_description": {
        "message": "Questo sito ha una buona reputazione\n\nsecondo "
    },
    "wot_excellent_description": {
        "message": "Questo sito ha un'ottima reputazione\n\nsecondo "
    },
    "settings_choose_size_and_position": {
        "message": "Regola dimensione e posizione di Assistente Adguard"
    },
    "settings_icon_size": {
        "message": "Grandezza dell'icona:"
    },
    "settings_small": {
        "message": "Piccola"
    },
    "settings_big": {
        "message": "Grande"
    },
    "settings_position": {
        "message": "Posizione:"
    },
    "settings_left_top": {
        "message": "In alto a sinistra"
    },
    "settings_right_top": {
        "message": "In alto a destra"
    },
    "settings_left_bottom": {
        "message": "In basso a sinistra"
    },
    "settings_right_bottom": {
        "message": "In basso a destra"
    },
    "settings_cancel": {
        "message": "Annulla"
    },
    "settings_save": {
        "message": "Salva cambiamenti"
    }
}
var pl = {
    "menu_filtration_status": {
        "message": "Filtrowanie na tej stronie internetowej"
    },
    "menu_do_not_filter_30_sec": {
        "message": "Nie filtruj przez 30 sekund"
    },
    "menu_block_ad_on_site": {
        "message": "Zablokuj reklam\u0119 na tej stronie internetowej"
    },
    "menu_report_abuse": {
        "message": "Raportuj stron\u0119 internetow\u0105"
    },
    "menu_site_report": {
        "message": "Raport bezpiecze\u0144stwa strony internetowej"
    },
    "menu_settings": {
        "message": "Ustawienia Asystenta"
    },
    "assistant_select_element": {
        "message": "Blokowanie element\u00f3w"
    },
    "assistant_select_element_ext": {
        "message": "Wybierz element na stronie by zablokowa\u0107"
    },
    "assistant_select_element_cancel": {
        "message": "Anuluj"
    },
    "assistant_block_element": {
        "message": "Blokowanie element\u00f3w"
    },
    "assistant_block_element_explain": {
        "message": "Dostosuj regu\u0142\u0119 blokowania element\u00f3w"
    },
    "assistant_slider_explain": {
        "message": "Przesu\u0144 suwak by zmieni\u0107 rozmiar ramki, dla kt\u00f3rej b\u0119dzie obowi\u0105zywa\u0107 nowa regu\u0142a:"
    },
    "assistant_slider_min": {
        "message": "Minimum"
    },
    "assistant_slider_max": {
        "message": "Maksimum"
    },
    "assistant_extended_settings": {
        "message": "Ustawienia zaawansowane"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "Zastosuj regu\u0142\u0119 dla wszystkich stron internetowych"
    },
    "assistant_block_by_reference": {
        "message": "Blokuj u\u017cywaj\u0105c linka referencyjnego"
    },
    "assistant_block_similar": {
        "message": "Blokuj podobne"
    },
    "assistant_another_element": {
        "message": "Wybierz inny element"
    },
    "assistant_preview": {
        "message": "Podgl\u0105d"
    },
    "assistant_block": {
        "message": "Blokuj"
    },
    "assistant_settings": {
        "message": "Ustawienia Asystenta"
    },
    "assistant_preview_header": {
        "message": "Blokowanie element\u00f3w - podgl\u0105d"
    },
    "assistant_preview_header_info": {
        "message": "Upewnij si\u0119, \u017ce element jest blokowany jak zamierzono"
    },
    "assistant_preview_end": {
        "message": "Zamknij podgl\u0105d"
    },
    "wot_unknown_description": {
        "message": "Reputacja nie jest zdefiniowana"
    },
    "wot_bad_description": {
        "message": "Ta strona internetowa ma bardzo z\u0142\u0105 reputacj\u0119 zgodnie z"
    },
    "wot_poor_description": {
        "message": "Ta strona internetowa ma z\u0142\u0105 reputacj\u0119 zgodnie z"
    },
    "wot_unsatisfactory_description": {
        "message": "Ta strona internetowa ma s\u0142ab\u0105 reputacj\u0119 zgodnie z"
    },
    "wot_good_description": {
        "message": "Ta strona internetowa ma dobr\u0105 reputacj\u0119 zgodnie z"
    },
    "wot_excellent_description": {
        "message": "Ta strona internetowa ma doskona\u0142\u0105 reputacj\u0119 zgodnie z"
    },
    "settings_choose_size_and_position": {
        "message": "Dostosuj rozmiar i pozycj\u0119 Asystenta Adguarda"
    },
    "settings_icon_size": {
        "message": "Rozmiar ikony:"
    },
    "settings_small": {
        "message": "Ma\u0142y"
    },
    "settings_big": {
        "message": "Du\u017cy"
    },
    "settings_position": {
        "message": "Pozycja:"
    },
    "settings_left_top": {
        "message": "Lewy g\u00f3rny"
    },
    "settings_right_top": {
        "message": "Prawy g\u00f3rny"
    },
    "settings_left_bottom": {
        "message": "Na dole po lewej"
    },
    "settings_right_bottom": {
        "message": "Na dole po prawej"
    },
    "settings_cancel": {
        "message": "Anuluj"
    },
    "settings_save": {
        "message": "Zapisz zmiany"
    }
}
var uk = {
    "menu_filtration_status": {
        "message": "\u0424\u0456\u043b\u044c\u0442\u0440\u0430\u0446\u0456\u044f \u043d\u0430 \u0434\u0430\u043d\u043e\u043c\u0443 \u0441\u0430\u0439\u0442\u0456"
    },
    "menu_do_not_filter_30_sec": {
        "message": "\u041d\u0435 \u0444\u0456\u043b\u044c\u0442\u0440\u0443\u0432\u0430\u0442\u0438 30 \u0441\u0435\u043a\u0443\u043d\u0434"
    },
    "menu_block_ad_on_site": {
        "message": "\u0417\u0430\u0431\u043b\u043e\u043a\u0443\u0432\u0430\u0442\u0438 \u0440\u0435\u043a\u043b\u0430\u043c\u0443 \u043d\u0430 \u0434\u0430\u043d\u043e\u043c\u0443 \u0441\u0430\u0439\u0442\u0456"
    },
    "menu_report_abuse": {
        "message": "\u041f\u043e\u0432\u0456\u0434\u043e\u043c\u0438\u0442\u0438 \u043f\u0440\u043e \u0441\u0430\u0439\u0442"
    },
    "menu_site_report": {
        "message": "\u0417\u0432\u0456\u0442 \u043f\u0440\u043e \u0431\u0435\u0437\u043f\u0435\u043a\u0443 \u0441\u0430\u0439\u0442\u0443"
    },
    "menu_settings": {
        "message": "\u041d\u0430\u043b\u0430\u0448\u0442\u0443\u0432\u0430\u043d\u043d\u044f \u043f\u043e\u043c\u0456\u0447\u043d\u0438\u043a\u0430"
    },
    "assistant_select_element": {
        "message": "\u0411\u043b\u043e\u043a\u0443\u0432\u0430\u043d\u043d\u044f \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0443"
    },
    "assistant_select_element_ext": {
        "message": "\u0412\u0438\u0431\u0435\u0440\u0456\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442 \u043d\u0430 \u0441\u0442\u043e\u0440\u0456\u043d\u0446\u0456, \u044f\u043a\u0438\u0439 \u0442\u0440\u0435\u0431\u0430 \u0437\u0430\u0431\u043b\u043e\u043a\u0443\u0432\u0430\u0442\u0438"
    },
    "assistant_select_element_cancel": {
        "message": "\u0421\u043a\u0430\u0441\u0443\u0432\u0430\u0442\u0438"
    },
    "assistant_block_element": {
        "message": "\u0411\u043b\u043e\u043a\u0443\u0432\u0430\u043d\u043d\u044f \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0443"
    },
    "assistant_block_element_explain": {
        "message": "\u041d\u0430\u043b\u0430\u0448\u0442\u0443\u0439\u0442\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u043e \u0431\u043b\u043e\u043a\u0443\u0432\u0430\u043d\u043d\u044f \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0443"
    },
    "assistant_slider_explain": {
        "message": "\u041f\u0435\u0440\u0435\u0441\u0443\u0432\u0430\u0439\u0442\u0435 \u043f\u043e\u0432\u0437\u0443\u043d\u043e\u043a, \u0449\u043e\u0431 \u0437\u043c\u0456\u043d\u0438\u0442\u0438 \u0440\u043e\u0437\u043c\u0456\u0440 \u0431\u043b\u043e\u043a\u0443, \u0434\u043b\u044f \u044f\u043a\u043e\u0433\u043e \u0434\u0456\u044f\u0442\u0438\u043c\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u043e:"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAX"
    },
    "assistant_extended_settings": {
        "message": "\u0420\u043e\u0437\u0448\u0438\u0440\u0435\u043d\u0456 \u043d\u0430\u043b\u0430\u0448\u0442\u0443\u0432\u0430\u043d\u043d\u044f"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "\u0417\u0430\u0441\u0442\u043e\u0441\u0443\u0432\u0430\u0442\u0438 \u043f\u0440\u0430\u0432\u0438\u043b\u043e \u0434\u043e \u0432\u0441\u0456\u0445 \u0432\u0435\u0431-\u0441\u0430\u0439\u0442\u0456\u0432"
    },
    "assistant_block_by_reference": {
        "message": "\u0411\u043b\u043e\u043a\u0443\u0432\u0430\u0442\u0438 \u0437\u0430 \u043f\u043e\u0441\u0438\u043b\u0430\u043d\u043d\u044f\u043c"
    },
    "assistant_block_similar": {
        "message": "\u0411\u043b\u043e\u043a\u0443\u0432\u0430\u0442\u0438 \u0441\u0445\u043e\u0436\u0456 \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0438"
    },
    "assistant_another_element": {
        "message": "\u0412\u0438\u0431\u0440\u0430\u0442\u0438 \u0456\u043d\u0448\u0438\u0439 \u0435\u043b\u0435\u043c\u0435\u043d\u0442"
    },
    "assistant_preview": {
        "message": "\u041f\u043e\u043f\u0435\u0440\u0435\u0434\u043d\u0456\u0439 \u043f\u0435\u0440\u0435\u0433\u043b\u044f\u0434"
    },
    "assistant_block": {
        "message": "\u0417\u0430\u0431\u043b\u043e\u043a\u0443\u0432\u0430\u0442\u0438"
    },
    "assistant_settings": {
        "message": "\u041d\u0430\u043b\u0430\u0448\u0442\u0443\u0432\u0430\u043d\u043d\u044f \u043f\u043e\u043c\u0456\u0447\u043d\u0438\u043a\u0430"
    },
    "assistant_preview_header": {
        "message": "\u0411\u043b\u043e\u043a\u0443\u0432\u0430\u043d\u043d\u044f \u0435\u043b\u0435\u043c\u0435\u043d\u0442\u0443 - \u043f\u043e\u043f\u0435\u0440\u0435\u0434\u043d\u0456\u0439 \u043f\u0435\u0440\u0435\u0433\u043b\u044f\u0434"
    },
    "assistant_preview_header_info": {
        "message": "\u041f\u0435\u0440\u0435\u043a\u043e\u043d\u0430\u0439\u0442\u0435\u0441\u044f, \u0449\u043e \u0435\u043b\u0435\u043c\u0435\u043d\u0442 \u0437\u0430\u0431\u043b\u043e\u043a\u043e\u0432\u0430\u043d\u0438\u0439 \u044f\u043a \u0441\u043b\u0456\u0434"
    },
    "assistant_preview_end": {
        "message": "\u0417\u0430\u043a\u0456\u043d\u0447\u0438\u0442\u0438 \u043f\u043e\u043f\u0435\u0440\u0435\u0434\u043d\u0456\u0439 \u043f\u0435\u0440\u0435\u0433\u043b\u044f\u0434"
    },
    "wot_unknown_description": {
        "message": "\u0420\u0435\u043f\u0443\u0442\u0430\u0446\u0456\u044f \u043d\u0435 \u0432\u0438\u0437\u043d\u0430\u0447\u0435\u043d\u0430"
    },
    "wot_bad_description": {
        "message": "\u0426\u0435\u0439 \u0441\u0430\u0439\u0442 \u043c\u0430\u0454 \u0434\u0443\u0436\u0435 \u043f\u043e\u0433\u0430\u043d\u0443 \u0440\u0435\u043f\u0443\u0442\u0430\u0446\u0456\u044e\n\u0437\u0430 \u0432\u0435\u0440\u0441\u0456\u0454\u044e "
    },
    "wot_poor_description": {
        "message": "\u0426\u0435\u0439 \u0441\u0430\u0439\u0442 \u043c\u0430\u0454 \u043f\u043e\u0433\u0430\u043d\u0443 \u0440\u0435\u043f\u0443\u0442\u0430\u0446\u0456\u044e\n\u0437\u0430 \u0432\u0435\u0440\u0441\u0456\u0454\u044e "
    },
    "wot_unsatisfactory_description": {
        "message": "\u0426\u0435\u0439 \u0441\u0430\u0439\u0442 \u043c\u0430\u0454 \u043d\u0435\u0437\u0430\u0434\u043e\u0432\u0456\u043b\u044c\u043d\u0443 \u0440\u0435\u043f\u0443\u0442\u0430\u0446\u0456\u044e\n\u0437\u0430 \u0432\u0435\u0440\u0441\u0456\u0454\u044e "
    },
    "wot_good_description": {
        "message": "\u0426\u0435\u0439 \u0441\u0430\u0439\u0442 \u043c\u0430\u0454 \u0434\u043e\u0431\u0440\u0443 \u0440\u0435\u043f\u0443\u0442\u0430\u0446\u0456\u044e\n\u0437\u0430 \u0432\u0435\u0440\u0441\u0456\u0454\u044e "
    },
    "wot_excellent_description": {
        "message": "\u0426\u0435\u0439 \u0441\u0430\u0439\u0442 \u043c\u0430\u0454 \u0434\u0443\u0436\u0435 \u0432\u0456\u0434\u043c\u0456\u043d\u043d\u0443 \u0440\u0435\u043f\u0443\u0442\u0430\u0446\u0456\u044e\n\u0437\u0430 \u0432\u0435\u0440\u0441\u0456\u0454\u044e "
    },
    "settings_choose_size_and_position": {
        "message": "\u041d\u0430\u043b\u0430\u0448\u0442\u0443\u0439\u0442\u0435 \u0440\u043e\u0437\u043c\u0456\u0440 \u0456 \u043f\u043e\u043b\u043e\u0436\u0435\u043d\u043d\u044f \u043f\u043e\u043c\u0456\u0447\u043d\u0438\u043a\u0430 Adguard"
    },
    "settings_icon_size": {
        "message": "\u0420\u043e\u0437\u043c\u0456\u0440 \u0456\u043a\u043e\u043d\u043a\u0438:"
    },
    "settings_small": {
        "message": "\u041c\u0430\u043b\u0435\u043d\u044c\u043a\u0430"
    },
    "settings_big": {
        "message": "\u0412\u0435\u043b\u0438\u043a\u0430"
    },
    "settings_position": {
        "message": "\u041f\u043e\u0437\u0438\u0446\u0456\u044f:"
    },
    "settings_left_top": {
        "message": "\u0417\u0432\u0435\u0440\u0445\u0443 \u0437\u043b\u0456\u0432\u0430"
    },
    "settings_right_top": {
        "message": "\u0417\u0432\u0435\u0440\u0445\u0443 \u0441\u043f\u0440\u0430\u0432\u0430"
    },
    "settings_left_bottom": {
        "message": "\u0412\u043d\u0438\u0437\u0443 \u0437\u043b\u0456\u0432\u0430"
    },
    "settings_right_bottom": {
        "message": "\u0412\u043d\u0438\u0437\u0443 \u0441\u043f\u0440\u0430\u0432\u0430"
    },
    "settings_cancel": {
        "message": "\u0421\u043a\u0430\u0441\u0443\u0432\u0430\u0442\u0438"
    },
    "settings_save": {
        "message": "\u0417\u0431\u0435\u0440\u0435\u0433\u0442\u0438 \u0437\u043c\u0456\u043d\u0438"
    }
}
var zh = {
    "menu_filtration_status": {
        "message": "\u5bf9\u6b64\u7f51\u7ad9\u8fdb\u884c\u8fc7\u6ee4"
    },
    "menu_do_not_filter_30_sec": {
        "message": "\u6682\u505c\u8fc7\u6ee4 30 \u79d2"
    },
    "menu_block_ad_on_site": {
        "message": "\u62e6\u622a\u6b64\u7f51\u7ad9\u4e0a\u7684\u5e7f\u544a"
    },
    "menu_report_abuse": {
        "message": "\u62a5\u544a\u6b64\u7f51\u7ad9"
    },
    "menu_site_report": {
        "message": "\u7f51\u7ad9\u5b89\u5168\u62a5\u544a"
    },
    "menu_settings": {
        "message": "\u52a9\u624b\u8bbe\u7f6e"
    },
    "assistant_select_element": {
        "message": "\u62e6\u622a\u5143\u7d20"
    },
    "assistant_select_element_ext": {
        "message": "\u9009\u62e9\u6b64\u9875\u9762\u4e0a\u9700\u8981\u62e6\u622a\u7684\u5143\u7d20"
    },
    "assistant_select_element_cancel": {
        "message": "\u53d6\u6d88"
    },
    "assistant_block_element": {
        "message": "\u62e6\u622a\u5143\u7d20"
    },
    "assistant_block_element_explain": {
        "message": "\u8c03\u6574\u5143\u7d20\u62e6\u622a\u89c4\u5219"
    },
    "assistant_slider_explain": {
        "message": "\u4f7f\u7528\u6ed1\u5757\u6539\u53d8\u8981\u7531\u65b0\u89c4\u5219\u5c06\u8981\u62e6\u622a\u7684\u6846\u67b6\u5927\u5c0f\uff1a"
    },
    "assistant_slider_min": {
        "message": "\u6700\u5c0f"
    },
    "assistant_slider_max": {
        "message": "\u6700\u5927"
    },
    "assistant_extended_settings": {
        "message": "\u9ad8\u7ea7\u8bbe\u7f6e"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "\u5e94\u7528\u89c4\u5219\u81f3\u6240\u6709\u7f51\u7ad9"
    },
    "assistant_block_by_reference": {
        "message": "\u901a\u8fc7\u53c2\u8003\u94fe\u63a5\u8fdb\u884c\u62e6\u622a"
    },
    "assistant_block_similar": {
        "message": "\u62e6\u622a\u7c7b\u4f3c\u5143\u7d20"
    },
    "assistant_another_element": {
        "message": "\u9009\u62e9\u5176\u5b83\u5143\u7d20"
    },
    "assistant_preview": {
        "message": "\u9884\u89c8"
    },
    "assistant_block": {
        "message": "\u62e6\u622a"
    },
    "assistant_settings": {
        "message": "Adguard \u52a9\u624b\u8bbe\u7f6e"
    },
    "assistant_preview_header": {
        "message": "\u5143\u7d20\u62e6\u622a - \u9884\u89c8"
    },
    "assistant_preview_header_info": {
        "message": "\u8bf7\u786e\u4fdd\u5143\u7d20\u62e6\u622a\u65b9\u5f0f\u7b26\u5408\u9884\u671f"
    },
    "assistant_preview_end": {
        "message": "\u9000\u51fa\u9884\u89c8"
    },
    "wot_unknown_description": {
        "message": "\u58f0\u671b\u5c1a\u672a\u5b9a\u4e49"
    },
    "wot_bad_description": {
        "message": "\u6b64\u7f51\u7ad9\u5728\u4ee5\u4e0b\u6570\u636e\u5e93\u4e2d\u58f0\u671b\u6781\u4f4e"
    },
    "wot_poor_description": {
        "message": "\u6b64\u7f51\u7ad9\u5728\u4ee5\u4e0b\u6570\u636e\u5e93\u4e2d\u58f0\u671b\u4f4e\u4e0b "
    },
    "wot_unsatisfactory_description": {
        "message": "\u6b64\u7f51\u7ad9\u5728\u4ee5\u4e0b\u6570\u636e\u5e93\u4e2d\u58f0\u671b\u4e0d\u4f73 "
    },
    "wot_good_description": {
        "message": "\u6b64\u7f51\u7ad9\u5728\u4ee5\u4e0b\u6570\u636e\u5e93\u4e2d\u58f0\u671b\u826f\u597d "
    },
    "wot_excellent_description": {
        "message": "\u6b64\u7f51\u7ad9\u5728\u4ee5\u4e0b\u6570\u636e\u5e93\u4e2d\u58f0\u671b\u6781\u4f73 "
    },
    "settings_choose_size_and_position": {
        "message": "\u8c03\u6574 Adguard \u52a9\u624b\u7684\u5927\u5c0f\u4e0e\u4f4d\u7f6e"
    },
    "settings_icon_size": {
        "message": "\u56fe\u6807\u5927\u5c0f\uff1a"
    },
    "settings_small": {
        "message": "\u5c0f"
    },
    "settings_big": {
        "message": "\u5927"
    },
    "settings_position": {
        "message": "\u4f4d\u7f6e\uff1a"
    },
    "settings_left_top": {
        "message": "\u5de6\u4e0a\u89d2"
    },
    "settings_right_top": {
        "message": "\u53f3\u4e0a\u89d2"
    },
    "settings_left_bottom": {
        "message": "\u5de6\u4e0b\u89d2"
    },
    "settings_right_bottom": {
        "message": "\u53f3\u4e0b\u89d2"
    },
    "settings_cancel": {
        "message": "\u53d6\u6d88"
    },
    "settings_save": {
        "message": "\u4fdd\u5b58\u66f4\u6539"
    }
}
var de = {
    "menu_filtration_status": {
        "message": "Auf dieser Webseite filtern"
    },
    "menu_do_not_filter_30_sec": {
        "message": "F\u00fcr 30 Sekunden nicht blockieren"
    },
    "menu_block_ad_on_site": {
        "message": "Werbung auf dieser Seite blockieren"
    },
    "menu_report_abuse": {
        "message": "Diese Webseite melden"
    },
    "menu_site_report": {
        "message": "Webseiten-Sicherheitsbericht"
    },
    "menu_settings": {
        "message": "Assistenten-Einstellungen"
    },
    "assistant_select_element": {
        "message": "Element-Blockierung"
    },
    "assistant_select_element_ext": {
        "message": "W\u00e4hlen Sie ein zu blockierendes Element auf der Seite aus"
    },
    "assistant_select_element_cancel": {
        "message": "Abbrechen"
    },
    "assistant_block_element": {
        "message": "Element-Blockierung"
    },
    "assistant_block_element_explain": {
        "message": "Anpassen der Regel der Element-Blockierung"
    },
    "assistant_slider_explain": {
        "message": "Bewegen Sie den Schieberegler, um die Ausma\u00dfgr\u00f6\u00dfe der neuen Regeln zu \u00e4ndern:"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAX"
    },
    "assistant_extended_settings": {
        "message": "Erweiterte Einstellungen"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "Regel auf alle Webseiten anwenden"
    },
    "assistant_block_by_reference": {
        "message": "Durch Referenzlink blockieren"
    },
    "assistant_block_similar": {
        "message": "\u00c4hnliche Elemente blockieren"
    },
    "assistant_another_element": {
        "message": "Ein anderes Element w\u00e4hlen"
    },
    "assistant_preview": {
        "message": "Vorschau"
    },
    "assistant_block": {
        "message": "Blockieren"
    },
    "assistant_settings": {
        "message": "Assistenten-Einstellungen"
    },
    "assistant_preview_header": {
        "message": "Element-Blockierung - Vorschau"
    },
    "assistant_preview_header_info": {
        "message": "Pr\u00fcfen Sie, ob das Element blockiert ist"
    },
    "assistant_preview_end": {
        "message": "Vorschau beenden"
    },
    "wot_unknown_description": {
        "message": "Kein Ruf festgelegt"
    },
    "wot_bad_description": {
        "message": "Diese Webseite hat einen sehr schlechten Ruf laut "
    },
    "wot_poor_description": {
        "message": "Diese Webseite hat einen schlechten Ruf laut "
    },
    "wot_unsatisfactory_description": {
        "message": "Diese Website hat einen schlechten Ruf laut "
    },
    "wot_good_description": {
        "message": "Diese Webseite hat einen guten Ruf laut "
    },
    "wot_excellent_description": {
        "message": "Diese Webseite hat einen exzellenten Ruf laut "
    },
    "settings_choose_size_and_position": {
        "message": "Anpassen der Gr\u00f6\u00dfe und Position des Adguard-Assistenten"
    },
    "settings_icon_size": {
        "message": "Symbol-Gr\u00f6\u00dfe:"
    },
    "settings_small": {
        "message": "Klein"
    },
    "settings_big": {
        "message": "Gro\u00df"
    },
    "settings_position": {
        "message": "Position:"
    },
    "settings_left_top": {
        "message": "Oben links"
    },
    "settings_right_top": {
        "message": "Oben rechts"
    },
    "settings_left_bottom": {
        "message": "Unten links"
    },
    "settings_right_bottom": {
        "message": "Unten rechts"
    },
    "settings_cancel": {
        "message": "Abbrechen"
    },
    "settings_save": {
        "message": "\u00c4nderungen speichern"
    }
}
var tr = {
    "menu_filtration_status": {
        "message": "Bu sitedeki filtreleme"
    },
    "menu_do_not_filter_30_sec": {
        "message": "30 saniye boyunca filtreleme yapma"
    },
    "menu_block_ad_on_site": {
        "message": "Bu sitede reklam engelle"
    },
    "menu_report_abuse": {
        "message": "Bu siteyi rapor et"
    },
    "menu_site_report": {
        "message": "Sitenin g\u00fcvenlik raporu"
    },
    "menu_settings": {
        "message": "Assistant Ayarlar\u0131"
    },
    "assistant_select_element": {
        "message": "\u00d6ge engelleme"
    },
    "assistant_select_element_ext": {
        "message": "Bu sitede engellemek i\u00e7in bir \u00f6ge se\u00e7in"
    },
    "assistant_select_element_cancel": {
        "message": "\u0130ptal"
    },
    "assistant_block_element": {
        "message": "\u00d6ge engelleme"
    },
    "assistant_block_element_explain": {
        "message": "\u00d6ge engelleme kural\u0131n\u0131 ayarla"
    },
    "assistant_slider_explain": {
        "message": "Yeni kural\u0131n \u00e7al\u0131\u015faca\u011f\u0131 \u00e7er\u00e7evenin boyutunu de\u011fi\u015ftirmek i\u00e7in kayar d\u00fc\u011fmeyi hareket ettirin"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAKS"
    },
    "assistant_extended_settings": {
        "message": "Geli\u015fmi\u015f ayarlar"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "T\u00fcm web sitelerinde bu kural\u0131 uygula"
    },
    "assistant_block_by_reference": {
        "message": "Referans ba\u011flant\u0131 ile engelle"
    },
    "assistant_block_similar": {
        "message": "Benzerlerini engelle"
    },
    "assistant_another_element": {
        "message": "Farkl\u0131 bir \u00f6ge se\u00e7"
    },
    "assistant_preview": {
        "message": "\u00d6nizleme"
    },
    "assistant_block": {
        "message": "Engelle"
    },
    "assistant_settings": {
        "message": "Assistant ayarlar\u0131"
    },
    "assistant_preview_header": {
        "message": "\u00d6\u011fe engelleme - \u00f6nizleme"
    },
    "assistant_preview_header_info": {
        "message": "\u00d6genin istedi\u011finiz gibi engellendi\u011finden emin olun"
    },
    "assistant_preview_end": {
        "message": "\u00d6nizlemeden \u00e7\u0131k"
    },
    "wot_unknown_description": {
        "message": "Pop\u00fclarite belirlenmemi\u015f"
    },
    "wot_bad_description": {
        "message": "Bu web sitesi \u00e7ok k\u00f6t\u00fc bir itibara sahip "
    },
    "wot_poor_description": {
        "message": "Bu web sitesi k\u00f6t\u00fc bir itibara sahip"
    },
    "wot_unsatisfactory_description": {
        "message": "Bu web sitesi zay\u0131f bir itibara sahip "
    },
    "wot_good_description": {
        "message": "Bu web sitesi iyi bir itibara sahip "
    },
    "wot_excellent_description": {
        "message": "Bu web sitesi m\u00fckemmel bir itibara sahip "
    },
    "settings_choose_size_and_position": {
        "message": "Adguard Assistant'\u0131n boyut ve konumunu ayarla"
    },
    "settings_icon_size": {
        "message": "Simge boyutu:"
    },
    "settings_small": {
        "message": "K\u00fc\u00e7\u00fck"
    },
    "settings_big": {
        "message": "B\u00fcy\u00fck"
    },
    "settings_position": {
        "message": "Konum:"
    },
    "settings_left_top": {
        "message": "Sol \u00fcst"
    },
    "settings_right_top": {
        "message": "Sa\u011f \u00fcst"
    },
    "settings_left_bottom": {
        "message": "Sol alt"
    },
    "settings_right_bottom": {
        "message": "Sa\u011f alt"
    },
    "settings_cancel": {
        "message": "\u0130ptal"
    },
    "settings_save": {
        "message": "De\u011fi\u015fiklikleri kaydet"
    }
}
var ja = {
    "menu_filtration_status": {
        "message": "\u3053\u306e\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u3092\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0"
    },
    "menu_do_not_filter_30_sec": {
        "message": "30\u79d2\u9593\u30d5\u30a3\u30eb\u30bf\u30ea\u30f3\u30b0\u3092\u884c\u308f\u306a\u3044"
    },
    "menu_block_ad_on_site": {
        "message": "\u3053\u306e\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u306e\u5e83\u544a\u3092\u30d6\u30ed\u30c3\u30af"
    },
    "menu_report_abuse": {
        "message": "\u3053\u306e\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u3092\u5831\u544a"
    },
    "menu_site_report": {
        "message": "\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u306e\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u30ec\u30dd\u30fc\u30c8"
    },
    "menu_settings": {
        "message": "\u30a2\u30b7\u30b9\u30bf\u30f3\u30c8\u306e\u8a2d\u5b9a"
    },
    "assistant_select_element": {
        "message": "\u8981\u7d20\u3092\u30d6\u30ed\u30c3\u30af"
    },
    "assistant_select_element_ext": {
        "message": "\u30d6\u30ed\u30c3\u30af\u3059\u308b\u8981\u7d20\u3092\u9078\u629e"
    },
    "assistant_select_element_cancel": {
        "message": "\u30ad\u30e3\u30f3\u30bb\u30eb"
    },
    "assistant_block_element": {
        "message": "\u8981\u7d20\u3092\u30d6\u30ed\u30c3\u30af"
    },
    "assistant_block_element_explain": {
        "message": "\u8981\u7d20\u306e\u30d6\u30ed\u30c3\u30af\u30eb\u30fc\u30eb\u3092\u8abf\u6574\u3059\u308b"
    },
    "assistant_slider_explain": {
        "message": "\u30b9\u30e9\u30a4\u30c0\u30fc\u3092\u52d5\u304b\u3059\u3068\u3001\u30d6\u30ed\u30c3\u30af\u3059\u308b\u30d5\u30ec\u30fc\u30e0\u306e\u30b5\u30a4\u30ba\u3092\u5909\u66f4\u3067\u304d\u307e\u3059:"
    },
    "assistant_slider_min": {
        "message": "\u6700\u5c0f"
    },
    "assistant_slider_max": {
        "message": "\u6700\u5927"
    },
    "assistant_extended_settings": {
        "message": "\u9ad8\u5ea6\u306a\u8a2d\u5b9a"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "\u5168\u3066\u306e\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u306b\u3053\u306e\u30eb\u30fc\u30eb\u3092\u9069\u7528"
    },
    "assistant_block_by_reference": {
        "message": "\u53c2\u7167\u30ea\u30f3\u30af\u306b\u3088\u308b\u30d6\u30ed\u30c3\u30af"
    },
    "assistant_block_similar": {
        "message": "\u985e\u4f3c\u9805\u76ee\u3092\u30d6\u30ed\u30c3\u30af"
    },
    "assistant_another_element": {
        "message": "\u4ed6\u306e\u8981\u7d20\u3092\u9078\u629e"
    },
    "assistant_preview": {
        "message": "\u30d7\u30ec\u30d3\u30e5\u30fc"
    },
    "assistant_block": {
        "message": "\u30d6\u30ed\u30c3\u30af"
    },
    "assistant_settings": {
        "message": "\u30a2\u30b7\u30b9\u30bf\u30f3\u30c8\u306e\u8a2d\u5b9a"
    },
    "assistant_preview_header": {
        "message": "\u8981\u7d20\u306e\u30d6\u30ed\u30c3\u30af - \u30d7\u30ec\u30d3\u30e5\u30fc"
    },
    "assistant_preview_header_info": {
        "message": "\u8981\u7d20\u304c\u610f\u56f3\u3057\u305f\u3068\u304a\u308a\u306b\u30d6\u30ed\u30c3\u30af\u3055\u308c\u3066\u3044\u308b\u3053\u3068\u3092\u78ba\u8a8d\u3057\u307e\u3059"
    },
    "assistant_preview_end": {
        "message": "\u30d7\u30ec\u30d3\u30e5\u30fc\u3092\u7d42\u4e86"
    },
    "wot_unknown_description": {
        "message": "\u8a55\u5224\u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u307e\u305b\u3093"
    },
    "wot_bad_description": {
        "message": "\u3053\u306e\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u306f\u975e\u5e38\u306b\u8a55\u5224\u304c\u60aa\u3044\u3067\u3059: "
    },
    "wot_poor_description": {
        "message": "\u3053\u306e\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u306f\u8a55\u5224\u304c\u60aa\u3044\u3067\u3059: "
    },
    "wot_unsatisfactory_description": {
        "message": "\u3053\u306e\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u306f\u8a55\u5224\u304c\u3084\u3084\u60aa\u3044\u3067\u3059: "
    },
    "wot_good_description": {
        "message": "\u3053\u306e\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u306f\u8a55\u5224\u304c\u826f\u3044\u3067\u3059: "
    },
    "wot_excellent_description": {
        "message": "\u3053\u306e\u30a6\u30a7\u30d6\u30b5\u30a4\u30c8\u306f\u3068\u3066\u3082\u8a55\u5224\u304c\u826f\u3044\u3067\u3059: "
    },
    "settings_choose_size_and_position": {
        "message": "Adguard\u30a2\u30b7\u30b9\u30bf\u30f3\u30c8\u306e\u30b5\u30a4\u30ba\u3068\u4f4d\u7f6e\u3092\u8abf\u6574\u3059\u308b"
    },
    "settings_icon_size": {
        "message": "\u30a2\u30a4\u30b3\u30f3\u306e\u5927\u304d\u3055:"
    },
    "settings_small": {
        "message": "\u5c0f"
    },
    "settings_big": {
        "message": "\u5927"
    },
    "settings_position": {
        "message": "\u4f4d\u7f6e:"
    },
    "settings_left_top": {
        "message": "\u5de6\u4e0a"
    },
    "settings_right_top": {
        "message": "\u53f3\u4e0a"
    },
    "settings_left_bottom": {
        "message": "\u5de6\u4e0b"
    },
    "settings_right_bottom": {
        "message": "\u53f3\u4e0b"
    },
    "settings_cancel": {
        "message": "\u30ad\u30e3\u30f3\u30bb\u30eb"
    },
    "settings_save": {
        "message": "\u8a2d\u5b9a\u3092\u4fdd\u5b58"
    }
}
var ar = {
    "menu_filtration_status": {
        "message": "\u062a\u0641\u0639\u064a\u0644 \u0627\u0644\u0641\u0644\u062a\u0631\u0629\u0639\u0644\u0649 \u0647\u0630\u0627 \u0627\u0644\u0645\u0648\u0642\u0639"
    },
    "menu_do_not_filter_30_sec": {
        "message": "\u0639\u062f\u0645 \u0627\u0644\u0641\u0644\u062a\u0631\u0629 \u0644\u0645\u062f\u0647 30 \u062b\u0627\u0646\u064a\u0647"
    },
    "menu_block_ad_on_site": {
        "message": "\u0645\u0646\u0639 \u0627\u0644\u0625\u0639\u0644\u0627\u0646 \u0639\u0644\u0649 \u0647\u0630\u0627 \u0627\u0644\u0645\u0648\u0642\u0639"
    },
    "menu_report_abuse": {
        "message": "\u0627\u0644\u0625\u0628\u0644\u0627\u063a \u0639\u0646 \u0647\u0630\u0627 \u0627\u0644\u0645\u0648\u0642\u0639"
    },
    "menu_site_report": {
        "message": "\u062a\u0642\u0631\u064a\u0631 \u0623\u0645\u0646 \u0627\u0644\u0645\u0648\u0642\u0639"
    },
    "menu_settings": {
        "message": "\u0625\u0639\u062f\u0627\u062f\u0627\u062a \u0627\u0644\u0645\u0633\u0627\u0639\u062f"
    },
    "assistant_select_element": {
        "message": "\u062d\u0638\u0631 \u0627\u0644\u0639\u0646\u0635\u0631"
    },
    "assistant_select_element_ext": {
        "message": "\u0627\u062e\u062a\u0631 \u0639\u0646\u0635\u0631\u0627 \u0641\u064a \u0627\u0644\u0635\u0641\u062d\u0629 \u0644\u0644\u062d\u0638\u0631"
    },
    "assistant_select_element_cancel": {
        "message": "\u0627\u0644\u063a\u0627\u0621"
    },
    "assistant_block_element": {
        "message": "\u062d\u0638\u0631 \u0627\u0644\u0639\u0646\u0635\u0631"
    },
    "assistant_block_element_explain": {
        "message": "\u0636\u0628\u0637 \u0642\u0627\u0639\u062f\u0629 \u062d\u0638\u0631 \u0627\u0644\u0639\u0646\u0635\u0631"
    },
    "assistant_slider_explain": {
        "message": "\u062d\u0631\u0643 \u0634\u0631\u064a\u0637 \u0627\u0644\u062a\u0645\u0631\u064a\u0631 \u0644\u062a\u063a\u064a\u064a\u0631 \u062d\u062c\u0645 \u0627\u0644\u0625\u0637\u0627\u0631 \u0627\u0644\u0630\u064a \u0633\u062a\u0639\u0645\u0644 \u0639\u0644\u064a\u0647 \u0627\u0644\u0642\u0627\u0639\u062f\u0629 \u0627\u0644\u062c\u062f\u064a\u062f\u0629:"
    },
    "assistant_slider_min": {
        "message": "\u062d\u062f \u0627\u062f\u0646\u064a"
    },
    "assistant_slider_max": {
        "message": "\u0643\u062d\u062f \u0623\u0642\u0635\u0649"
    },
    "assistant_extended_settings": {
        "message": "\u0625\u0639\u062f\u0627\u062f\u0627\u062a \u0645\u062a\u0642\u062f\u0645\u0629"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "\u062a\u0637\u0628\u064a\u0642 \u0627\u0644\u0642\u0627\u0639\u062f\u0629 \u0639\u0644\u064a \u0643\u0627\u0641\u0629 \u0645\u0648\u0627\u0642\u0639 \u0627\u0644\u0648\u064a\u0628"
    },
    "assistant_block_by_reference": {
        "message": "\u062d\u0638\u0631 \u062d\u0633\u0628 \u0627\u0644\u0627\u0631\u062a\u0628\u0627\u0637 \u0627\u0644\u0645\u0631\u062c\u0639\u064a"
    },
    "assistant_block_similar": {
        "message": "\u062d\u0638\u0631 \u0639\u0646\u0635\u0631 \u0645\u0645\u0627 \u062b\u0644"
    },
    "assistant_another_element": {
        "message": "\u062a\u062d\u062f\u064a\u062f \u0639\u0646\u0635\u0631 \u0622\u062e\u0631"
    },
    "assistant_preview": {
        "message": "\u0627\u0644\u0645\u0639\u0627\u064a\u0646\u0647"
    },
    "assistant_block": {
        "message": "\u062d\u0638\u0631"
    },
    "assistant_settings": {
        "message": "\u0625\u0639\u062f\u0627\u062f\u0627\u062a \u0627\u0644\u0645\u0633\u0627\u0639\u062f"
    },
    "assistant_preview_header": {
        "message": "\u062d\u062c\u0628 \u0639\u0646\u0635\u0631--\u0645\u0639\u0627\u064a\u0646\u0647"
    },
    "assistant_preview_header_info": {
        "message": "\u062a\u0627\u0643\u062f \u0645\u0646 \u062d\u0638\u0631 \u0647\u0630\u0627 \u0627\u0644\u0639\u0646\u0635\u0631 \u0643\u0645\u0627 \u0647\u0648 \u0645\u0642\u0635\u0648\u062f"
    },
    "assistant_preview_end": {
        "message": "\u0625\u0646\u0647\u0627\u0621 \u0627\u0644\u0645\u0639\u0627\u064a\u0646\u0629"
    },
    "wot_unknown_description": {
        "message": "\u0644\u0645 \u064a\u062a\u0645 \u062a\u0639\u0631\u064a\u0641 \u0627\u0644\u0633\u0645\u0639\u0629"
    },
    "wot_bad_description": {
        "message": "\u0647\u0630\u0627 \u0627\u0644\u0645\u0648\u0642\u0639 \u0644\u062f\u064a\u0647 \u0633\u0645\u0639\u0629 \u0633\u064a\u0626\u0629 \u0644\u0644\u063a\u0627\u064a\u0629 \n\u0648\u0641\u0642\u0627 \u0644 "
    },
    "wot_poor_description": {
        "message": "\u0647\u0630\u0627 \u0627\u0644\u0645\u0648\u0642\u0639 \u0644\u062f\u064a\u0647 \u0633\u0645\u0639\u0629 \u0633\u064a\u0626\u0629 \n\u0648\u0641\u0642\u0627 \u0644 "
    },
    "wot_unsatisfactory_description": {
        "message": "\u0647\u0630\u0627 \u0627\u0644\u0645\u0648\u0642\u0639 \u0644\u062f\u064a\u0647 \u0633\u0645\u0639\u0629 \u0633\u064a\u0626\u0629 \n\u0648\u0641\u0642\u0627 \u0644 "
    },
    "wot_good_description": {
        "message": "\u0647\u0630\u0627 \u0627\u0644\u0645\u0648\u0642\u0639 \u0644\u062f\u064a\u0647 \u0633\u0645\u0639\u0629 \u062c\u064a\u062f\u0629 \n\u0648\u0641\u0642\u0627 \u0644 "
    },
    "wot_excellent_description": {
        "message": "\u0647\u0630\u0627 \u0627\u0644\u0645\u0648\u0642\u0639 \u0644\u062f\u064a\u0647 \u0633\u0645\u0639\u0629 \u0645\u0645\u062a\u0627\u0632\u0629 \n\u0648\u0641\u0642\u0627 \u0644 "
    },
    "settings_choose_size_and_position": {
        "message": "\u0636\u0628\u0637 \u062d\u062c\u0645 \u0645\u0633\u0627\u0639\u062f Adguard \u0648\u0645\u0648\u0636\u0639\u0647"
    },
    "settings_icon_size": {
        "message": "\u062d\u062c\u0645 \u0627\u0644\u0631\u0645\u0632:"
    },
    "settings_small": {
        "message": "\u0635\u063a\u064a\u0631"
    },
    "settings_big": {
        "message": "\u0643\u0628\u064a\u0631"
    },
    "settings_position": {
        "message": "\u0648\u0636\u0639"
    },
    "settings_left_top": {
        "message": "\u0627\u0639\u0644\u064a \u0627\u0644\u064a\u0633\u0627\u0631"
    },
    "settings_right_top": {
        "message": "\u0627\u0639\u0644\u064a \u0627\u0644\u064a\u0645\u064a\u0646"
    },
    "settings_left_bottom": {
        "message": "\u0623\u0633\u0641\u0644 \u0627\u0644\u064a\u0633\u0627\u0631"
    },
    "settings_right_bottom": {
        "message": "\u0623\u0633\u0641\u0644 \u0644\u0644\u064a\u0645\u064a\u0646"
    },
    "settings_cancel": {
        "message": "\u0627\u0644\u063a\u0627\u0621"
    },
    "settings_save": {
        "message": "\u062d\u0641\u0638 \u0627\u0644\u062a\u063a\u064a\u064a\u0631\u0627\u062a"
    }
}
var es_419 = {
    "menu_filtration_status": {
        "message": "Filtrando en esta p\u00e1gina"
    },
    "menu_do_not_filter_30_sec": {
        "message": "No filtrar durante 30 segundos"
    },
    "menu_block_ad_on_site": {
        "message": "Bloquear anuncio en esta p\u00e1gina"
    },
    "menu_report_abuse": {
        "message": "Reportar la p\u00e1gina"
    },
    "menu_site_report": {
        "message": "Reporte de seguridad sobre la p\u00e1gina"
    },
    "menu_settings": {
        "message": "Configuraci\u00f3n del Asistente"
    },
    "assistant_select_element": {
        "message": "Bloqueo de Elementos"
    },
    "assistant_select_element_ext": {
        "message": "Seleccione un elemento de la p\u00e1gina para bloquear"
    },
    "assistant_select_element_cancel": {
        "message": "Cancelar"
    },
    "assistant_block_element": {
        "message": "Bloqueo de Elementos"
    },
    "assistant_block_element_explain": {
        "message": "Ajustar regla del bloqueo de elementos"
    },
    "assistant_slider_explain": {
        "message": "Mueva el deslizador para cambiar el tama\u00f1o del marco para el que trabajar\u00e1 la nueva regla:"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAX"
    },
    "assistant_extended_settings": {
        "message": "Configuraci\u00f3n avanzada"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "Aplicar la norma a todas las p\u00e1ginas"
    },
    "assistant_block_by_reference": {
        "message": "Bloquear por enlace de referencia"
    },
    "assistant_block_similar": {
        "message": "Bloquear similares"
    },
    "assistant_another_element": {
        "message": "Seleccionar otro elemento"
    },
    "assistant_preview": {
        "message": "Vista previa"
    },
    "assistant_block": {
        "message": "Bloquear"
    },
    "assistant_settings": {
        "message": "Configuraci\u00f3n del asistente"
    },
    "assistant_preview_header": {
        "message": "Bloqueo de elementos - vista previa"
    },
    "assistant_preview_header_info": {
        "message": "Aseg\u00farese de que el elemento est\u00e1 bloqueado como se pretende"
    },
    "assistant_preview_end": {
        "message": "Salir de vista previa"
    },
    "wot_unknown_description": {
        "message": "La reputaci\u00f3n no est\u00e1 definida"
    },
    "wot_bad_description": {
        "message": "Esta p\u00e1gina tiene muy mala reputaci\u00f3n\nseg\u00fan "
    },
    "wot_poor_description": {
        "message": "Esta p\u00e1gina tiene mala reputaci\u00f3n \nseg\u00fan "
    },
    "wot_unsatisfactory_description": {
        "message": "Esta p\u00e1gina tiene poca reputaci\u00f3n \nseg\u00fan "
    },
    "wot_good_description": {
        "message": "Esta p\u00e1gina tiene buena reputaci\u00f3n \nseg\u00fan "
    },
    "wot_excellent_description": {
        "message": "Esta p\u00e1gina tiene excelente reputaci\u00f3n \nseg\u00fan "
    },
    "settings_choose_size_and_position": {
        "message": "Ajustar tama\u00f1o y posici\u00f3n de Adguard Assistant"
    },
    "settings_icon_size": {
        "message": "Tama\u00f1o del icono:"
    },
    "settings_small": {
        "message": "Peque\u00f1o"
    },
    "settings_big": {
        "message": "Grande"
    },
    "settings_position": {
        "message": "Posici\u00f3n:"
    },
    "settings_left_top": {
        "message": "Superior izquierda"
    },
    "settings_right_top": {
        "message": "Superior derecha"
    },
    "settings_left_bottom": {
        "message": "Inferior izquierda"
    },
    "settings_right_bottom": {
        "message": "Inferior derecha"
    },
    "settings_cancel": {
        "message": "Cancelar"
    },
    "settings_save": {
        "message": "Guardar cambios"
    }
}
var pt_BR = {
    "menu_filtration_status": {
        "message": "Filtrando neste site"
    },
    "menu_do_not_filter_30_sec": {
        "message": "N\u00e3o filtrar durante 30 segundos"
    },
    "menu_block_ad_on_site": {
        "message": "Bloquear an\u00fancios neste site"
    },
    "menu_report_abuse": {
        "message": "Denunciar o site"
    },
    "menu_site_report": {
        "message": "Relat\u00f3rio de seguran\u00e7a do site"
    },
    "menu_settings": {
        "message": "Configura\u00e7\u00f5es do assistente"
    },
    "assistant_select_element": {
        "message": "Bloqueio de elemento"
    },
    "assistant_select_element_ext": {
        "message": "Escolha um elemento na p\u00e1gina para bloquear"
    },
    "assistant_select_element_cancel": {
        "message": "Cancelar"
    },
    "assistant_block_element": {
        "message": "Bloqueio de elementos"
    },
    "assistant_block_element_explain": {
        "message": "Ajustar a regra de bloqueio de elemento"
    },
    "assistant_slider_explain": {
        "message": "Mova o controle deslizante para alterar o tamanho do quadro para o qual a nova regra funcionar\u00e1:"
    },
    "assistant_slider_min": {
        "message": "MIN"
    },
    "assistant_slider_max": {
        "message": "MAX"
    },
    "assistant_extended_settings": {
        "message": "Configura\u00e7\u00f5es avan\u00e7adas"
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "Aplicar a regra para todos os sites"
    },
    "assistant_block_by_reference": {
        "message": "Bloquear por link de refer\u00eancia"
    },
    "assistant_block_similar": {
        "message": "Bloquear semelhante"
    },
    "assistant_another_element": {
        "message": "Selecione outro elemento"
    },
    "assistant_preview": {
        "message": "Ver pr\u00e9via"
    },
    "assistant_block": {
        "message": "Bloquear"
    },
    "assistant_settings": {
        "message": "Configura\u00e7\u00f5es do assistente"
    },
    "assistant_preview_header": {
        "message": "Bloquear elemento - Pr\u00e9via"
    },
    "assistant_preview_header_info": {
        "message": "Certifique-se de que o elemento esteja bloqueado como pretendido"
    },
    "assistant_preview_end": {
        "message": "Sair da pr\u00e9via"
    },
    "wot_unknown_description": {
        "message": "Nenhuma reputa\u00e7\u00e3o definida"
    },
    "wot_bad_description": {
        "message": "Este site tem uma reputa\u00e7\u00e3o muito ruim\nde acordo com "
    },
    "wot_poor_description": {
        "message": "Este site tem uma m\u00e1 reputa\u00e7\u00e3o\nde acordo com "
    },
    "wot_unsatisfactory_description": {
        "message": "Este site tem uma reputa\u00e7\u00e3o ruim\nde acordo com "
    },
    "wot_good_description": {
        "message": "Este site tem uma boa reputa\u00e7\u00e3o\nde acordo com "
    },
    "wot_excellent_description": {
        "message": "Este site tem uma excelente reputa\u00e7\u00e3o\n\nde acordo com "
    },
    "settings_choose_size_and_position": {
        "message": "Ajuste o tamanho e posi\u00e7\u00e3o do AdGuard Assistente"
    },
    "settings_icon_size": {
        "message": "Tamanho do \u00edcone:"
    },
    "settings_small": {
        "message": "Pequeno"
    },
    "settings_big": {
        "message": "Grande"
    },
    "settings_position": {
        "message": "Posi\u00e7\u00e3o:"
    },
    "settings_left_top": {
        "message": "Canto superior esquerdo"
    },
    "settings_right_top": {
        "message": "Canto superior direito"
    },
    "settings_left_bottom": {
        "message": "Canto inferior esquerdo"
    },
    "settings_right_bottom": {
        "message": "Canto inferior direito"
    },
    "settings_cancel": {
        "message": "Cancelar"
    },
    "settings_save": {
        "message": "Salvar altera\u00e7\u00f5es"
    }
}
var ko = {
    "menu_filtration_status": {
        "message": "\uc774 \uc6f9\uc0ac\uc774\ud2b8\uc5d0\uc11c\uc758 \ubcf4\ud638"
    },
    "menu_do_not_filter_30_sec": {
        "message": "30\ucd08 \ub3d9\uc548 \ucc28\ub2e8 \uc77c\uc2dc\uc815\uc9c0"
    },
    "menu_block_ad_on_site": {
        "message": "\uc774 \uc6f9\uc0ac\uc774\ud2b8\uc5d0\uc11c \uad11\uace0 \ucc28\ub2e8"
    },
    "menu_report_abuse": {
        "message": "\uc774 \uc6f9\uc0ac\uc774\ud2b8\uc5d0 \uad00\ud55c \ubd88\ub9cc \uc0ac\ud56d \uc81c\ucd9c"
    },
    "menu_site_report": {
        "message": "\uc6f9\uc0ac\uc774\ud2b8 \ubcf4\uc548 \ubcf4\uace0"
    },
    "menu_settings": {
        "message": "Adguard \uc124\uc815"
    },
    "assistant_select_element": {
        "message": "\uc120\ud0dd \ubaa8\ub4dc"
    },
    "assistant_select_element_ext": {
        "message": "\ud398\uc774\uc9c0\uc5d0\uc11c \uc544\ubb34 \uc694\uc18c\ub098 \ud074\ub9ad\ud558\uac70\ub098"
    },
    "assistant_select_element_cancel": {
        "message": "\uc120\ud0dd \ubaa8\ub4dc \ucde8\uc18c"
    },
    "assistant_block_element": {
        "message": "\uc694\uc18c \ucc28\ub2e8"
    },
    "assistant_block_element_explain": {
        "message": "\uc694\uc18c \ucc28\ub2e8 \uaddc\uce59 \uc124\uc815"
    },
    "assistant_slider_explain": {
        "message": "\uc2ac\ub77c\uc774\ub354\ub85c \ucc28\ub2e8\ud560 \uc694\uc18c\uc758 \ubc94\uc704\ub97c \uc9c0\uc815\ud558\uc138\uc694."
    },
    "assistant_slider_min": {
        "message": "\uc791\uac8c"
    },
    "assistant_slider_max": {
        "message": "\ud06c\uac8c"
    },
    "assistant_extended_settings": {
        "message": "\uace0\uae09 \uc124\uc815..."
    },
    "assistant_apply_rule_to_all_sites": {
        "message": "\ubaa8\ub4e0 \uc6f9\uc0ac\uc774\ud2b8\uc5d0 \uc774 \uaddc\uce59 \uc801\uc6a9"
    },
    "assistant_block_by_reference": {
        "message": "\ucc38\uc870 \ub9c1\ud06c\uac00 \ucc28\ub2e8"
    },
    "assistant_block_similar": {
        "message": "\uc720\uc0ac\ud55c \uc694\uc18c \ucc28\ub2e8"
    },
    "assistant_another_element": {
        "message": "\ub2e4\ub978 \uc694\uc18c \uc120\ud0dd"
    },
    "assistant_preview": {
        "message": "\ubbf8\ub9ac \ubcf4\uae30"
    },
    "assistant_block": {
        "message": "\ucc28\ub2e8"
    },
    "assistant_settings": {
        "message": "\ub3c4\uc6b0\ubbf8 \uc124\uc815"
    },
    "assistant_preview_header": {
        "message": "\uc694\uc18c \ucc28\ub2e8 - \ubbf8\ub9ac \ubcf4\uae30"
    },
    "assistant_preview_header_info": {
        "message": "\uc758\ub3c4\ud55c \ub300\ub85c \uc694\uc18c\uac00 \ucc28\ub2e8\ub418\uc5c8\ub294\uc9c0 \ud655\uc778\ud558\uc138\uc694."
    },
    "assistant_preview_end": {
        "message": "\ubbf8\ub9ac \ubcf4\uae30 \uc885\ub8cc"
    },
    "wot_unknown_description": {
        "message": "\ud3c9\ud310\uc774 \ub4f1\ub85d\ub418\uc9c0 \uc54a\uc558\uc2b5\ub2c8\ub2e4."
    },
    "wot_bad_description": {
        "message": "\uc774 \uc6f9\uc0ac\uc774\ud2b8\ub294 \uc544\uc8fc \ub098\uc05c \ud3c9\ud310\uc744 \uac16\uace0 \uc788\uc2b5\ub2c8\ub2e4.\n\uc81c\uacf5 "
    },
    "wot_poor_description": {
        "message": "\uc774 \uc6f9\uc0ac\uc774\ud2b8\ub294 \ub098\uc05c \ud3c9\ud310\uc744 \uac16\uace0 \uc788\uc2b5\ub2c8\ub2e4.\n\uc81c\uacf5 "
    },
    "wot_unsatisfactory_description": {
        "message": "\uc774 \uc6f9\uc0ac\uc774\ud2b8\ub294 \uc88b\uc9c0 \uc54a\uc740 \ud3c9\ud310\uc744 \uac16\uace0 \uc788\uc2b5\ub2c8\ub2e4.\n\uc81c\uacf5 "
    },
    "wot_good_description": {
        "message": "\uc774 \uc6f9\uc0ac\uc774\ud2b8\ub294 \uc88b\uc740 \ud3c9\ud310\uc744 \uac16\uace0 \uc788\uc2b5\ub2c8\ub2e4.\n\uc81c\uacf5 "
    },
    "wot_excellent_description": {
        "message": "\uc774 \uc6f9\uc0ac\uc774\ud2b8\ub294 \uc544\uc8fc \uc88b\uc740 \ud3c9\ud310\uc744 \uac16\uace0 \uc788\uc2b5\ub2c8\ub2e4.\n\uc81c\uacf5 "
    },
    "settings_choose_size_and_position": {
        "message": "AdGuard \ub3c4\uc6b0\ubbf8\uc758 \ud06c\uae30\uc640 \uc704\uce58\ub97c \uc870\uc815\ud569\ub2c8\ub2e4."
    },
    "settings_icon_size": {
        "message": "\uc544\uc774\ucf58 \ud06c\uae30:"
    },
    "settings_small": {
        "message": "\uc791\uac8c"
    },
    "settings_big": {
        "message": "\ud06c\uac8c"
    },
    "settings_position": {
        "message": "\uc704\uce58:"
    },
    "settings_left_top": {
        "message": "\uc67c\ucabd \uc704"
    },
    "settings_right_top": {
        "message": "\uc624\ub978\ucabd \uc704"
    },
    "settings_left_bottom": {
        "message": "\uc67c\ucabd \uc544\ub798"
    },
    "settings_right_bottom": {
        "message": "\uc624\ub978\ucabd \uc544\ub798"
    },
    "settings_cancel": {
        "message": "\ucde8\uc18c"
    },
    "settings_save": {
        "message": "\uc800\uc7a5"
    }
}
/**
 * Object that manages localizations
 * @returns {{getMessage: Function, translateElement: Function}}
 * @constructor
 */
/* global en, ru, uk, pl, de, zh, he, it, fa, tr, ja, ar, es_419, pt_BR, ko, AdguardSettings */

var Localization = function() { // jshint ignore:line
    var currentLocale = null, locale;
    var SupportedLocales = {
        'en': en,
        'ru': ru,
        'uk': uk,
        'pl': pl,
        'de': de,
        'zh': zh,
        'he': he,
        'it': it,
        'fa': fa,
        'tr': tr,
        'ja': ja,
        'ar': ar,
        'es': es_419,
        'pt': pt_BR,
        'ko': ko
    };

    if (typeof AdguardSettings !== 'undefined') {
        locale = AdguardSettings.locale;
    } else if (navigator.languages) {
        locale = navigator.languages[0];
    } else if (navigator.language) {
        locale = navigator.language.split('-')[0];
    }

    if (SupportedLocales[locale]) {
        currentLocale = locale;
    } else {
        currentLocale = 'en';
    }

    var getMessage = function (messageId) {
        var message = SupportedLocales[currentLocale][messageId];
        if (!message) {
            throw messageId + ' not localized';
        }
        return SupportedLocales[currentLocale][messageId].message;
    };

    var translateElement = function (element, message) {
        try {
            while (element.lastChild) {
                element.removeChild(element.lastChild);
            }
            processString(message, element);
        } catch (ex) {
            // Ignore exceptions
        }
    };

    var processString = function (str, element) {
        var el;

        var match1 = /^([^]*?)<(a|strong|span|i)([^>]*)>(.*?)<\/\2>([^]*)$/m.exec(str);
        var match2 = /^([^]*?)<(br|input)([^>]*)\/?>([^]*)$/m.exec(str);
        if (match1) {

            processString(match1[1], element);

            el = createElement(match1[2], match1[3]);

            processString(match1[4], el);
            element.appendChild(el);

            processString(match1[5], element);

        } else if (match2) {

            processString(match2[1], element);

            el = createElement(match2[2], match2[3]);
            element.appendChild(el);

            processString(match2[4], element);

        } else {
            element.appendChild(document.createTextNode(str.replace(/&nbsp;/g, '\u00A0')));
        }
    };

    var createElement = function (tagName, attributes) {

        var el = document.createElement(tagName);
        if (!attributes) {
            return el;
        }

        var attrs = attributes.split(/([a-z]+='[^']+')/);
        for (var i = 0; i < attrs.length; i++) {
            var attr = attrs[i].trim();
            if (!attr) {
                continue;
            }
            var index = attr.indexOf("=");
            var attrName;
            var attrValue;
            if (index > 0) {
                attrName = attr.substring(0, index);
                attrValue = attr.substring(index + 2, attr.length - 1);
            }
            if (attrName && attrValue) {
                el.setAttribute(attrName, attrValue);
            }
        }
        return el;
    };

    return {
        getMessage: getMessage,
        translateElement: translateElement
    };
};

/**
 * Main menu controller
 * @param $
 * @param wot
 * @param localization
 * @param gmApi
 * @returns {{init: init}}
 * @constructor
 */
/* global Ioc, StringUtils, punycode */
var DetailedMenuController = function($, wot, localization, gmApi, settings, log) { // jshint ignore:line
    var contentDocument = null;
    var iframeCtrl = null;
    var domain = null;
    var FILTERING_STATE_LS_PROPERTY = '__adfstate';

    /*
     Called from IframeController._showMenuItem to initialize view
     */
    var init = function(iframe) {
        contentDocument = iframe.contentDocument;
        iframeCtrl = Ioc.get('iframeController');
        setDomain();
        setWotData();
        bindEvents();
        setInitFilteringState();
    };

    var setDomain = function() {
        domain = punycode.toUnicode(location.hostname);
        contentDocument.getElementsByClassName('menu-head_name')[0].textContent = domain;
    };

    var bindEvents = function() {
        var menuEvents = {
            '.close': iframeCtrl.removeIframe,
            '#block-ad': startAdSelector,
            '#assistant-settings': iframeCtrl.showSettingsMenu,
            '#WotDescriptionText': goToWotUrl,
            '#do-not-block-30-sec': doNotBlock,
            '#report-abuse': reportAbuse,
            '#site-report': goToSiteReport,
            '#is-filter': onIsFilterChange
        };
        Object.keys(menuEvents).forEach(function(item) {
            $(contentDocument.querySelectorAll(item)).on('click', menuEvents[item]);
        });
    };

    var onIsFilterChange = function() {
        var isFilter = contentDocument.getElementById('is-filter').checked;

        // animate class for prevent animation while the state from the application is determined
        $(contentDocument.querySelectorAll(".menu-filter_label")).addClass("animate");

        showHideBlockAdButton(isFilter);
        setFilteringStateToStore(isFilter);
        gmApi.ADG_changeFilteringState(isFilter, function() {
            CommonUtils.reloadPageBypassCache();
        });
    };

    var setInitFilteringState = function() {
        var input = contentDocument.getElementById('is-filter');
        input.checked = getFilteringStateFromStore();
        gmApi.ADG_isFiltered(function(isFiltered) {
            input.checked = isFiltered;
            setFilteringStateToStore(isFiltered);
            showHideBlockAdButton(isFiltered);
        });
    };

    /**
     * Storing the filtering state for quick initialization
     *
     * @param {Boolean} state  on/off filtering state
     */
    var setFilteringStateToStore = function(state) {
        try {
            localStorage.setItem(FILTERING_STATE_LS_PROPERTY, JSON.stringify({
                "state": state
            }));
        } catch (ex) {
            log.error(ex);
            return null;
        }
    };

    /**
     * Getting the filtering state for quick initialization from the localStorage,
     * while the state from the application is determined
     *
     * @returns {Boolean} on/off filtering state
     */
    var getFilteringStateFromStore = function() {
        try {
            var state = localStorage.getItem(FILTERING_STATE_LS_PROPERTY);
            if (state) {
                return JSON.parse(state).state;
            } else {
                return false;
            }
        } catch (ex) {
            log.error(ex);
            return false;
        }
        return false;
    };

    var doNotBlock = function() {
        gmApi.ADG_temporaryDontBlock(30, function() {
            CommonUtils.reloadPageBypassCache();
        });
    };

    var reportAbuse = function() {
        gmApi.ADG_sendAbuse(function() {
            iframeCtrl.removeIframe();
        });
    };

    var goToSiteReport = function() {
        var url = StringUtils.format(settings.Constants.REPORT_URL, domain);
        window.open(url, '_blank');
    };

    var setWotData = function() {
        var wotData = wot.getWotData();
        var wotReputationSettings = getWotReputationSettings(wotData);

        if (wotReputationSettings) {
            var wotIndication = $(contentDocument.getElementById('WotIndication'));
            var wotDescriptionText = contentDocument.getElementById('WotDescriptionText');
            var confidenceIndication = $(contentDocument.getElementById('ConfidenceIndication'));

            contentDocument.getElementsByClassName('wot-indicator')[0].href = wot.getWotScorecardUrl(domain);
            wotIndication.addClass(wotReputationSettings.class);
            var wotLogo = $('<a id="WotLogo" href="#"><span class="wot-logo"></span></a>')[0];
            wotDescriptionText.textContent = wotReputationSettings.text;
            wotDescriptionText.appendChild(wotLogo);

            var wotConfidenceClass = getWotConfidenceClass(wotData);
            confidenceIndication.addClass(wotConfidenceClass);

            $(contentDocument.getElementsByClassName('wot-hide')).removeClass('wot-hide');
        }
    };

    var goToWotUrl = function() {
        window.open(wot.WOT_URL, '_blank');
    };

    var getWotReputationSettings = function(wotData) {
        if (!wotData) {
            return null;
        }
        var prefix = 'adg-wot-';
        var averageWot = wotData.reputation;
        var wotRatingText = null;
        var wotRating = null;
        if (averageWot === 0) {
            wotRatingText = localization.getMessage('wot_unknown_description');
            wotRating = prefix + 'unknown';
            return {
                text: wotRatingText,
                class: wotRating
            };
        }
        var wotSettings = {
            0: {
                color: 'red',
                string: localization.getMessage('wot_bad_description')
            },
            1: {
                color: 'lightRed',
                string: localization.getMessage('wot_poor_description')
            },
            2: {
                color: 'yellow',
                string: localization.getMessage('wot_unsatisfactory_description')
            },
            3: {
                color: 'lightGreen',
                string: localization.getMessage('wot_good_description')
            },
            4: {
                color: 'green',
                string: localization.getMessage('wot_excellent_description')
            },
            5: {
                color: 'green',
                string: localization.getMessage('wot_excellent_description')
            }
        };
        var current = wotSettings[truncateDecimals(averageWot / 20)];
        wotRatingText = current.string;
        wotRating = prefix + current.color;
        return {
            text: wotRatingText,
            class: wotRating
        };
    };

    var truncateDecimals = function(number) {
        return Math[number < 0 ? 'ceil' : 'floor'](number);
    };

    var getWotConfidenceClass = function(wotData) {
        if (!wotData) {
            return null;
        }
        var prefix = 'adg-wot-confidence-';
        var confidenceWot = wotData.confidence;
        if (confidenceWot >= 0 && confidenceWot < 6) {
            return prefix + '0';
        }
        if (confidenceWot >= 6 && confidenceWot < 12) {
            return prefix + '1';
        }
        if (confidenceWot >= 12 && confidenceWot < 23) {
            return prefix + '2';
        }
        if (confidenceWot >= 23 && confidenceWot < 34) {
            return prefix + '3';
        }
        if (confidenceWot >= 34 && confidenceWot < 45) {
            return prefix + '4';
        }
        if (confidenceWot >= 45) {
            return prefix + '5';
        }
    };

    var startAdSelector = function() {
        iframeCtrl.showSelectorMenu();
    };

    var showHideBlockAdButton = function(isFilter) {
        if (isFilter) {
            $(contentDocument.getElementById('block-ad')).removeClass('hidden');
        } else {
            $(contentDocument.getElementById('block-ad')).addClass('hidden');
        }
    };

    return {
        init: init
    };
};

/**
 * Selector menu controller
 * @param $
 * @param selector
 * @returns {{init: init}}
 * @constructor
 */
/* global Ioc */
var SelectorMenuController = function ($, selector) { // jshint ignore:line
    var contentDocument = null;
    var iframeCtrl = Ioc.get('iframeController');

    /*
     Called from IframeController._showMenuItem to initialize view
     */
    var init = function (iframe) {
        contentDocument = iframe.contentDocument;
        bindEvents();
        startSelector();
    };

    var close = function () {
        iframeCtrl.removeIframe();
    };

    var bindEvents = function () {
        var menuEvents = {
            '.close': close,
            '.btn-default': close
        };
        Object.keys(menuEvents).forEach(function (item) {
            $(contentDocument.querySelectorAll(item)).on('click', menuEvents[item]);
        });
    };
    var startSelector = function () {
        selector.reset();
        selector.init(onElementSelected);
    };

    var onElementSelected = function (element) {
        iframeCtrl.showSliderMenu(element);
    };

    iframeCtrl.onCloseMenu.attach(selector.close);

    return {
        init: init
    };
};

/**
 * Slider menu controller mobile
 * @param $
 * @param selector
 * @param sliderWidget
 * @param adguardRulesConstructor
 * @param localization
 * @param addRule
 * @returns {{init: init}}
 * @constructor
 */
/* global Ioc, CommonUtils */
var SliderMenuControllerMobile = function ($, selector, sliderWidget, adguardRulesConstructor, localization, addRule) { // jshint ignore:line
    var contentDocument = null;
    var selectedElement = null;
    var iframeCtrl = Ioc.get('iframeController');

    var nodeParentsCount = 0;
    var nodeChildsCount = 0;
    var parents, children;
    var nodeNumber = 0;

    /*
     Called from IframeController._showMenuItem to initialize view
     */
    var init = function (iframe, options) {
        selectedElement = options.element;
        contentDocument = iframe.contentDocument;
        bindEvents();
        createSlider();
        onScopeChange();
        selector.selectElement(selectedElement);

        children = CommonUtils.getAllChildren(selectedElement);
        parents = CommonUtils.getParentsLevel(selectedElement);

        parents.splice(0,0,selectedElement);

        nodeParentsCount = parents.length;
        nodeChildsCount = children.length;
    };

    var close = function () {
        iframeCtrl.removeIframe();
    };

    var plus = function() {
        (nodeNumber + 1) > nodeParentsCount ? nodeNumber = nodeNumber : nodeNumber++;

        if (nodeNumber >= 0) {
            if (parents[nodeNumber]) onSliderMove(parents[nodeNumber]);
        } else {
            if (children[~nodeNumber]) onSliderMove(children[~nodeNumber]);
        }
    };

    var minus = function() {
        nodeNumber <= -nodeChildsCount ? nodeNumber = nodeNumber : nodeNumber--;

        if (nodeNumber >= 0) {
            if (parents[nodeNumber]) onSliderMove(parents[nodeNumber]);
        } else {
            if (children[~nodeNumber]) onSliderMove(children[~nodeNumber]);
        }
    };

    var bindEvents = function () {
        var menuEvents = {
            '.close': close,
            '#ExtendedSettingsText': expandAdvanced,
            '#adv-settings': onScopeChange,
            '#adg-cancel': iframeCtrl.showSelectorMenu,
            '#adg-preview': showPreview,
            '#adg-accept': blockElement,
            '.adg-slide-btn--plus': plus,
            '.adg-slide-btn--minus': minus
        };
        Object.keys(menuEvents).forEach(function (item) {
            $(contentDocument.querySelectorAll(item)).on('click', menuEvents[item]);
        });

        window.addEventListener('resize', iframeCtrl.showSelectorMenu);
    };

    var blockElement = function () {
        addRule(getFilterRuleInputText());
        iframeCtrl.removeIframe();
    };

    var expandAdvanced = function () {
        var hidden = !$(contentDocument.getElementById('adv-settings')).hasClass("open");
        if (hidden) {
            iframeCtrl.resizeSliderMenuToAdvanced();
            $(contentDocument.getElementById('adv-settings')).addClass('open');
            $(contentDocument.getElementById('ExtendedSettingsText')).addClass('active');
        } else {
            iframeCtrl.resizeSliderMenuToNormal();
            $(contentDocument.getElementById('adv-settings')).removeClass('open');
            $(contentDocument.getElementById('ExtendedSettingsText')).removeClass('active');
        }
    };

    var showPreview = function () {
        iframeCtrl.showBlockPreview(selectedElement, getFilterRuleInputText());
    };

    var createSlider = function () {
        var parents = CommonUtils.getParentsLevel(selectedElement);
        var children = CommonUtils.getAllChildren(selectedElement);
        var value = Math.abs(parents.length + 1);
        var max = parents.length + children.length + 1;
        var min = 1;
        var options = {value: value, min: min, max: max};
        var slider = contentDocument.getElementById('slider');
        var sliderArea = contentDocument.getElementById('slider-area');
        if (min === max) {
            //hide slider text
            $(slider).hide();
            $(contentDocument.getElementsByClassName('element-rule_text')).hide();
            expandAdvanced();
        }

        options.onSliderMove = function (delta) {
            var elem;
            if (delta > 0) {
                elem = parents[delta - 1];
            }
            if (delta === 0) {
                elem = selectedElement;
            }
            if (delta < 0) {
                elem = children[Math.abs(delta + 1)];
            }
            onSliderMove(elem);
        };

        sliderWidget.init(slider, {
            min: options.min,
            max: options.max,
            value: options.value,
            onValueChanged: function (value) {
                var delta = options.value - value;
                options.onSliderMove(delta);
            },
            sliderArea: sliderArea
        });
    };

    var onSliderMove = function (element) {
        selectedElement = element;
        selector.selectElement(element);

        makeDefaultCheckboxesForDetailedMenu();
        onScopeChange();
        handleShowBlockSettings(haveUrlBlockParameter(element), haveClassAttribute(element));
    };

    var makeDefaultCheckboxesForDetailedMenu = function () {
        contentDocument.getElementById('block-by-url-checkbox').checked = false;
        contentDocument.getElementById('block-similar-checkbox').checked = false;
        contentDocument.getElementById('one-domain-checkbox').checked = false;
    };

    var onScopeChange = function () {

        var isBlockByUrl = contentDocument.getElementById('block-by-url-checkbox').checked;
        var isBlockSimilar = contentDocument.getElementById('block-similar-checkbox').checked;
        var isBlockOneDomain = contentDocument.getElementById('one-domain-checkbox').checked;

        handleShowBlockSettings(haveUrlBlockParameter(selectedElement) && !isBlockSimilar, haveClassAttribute(selectedElement) && !isBlockByUrl);

        var options = {
            urlMask: getUrlBlockAttribute(selectedElement),
            cssSelectorType: isBlockSimilar ? "SIMILAR" : "STRICT_FULL",
            isBlockOneDomain: isBlockOneDomain,
            url: document.location,
            ruleType: isBlockByUrl ? "URL" : "CSS"
        };

        var ruleText = adguardRulesConstructor.constructRuleText(selectedElement, options);
        setFilterRuleInputText(ruleText);
    };

    var haveUrlBlockParameter = function (element) {
        var value = getUrlBlockAttribute(element);
        return value && value !== '';
    };

    var getUrlBlockAttribute = function (element) {
        var urlBlockAttributes = ["src", "data"];
        for (var i = 0; i < urlBlockAttributes.length; i++) {
            var attr = urlBlockAttributes[i];
            var value = element.getAttribute(attr);
            if (value) {
                return value;
            }
        }
        return null;
    };

    var haveClassAttribute = function (element) {
        var className = element.getAttribute("class");
        return className && className.trim() !== '';
    };

    var handleShowBlockSettings = function (showBlockByUrl, showBlockSimilar) {
        var blockByUrlBlock = $(contentDocument.getElementById('block-by-url-checkbox-block'));
        var blockSimilarBlock = $(contentDocument.getElementById('block-similar-checkbox-block'));
        if (showBlockByUrl) {
            blockByUrlBlock.show();
        } else {
            contentDocument.getElementById('block-by-url-checkbox').checked = false;
            blockByUrlBlock.hide();
        }
        if (showBlockSimilar) {
            blockSimilarBlock.show();
        } else {
            contentDocument.getElementById('block-similar-checkbox').checked = false;
            blockSimilarBlock.hide();
        }
    };

    var setFilterRuleInputText = function (ruleText) {
        contentDocument.getElementById('filter-rule').value = ruleText;
    };

    var getFilterRuleInputText = function () {
        return contentDocument.getElementById('filter-rule').value;
    };

    return {
        init: init
    };
};

/**
 * Block preview controller
 * @param $
 * @param selector
 * @param gmApi
 * @returns {{init: init}}
 * @constructor
 */
/* global Ioc */
var BlockPreviewController = function ($, selector, gmApi) { // jshint ignore:line
    var contentDocument = null;
    var selectedElement = null;
    var selectedPath = null;
    var iframeCtrl = Ioc.get('iframeController');

    /*
     Called from IframeController.showMenuItem to initialize view
     */
    var init = function (iframe, options) {
        selectedElement = options.element;
        selectedPath = options.path;
        contentDocument = iframe.contentDocument;
        selector.reset();
        bindEvents();
        hideElement();
    };

    var close = function () {
        showElement();
        iframeCtrl.removeIframe();
    };

    var bindEvents = function () {
        var menuEvents = {
            '.close': close,
            '#select-another-element': selectAnotherElement,
            '#end-preview': showDetailedMenu,
            '#block-element': blockElement
        };
        Object.keys(menuEvents).forEach(function (item) {
            $(contentDocument.querySelectorAll(item)).on('click', menuEvents[item]);
        });
    };

    var hideElement = function () {
        if (!selectedElement) {
            return;
        }
        $(selectedElement).addClass('adguard-hide');
    };

    var showElement = function () {
        if (!selectedElement) {
            return;
        }
        $(selectedElement).removeClass('adguard-hide');
    };

    var selectAnotherElement = function () {
        showElement();
        iframeCtrl.showSelectorMenu();
    };

    var blockElement = function () {
        gmApi.ADG_addRule(selectedPath, function() {
            iframeCtrl.removeIframe();
            CommonUtils.reloadPageBypassCache();
        });
    };

    var showDetailedMenu = function () {
        showElement();
        iframeCtrl.showSliderMenu(selectedElement);
    };

    return {
        init: init
    };
};

/**
 * Adguard assistant mobile button
 * @param log Logger
 * @param settings User settings
 * @param uiValidationUtils Validation utils
 * @param $ balalaika
 * @param uiUtils UI Utils
 * @param iframeController Iframe controller
 * @param resources Resources that generates in compiler
 * @returns {{show: show, remove: remove}}
 * @constructor
 */
var UIButtonMobile = function(log, settings, uiValidationUtils, $, uiUtils, iframeController, resources) { // jshint ignore:line
    var button = null;
    var isFullScreenEventsRegistered = false;

    /**
     * Shows Adguard initial button
     */
    var show = function() {
        if (!checkRequirements()) {
            log.info("Environment doesn't satisfy requirements, so don't show Adguard");
            return;
        }
        if (button) {
            return;
        }
        log.debug("Requirements checked, all ok");
        button = $(resources.getResource('button.html'));

        var css = document.createElement('style');
        var styles = resources.getResource('button.css') + resources.getResource('selector.css');

        if (css.styleSheet) {
            css.styleSheet.cssText = styles;
        }else {
            css.appendChild(document.createTextNode(styles));
        }

        document.getElementsByTagName("head")[0].appendChild(css);

        setPositionSettingsToButton(button);
        var body = $('body')[0];
        if (!body) {
            log.error('Cant find body');
        }
        body.appendChild(button[0]);
        registerEvents(button);
    };

    /**
     * Checking browser and other requirements.
     * @private
     */
    var checkRequirements = function() {
        if (!uiValidationUtils.validateBrowser()) {
            log.error('Browser is unsupported');
            return false;
        }

        if (!uiValidationUtils.validatePage()) {
            log.error('Page is iframe or there is no body');
            return false;
        }

        if (!uiValidationUtils.checkVisibleAreaSize()) {
            log.error('Page is too small for button');
            return false;
        }

        if (isButtonAlreadyInDOM()) {
            log.error('Button is allready in DOM');
            return false;
        }
        return true;
    };

    var isButtonAlreadyInDOM = function() {
        return $('.adguard-alert').length > 0;
    };

    var setUserPositionIfExists = function(button) {
        var position = settings.getUserPositionForButton();

        // check if the browser stores old data without a anchor to prevent an error
        if (!position || !position.storedAnchor) {
            return false;
        }

        uiUtils.setAnchorPosition.positionY(button[0], position.storedAnchor.top);
        uiUtils.setAnchorPosition.positionX(button[0], position.storedAnchor.left);

        uiUtils.moveElementTo(button[0], position.x, position.y);

        // validate that button is in the viewport
        // with timeout for deferred execution
        setTimeout(function () {
            uiUtils.checkElementPosition(button[0], position);
        });

        return true;
    };

    var setPositionSettingsToButton = function(button) {
        var config = settings.getSettings();
        if (!config.largeIcon) {
            $(button[0].getElementsByClassName('adguard-a-logo')[0]).addClass('adguard-a-logo__small');
        }
        if (setUserPositionIfExists(button)) {
            return;
        }

        uiUtils.setAnchorPosition.positionY(button[0], config.buttonPositionTop);
        uiUtils.setAnchorPosition.positionX(button[0], config.buttonPositionLeft);

        respectPageElements(button[0]);
    };

    var registerEvents = function(button) {
        var onDragEnd = function(data) {
            settings.setUserPositionForButton(data);
        };

        var openMenu = function() {
            iframeController.setButtonPosition(getButtonPosition());
            iframeController.showSelectorMenu();
        };

        uiUtils.makeElementDraggable(button[0], onDragEnd, openMenu);
        hideRestoreOnFullScreen();
    };

    /**
     * Get center button position
     * @returns {{left: *, top: *}}
     * @private
     */
    var getButtonPosition = function() {
        var box = button[0].getBoundingClientRect();
        return {
            top: box.top + button[0].offsetHeight / 2,
            left: box.left + button[0].offsetWidth / 2
        };
    };

    var hideRestoreOnFullScreen = function() {
        if (isFullScreenEventsRegistered) {
            return;
        }
        $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function() {
            if (uiUtils.tryFullScreenPrefix(document, "FullScreen") || uiUtils.tryFullScreenPrefix(document, "IsFullScreen")) {
                hideButton();
            } else {
                showButton();
            }
        });
        isFullScreenEventsRegistered = true;
    };

    var hideButton = function() {
        if (!button) {
            return;
        }
        button.addClass('adguard-hide');
    };

    var showButton = function() {
        if (!button) {
            return;
        }
        button.removeClass('adguard-hide');
    };

    var removeButton = function() {
        if (!button) {
            return;
        }
        $('body')[0].removeChild(button[0]);
        button = null;
    };

    /**
     * Set a special classes for the pages on which
     * under the button there are important elements
     * issue: https://github.com/AdguardTeam/AdguardAssistant/issues/32
     */
    var respectPageElements = function(element) {
        var buttonInRightBottom =
            $(element).hasClass('adguard-assistant-button-bottom') &&
            $(element).hasClass('adguard-assistant-button-right');

        if (buttonInRightBottom && document.location.hostname.indexOf('vk.com') >= 0) {
            $(element).addClass('adguard-assistant-button-respect adguard-assistant-button-respect-vk');
        }
        if (buttonInRightBottom && document.location.hostname.indexOf('facebook.com') >= 0) {
            $(element).addClass('adguard-assistant-button-respect adguard-assistant-button-respect-fb');
        }
        return false;
    };

    iframeController.onCloseMenu.attach(showButton);
    iframeController.onShowMenuItem.attach(hideButton);

    return {
        show: show,
        remove: removeButton
    };
};

/* global Ioc, Log, Resources, Settings, UIValidationUtils, balalaika, UIUtils, Localization, IframeControllerMobile, SliderWidget, AdguardRulesConstructorLib, AdguardSelectorLib, UIButtonMobile */

this.adguardAssistant = (function() {
    return {
        start: function(callback) {
            Ioc.register('log', new Log());
            Ioc.register('addRule', callback.bind(this));

            Ioc.register('resources', new Resources());
            Ioc.register('$', balalaika);
            Ioc.register('selector', new AdguardSelectorLib({}, balalaika));
            Ioc.register('uiUtils', Ioc.get(UIUtils));
            Ioc.register('localization', Ioc.get(Localization));
            var iframeController = Ioc.get(IframeControllerMobile);
            Ioc.register('iframeController', iframeController);
            Ioc.register('sliderWidget', new SliderWidget({}, balalaika));
            Ioc.register('adguardRulesConstructor', new AdguardRulesConstructorLib({}));

            iframeController.showSelectorMenu();
        }
    };
})();

})();