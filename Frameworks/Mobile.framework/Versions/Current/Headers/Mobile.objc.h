// Objective-C API for talking to github.com/AdguardTeam/dnsproxy/mobile Go package.
//   gobind -lang=objc github.com/AdguardTeam/dnsproxy/mobile
//
// File is generated by gobind. Do not edit.

#ifndef __Mobile_H__
#define __Mobile_H__

@import Foundation;
#include "ref.h"
#include "Universe.objc.h"


@class MobileConfig;
@class MobileDNSProxy;
@class MobileDNSStamp;
@class MobileLogWriterAdapter;
@protocol MobileLogWriter;
@class MobileLogWriter;

@protocol MobileLogWriter <NSObject>
- (void)write:(NSString*)s;
@end

/**
 * Config is the DNS proxy configuration which uses only the subset of types that is supported by gomobile
In Java API this structure becomes an object that needs to be configured and setted as field of DNSProxy
 */
@interface MobileConfig : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) id _ref;

- (instancetype)initWithRef:(id)ref;
- (instancetype)init;
@property (nonatomic) NSString* listenAddr;
@property (nonatomic) long listenPort;
@property (nonatomic) NSString* bootstrapDNS;
@property (nonatomic) NSString* fallbacks;
@property (nonatomic) NSString* upstreams;
@property (nonatomic) long timeout;
@property (nonatomic) BOOL allServers;
@end

/**
 * DNSProxy represents a proxy with it's configuration
 */
@interface MobileDNSProxy : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) id _ref;

- (instancetype)initWithRef:(id)ref;
- (instancetype)init;
@property (nonatomic) MobileConfig* config;
// skipped field DNSProxy.RWMutex with unsupported type: sync.RWMutex

/**
 * Addr gets the address proxy is currently listening to
 */
- (NSString*)addr;
- (void)lock;
- (void)rLock;
// skipped method DNSProxy.RLocker with unsupported parameter or return types

- (void)rUnlock;
/**
 * Start starts the DNS proxy
 */
- (BOOL)start:(NSError**)error;
/**
 * Stop stops the DNS proxy
 */
- (BOOL)stop:(NSError**)error;
- (void)unlock;
@end

/**
 * DNSStamp is mobile-friendly DNS stamp structure
 */
@interface MobileDNSStamp : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) id _ref;

- (instancetype)initWithRef:(id)ref;
- (instancetype)init;
@property (nonatomic) long proto;
@property (nonatomic) NSString* serverAddr;
@property (nonatomic) NSString* providerName;
@property (nonatomic) NSString* path;
@end

/**
 * LogWriterAdapter between go log and LogWriter
 */
@interface MobileLogWriterAdapter : NSObject <goSeqRefInterface> {
}
@property(strong, readonly) id _ref;

- (instancetype)initWithRef:(id)ref;
- (instancetype)init;
- (BOOL)write:(NSData*)p0 n:(long*)n error:(NSError**)error;
@end

/**
 * ConfigureLogger function is called from mobile API to write dnsproxy log into mobile log
You need to create object that implements LogWriter interface and set it as argument of this function
 */
FOUNDATION_EXPORT BOOL MobileConfigureLogger(BOOL verbose, NSString* stderrRedirectPath, id<MobileLogWriter> w, NSError** error);

/**
 * ParseDNSStamp parses a DNS stamp string and returns a stamp instance or an error
 */
FOUNDATION_EXPORT MobileDNSStamp* MobileParseDNSStamp(NSString* stampStr, NSError** error);

/**
 * TestUpstream checks if upstream is valid and available
If it is, no error is returned. Otherwise this method returns an error with an explanation.
* address - see upstream.AddressToUpstream for examples
* bootstrap - an optional bootstrap DNS. You can pass multiple addresses by separating them with a newline
* timeout - timeout in milliseconds
 */
FOUNDATION_EXPORT BOOL MobileTestUpstream(NSString* address, NSString* bootstrap, long timeout, NSError** error);

@class MobileLogWriter;

/**
 * LogWriter interface should be implemented inside project that will use dnsproxy mobile API to write dnsproxy log into mobile log
 */
@interface MobileLogWriter : NSObject <goSeqRefInterface, MobileLogWriter> {
}
@property(strong, readonly) id _ref;

- (instancetype)initWithRef:(id)ref;
- (void)write:(NSString*)s;
@end

#endif
